{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\n\nvar _graph = require(\"./graph.helper\");\n\nvar _utils = require(\"../../utils\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree.inDegree,\n      outDegree = _computeNodeDegree.outDegree;\n\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      directed = _ref.directed;\n\n  var rootConnectionsNodesIds = linksMatrix[rootNodeId] ? Object.keys(linksMatrix[rootNodeId]) : [];\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  var node = nodes[nodeId];\n\n  if (!node) {\n    if (process.env.NODE_ENV === \"development\") {\n      (0, _utils.logError)(\"graph/collapse.helper\", \"Trying to check if node \".concat(nodeId, \" is visible but its not present in nodes: \"), nodes);\n    }\n\n    return false;\n  }\n\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree2.inDegree,\n      outDegree = _computeNodeDegree2.outDegree;\n\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n        target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}","map":{"version":3,"sources":["/home/telix/dictio-grapho/node_modules/react-d3-graph/lib/components/graph/collapse.helper.js"],"names":["Object","defineProperty","exports","value","computeNodeDegree","getTargetLeafConnections","isNodeVisible","toggleLinksConnections","toggleLinksMatrixConnections","_graph","require","_utils","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","_isLeafDirected","inDegree","outDegree","_isLeafNotDirected","_isLeaf","nodeId","linksMatrix","directed","_computeNodeDegree","fn","undefined","reduce","acc","currentNodeConnections","_acc","rootNodeId","_ref","rootConnectionsNodesIds","leafConnections","nodes","node","process","env","NODE_ENV","logError","concat","_orphan","_computeNodeDegree2","d3Links","connectionMatrix","map","d3Link","sourceId","getId","targetId","connection","isHidden","connections","_ref2","newMatrix","link","newConnectionValue"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\n\nvar _graph = require(\"./graph.helper\");\n\nvar _utils = require(\"../../utils\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree.inDegree,\n      outDegree = _computeNodeDegree.outDegree;\n\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      directed = _ref.directed;\n\n  var rootConnectionsNodesIds = linksMatrix[rootNodeId] ? Object.keys(linksMatrix[rootNodeId]) : [];\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  var node = nodes[nodeId];\n\n  if (!node) {\n    if (process.env.NODE_ENV === \"development\") {\n      (0, _utils.logError)(\"graph/collapse.helper\", \"Trying to check if node \".concat(nodeId, \" is visible but its not present in nodes: \"), nodes);\n    }\n\n    return false;\n  }\n\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree2.inDegree,\n      outDegree = _computeNodeDegree2.outDegree;\n\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n        target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}"]},"metadata":{},"sourceType":"script"}
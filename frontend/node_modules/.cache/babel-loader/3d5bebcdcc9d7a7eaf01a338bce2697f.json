{"ast":null,"code":"var _jsxFileName = \"/home/telix/dictio-grapho/frontend/src/App.js\";\nimport React from 'react';\nimport './App.css';\nimport { Graph } from \"react-d3-graph\";\nimport { genRandomNode, genGrapNodes, genPath } from \"./RandomGenerator\";\nimport myConfig from \"./myConfig\";\nconst API_ENDPOINT = 'http://127.0.0.1:8000/api/v1/';\nconst initial_words = {\n  words: [\"anxious\", \"edgy\", \"upset\"]\n}; // graph payload (with minimalist structure)\n\nconst state_guide = {\n  nodes: [{\n    id: \"zine\"\n  }, {\n    id: \"cool\"\n  }, {\n    id: \"world\"\n  }],\n  links: [{\n    source: \"zine\",\n    target: \"cool\"\n  }, {\n    source: \"zine\",\n    target: \"world\"\n  }],\n  isError: false,\n  isLoading: true,\n  searchTerm: '',\n  DestinationTerm: ''\n}; // graph payload (with minimalist structure)\n\nconst initial_state = {\n  nodes: [{\n    id: \"zine\",\n    synonyms: ['anxious']\n  }, {\n    id: \"cool\",\n    synonyms: ['anxious']\n  }, {\n    id: \"world\",\n    synonyms: []\n  }],\n  links: [{\n    source: \"zine\",\n    target: \"cool\"\n  }, {\n    source: \"zine\",\n    target: \"world\"\n  }],\n  isError: false,\n  isLoading: true,\n  searchTerm: '',\n  DestinationTerm: ''\n};\n\nfunction App() {\n  // make reducer for the words data and internal state \n  const stateReducer = (state, action) => {\n    switch (action.type) {\n      case 'SET_NEW_NODES':\n        return { ...state,\n          nodes: [...state.nodes, ...action.payload]\n        };\n\n      case 'SET_NEW_LINKS':\n        return { ...state,\n          links: [...state.links, ...action.payload]\n        };\n\n      case 'RESET_NODE':\n        return { ...state,\n          nodes: [],\n          links: []\n        };\n\n      case 'SET_FETCH_FAILED':\n        return { ...state,\n          isError: true\n        };\n\n      default:\n        throw new Error();\n    }\n  };\n\n  const [state, dispatchState] = React.useReducer(stateReducer, initial_state);\n  /* define dispatcher for the Internal data */\n\n  const processNode = node => {\n    /* process a node from the api into one for the dispatcher\n     * it changes title for id, for instance */\n    node['id'] = node.title;\n    return node;\n  };\n\n  const createLinks = newNode => {\n    /* This is pornography, but it basically check if a new word is a synonym of one already \n    \tor if the new word has synonyms one of the words already in state */\n    let newLinks = [];\n\n    let makeLink = (synonym, target) => {\n      console.log(synonym);\n      console.log(target);\n\n      if (synonym === target) {\n        newLinks.add({\n          source: synonym,\n          target: target\n        });\n      }\n    }; // look if state nodes are symnonyms to new word\n\n\n    state.nodes.every(node => node.synonyms.every(synonym => makeLink(synonym[\"synonym\"], newNode.id))); // look if new word has a synonym to to state word\n\n    newNode.synonyms.every(synonym => state.nodes.every(node => makeLink(node.id, synonym[\"synonym\"])));\n    return newLinks;\n  };\n\n  const loadNodes = nodes => {\n    /* append array of nodes with a waiting time in between them so that they flow\n     * also create new links and append them to state */\n    if (!Array.isArray(nodes)) nodes = [nodes]; // if a single node was passed\n    // if passed is an array\n\n    nodes.every(node => {\n      node = processNode(node);\n      let links = createLinks(node);\n      console.log(\"got upto here, woah...\");\n      console.log(node);\n      console.log(links);\n      setTimeout(() => {\n        dispatchState({\n          type: 'SET_NEW_NODES',\n          payload: [node]\n        });\n        dispatchState({\n          type: 'SET_NEW_LINKS',\n          payload: links\n        });\n      }, 200);\n    });\n  };\n\n  const requestNode = word => {\n    /* request a single node to the api and disptch to state */\n    fetch(API_ENDPOINT + word).then(result => result.json()).then(result => processNode(result)).then(result => loadNodes(result)).catch(() => dispatchState({\n      type: 'SET_FETCH_FAILED'\n    }));\n  };\n\n  const requestSurroundingNodes = node => {}; // get surounding nodes \n  // for synonym in node, request_node(synonym)\n  // get nodes Async\n\n\n  const getNodesAsync = word => new Promise((resolve, reject) => setTimeout(() => resolve(genGrapNodes(word, 0)), 200)); // get nodes Async\n\n\n  const getPathAsync = (word, dest) => new Promise((resolve, reject) => setTimeout(() => resolve(genPath(word, dest)), 200));\n  /*\n  // add a random nodes\n  const addNodesAsync = () => { \n  \t\tgetWordAsync()\n  \t\t\t\t.then( (result) => setTimeout(() =>  dispatchState({ type: 'SET_NEW_NODE', payload: result }), 200))\n  \t\t\t\t.catch( () => dispatchState({ type: 'SET_FETCH_FAILED' }) );\n  }\n  \t// append nodes in a path \n  async function appendPathAsync(word, dest){ \n  \t\tgetPathAsync(word, dest)\n  \t\t\t\t.then(result => dispatchNodesAsync(result))\n  \t\t\t\t.catch(() => dispatchState({ type: 'SET_FETCH_FAILED' }));\n  }\n  \t*/\n  // fuction for make a persitant state\n\n\n  const useSemiPersistentSate = key => {\n    const [value, setValue] = React.useState(localStorage.getItem(key) || '');\n    React.useEffect(key => {\n      localStorage.setItem(key, value);\n    }, [value]);\n    return [value, setValue];\n  }; // get state fuctions\n\n\n  const [searchTerm, setSearchTerm] = useSemiPersistentSate('search'); // get state fuctions\n\n  const [destinationTerm, setDestinationTerm] = useSemiPersistentSate('destination'); // handle the change by seting the state variable to \n\n  const handleSearchChange = change => setSearchTerm(change.target.value); // handle the change by seting the state variable to \n\n\n  const handleDestinationChange = change => setDestinationTerm(change.target.value); // handle submit search button\n\n\n  const handleSearchSubmit = () => {\n    dispatchState({\n      type: 'RESET_NODE',\n      payload: {\n        node: {\n          id: searchTerm\n        }\n      }\n    }); // appendNodesAsync(searchTerm);\n  }; // get node info\n  // handle path button\n\n\n  const handlePathSubmit = () => {\n    //  reset graph\n    dispatchState({\n      type: 'RESET_NODE',\n      payload: {\n        node: {\n          id: searchTerm\n        }\n      }\n    }); // appendPathAsync(searchTerm, destinationTerm);\n  };\n\n  const onClickNode = function (nodeId) {\n    console.log(`clicked node ${nodeId}`); // appendNodesAsync(nodeId);\n  };\n\n  const onRightClickNode = function (event, nodeId) {\n    window.alert(`Right clicked node ${nodeId}`);\n  };\n\n  const onClickLink = function (source, target) {\n    window.alert(`Clicked link between ${source} and ${target}`);\n  };\n\n  const onRightClickLink = function (event, source, target) {\n    window.alert(`Right clicked link between ${source} and ${target}`);\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(InputWithLabel, {\n    id: \"search\",\n    type: \"text\",\n    isFocuse: true,\n    value: searchTerm,\n    onInputChange: handleSearchChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 11\n    }\n  }, \"Search:\")), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    disable: !searchTerm,\n    onClick: handleSearchSubmit,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 216,\n      columnNumber: 9\n    }\n  }, \"Search\"), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    onClick: () => requestNode(\"anxious\"),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 9\n    }\n  }, \"Add random Nodes\")), /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(InputWithLabel, {\n    id: \"destination\",\n    type: \"text\",\n    value: destinationTerm,\n    onInputChange: handleDestinationChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 225,\n      columnNumber: 11\n    }\n  }, \"Destination:\")), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    disable: !destinationTerm,\n    onClick: handlePathSubmit,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 227,\n      columnNumber: 9\n    }\n  }, \"Get path\")), /*#__PURE__*/React.createElement(Graph, {\n    id: \"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n    ,\n    data: state,\n    config: myConfig,\n    onClickNode: onClickNode,\n    onRightClickNode: onRightClickNode,\n    onClickLink: onClickLink,\n    onRightClickLink: onRightClickLink,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }\n  }));\n}\n\nconst InputWithLabel = ({\n  id,\n  type,\n  value,\n  onInputChange,\n  isFocused,\n  children\n}) => {\n  /* A component with the Input and a Label */\n  // Define an input ref for passing to input component\n  const inputRef = React.useRef(); // set up a side effect it is updates if the focus changes\n\n  React.useEffect(() => {\n    if (isFocused && inputRef.current) inputRef.current.focused();\n  }, [isFocused]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: id,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 5\n    }\n  }, \" \", children, \" \"), \"\\xA0\", /*#__PURE__*/React.createElement(\"input\", {\n    id: id,\n    ref: inputRef,\n    type: type,\n    value: value,\n    onChange: onInputChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 253,\n      columnNumber: 5\n    }\n  }));\n};\n\nexport default App;","map":{"version":3,"sources":["/home/telix/dictio-grapho/frontend/src/App.js"],"names":["React","Graph","genRandomNode","genGrapNodes","genPath","myConfig","API_ENDPOINT","initial_words","words","state_guide","nodes","id","links","source","target","isError","isLoading","searchTerm","DestinationTerm","initial_state","synonyms","App","stateReducer","state","action","type","payload","Error","dispatchState","useReducer","processNode","node","title","createLinks","newNode","newLinks","makeLink","synonym","console","log","add","every","loadNodes","Array","isArray","setTimeout","requestNode","word","fetch","then","result","json","catch","requestSurroundingNodes","getNodesAsync","Promise","resolve","reject","getPathAsync","dest","useSemiPersistentSate","key","value","setValue","useState","localStorage","getItem","useEffect","setItem","setSearchTerm","destinationTerm","setDestinationTerm","handleSearchChange","change","handleDestinationChange","handleSearchSubmit","handlePathSubmit","onClickNode","nodeId","onRightClickNode","event","window","alert","onClickLink","onRightClickLink","InputWithLabel","onInputChange","isFocused","children","inputRef","useRef","current","focused"],"mappings":"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","sourcesContent":["import React from 'react';\nimport './App.css';\nimport { Graph } from \"react-d3-graph\";\nimport { genRandomNode, genGrapNodes, genPath } from \"./RandomGenerator\";\nimport  myConfig  from \"./myConfig\";\n\nconst API_ENDPOINT = 'http://127.0.0.1:8000/api/v1/'\n\nconst initial_words = {\n\t\twords: [ \"anxious\", \"edgy\" , \"upset\" ]\n}\n\n\n// graph payload (with minimalist structure)\nconst state_guide = {\n\t\tnodes: [{ id: \"zine\", }, { id: \"cool\" }, { id: \"world\" }],\n\t\tlinks: [\n\t\t\t\t{ source: \"zine\", target: \"cool\"  },\n\t\t\t\t{ source: \"zine\", target: \"world\" },\n\t\t],\n\t\tisError: false,\n\t\tisLoading: true,\n\t\tsearchTerm: '',\n\t\tDestinationTerm: '',\n};\n\n\n// graph payload (with minimalist structure)\nconst initial_state = {\n\t\tnodes: [{ id: \"zine\", synonyms:['anxious', ] }, { id: \"cool\", synonyms:['anxious',]}, { id: \"world\", synonyms:[]}],\n\t\tlinks: [\n\t\t\t\t{ source: \"zine\", target: \"cool\"  },\n\t\t\t\t{ source: \"zine\", target: \"world\" },\n\t\t],\n\t\tisError: false,\n\t\tisLoading: true,\n\t\tsearchTerm: '',\n\t\tDestinationTerm: '',\n};\n\n\nfunction App() {\n\n\n\t\t// make reducer for the words data and internal state \n\t\tconst stateReducer = (state, action) =>{\n\t\t\t\tswitch (action.type){\n\t\t\t\t\t\tcase 'SET_NEW_NODES':\n\t\t\t\t\t\t\t\treturn { \n\t\t\t\t\t\t\t\t\t\t...state, \n\t\t\t\t\t\t\t\t\t\tnodes: [ ...state.nodes, ...action.payload ],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'SET_NEW_LINKS':\n\t\t\t\t\t\t\t\treturn { \n\t\t\t\t\t\t\t\t\t\t...state, \n\t\t\t\t\t\t\t\t\t\tlinks: [ ...state.links, ...action.payload ]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'RESET_NODE':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\t\t\t\tlinks: [],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'SET_FETCH_FAILED':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tisError: true,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\t\t}\n\n\t\tconst [state, dispatchState] = React.useReducer( stateReducer, initial_state );\n\t\t/* define dispatcher for the Internal data */\n\n\t\tconst processNode = (node) =>{\n\t\t\t\t/* process a node from the api into one for the dispatcher\n\t\t\t\t * it changes title for id, for instance */\n\t\t\t\tnode['id'] = node.title\n\t\t\t\treturn node\n\t\t}\n\n\t\tconst createLinks = (newNode) => {\n\t\t\t\t/* This is pornography, but it basically check if a new word is a synonym of one already \n\t\t\t\t\tor if the new word has synonyms one of the words already in state */\n\t\t\t\tlet newLinks = [];\n\t\t\t\tlet makeLink = (synonym, target) => { \n\t\t\t\t\t\tconsole.log(synonym);\n\t\t\t\t\t\tconsole.log(target);\n\t\t\t\t\t\tif(synonym === target){\n\t\t\t\t\t\t\t\tnewLinks.add({ source: synonym, target: target })\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// look if state nodes are symnonyms to new word\n\t\t\t\tstate.nodes.every( (node) => node.synonyms.every( (synonym) => makeLink(synonym[\"synonym\"], newNode.id)));\n\t\t\t\t// look if new word has a synonym to to state word\n\t\t\t\tnewNode.synonyms.every( (synonym) => state.nodes.every( (node) => makeLink(node.id, synonym[\"synonym\"])));\n\t\t\t\treturn newLinks\n\t\t} \n\n\t\tconst  loadNodes = (nodes) => {\n\t\t\t\t/* append array of nodes with a waiting time in between them so that they flow\n\t\t\t\t * also create new links and append them to state */\n\t\t\t\tif(!Array.isArray(nodes)) nodes = [nodes,]  // if a single node was passed\n\t\t\t\t// if passed is an array\n\t\t\t\tnodes.every( (node) => { \n\t\t\t\t\t\tnode = processNode(node)\n\t\t\t\t\t\tlet links = createLinks(node)\n\t\t\t\t\t\tconsole.log(\"got upto here, woah...\")\n\t\t\t\t\t\tconsole.log(node)\n\t\t\t\t\t\tconsole.log(links)\n\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\t\tdispatchState({ type: 'SET_NEW_NODES', payload: [node,]})\n\t\t\t\t\t\t\t\tdispatchState({ type: 'SET_NEW_LINKS', payload: links })\n\t\t\t\t\t\t}, 200 );\n\t\t\t\t}\n\t\t\t\t)\n\t\t}\n\t\t\n\n\t\tconst requestNode = (word) => { \n\t\t\t\t/* request a single node to the api and disptch to state */\n\t\t\t\tfetch(API_ENDPOINT + word) \n\t\t\t\t\t\t.then( result => result.json())\n\t\t\t\t\t\t.then( result => processNode(result))\n\t\t\t\t\t\t.then( result => loadNodes(result))\n\t\t\t\t\t\t.catch( () => dispatchState({ type: 'SET_FETCH_FAILED' }) );\n\t\t}\n\t\t\n\t\tconst requestSurroundingNodes = (node) =>{\n\t\t\t\n\t\t}\n\n\t\t// get surounding nodes \n\t\t\t// for synonym in node, request_node(synonym)\n\n\t\t// get nodes Async\n\t\tconst getNodesAsync = (word)=> new Promise((resolve, reject)=> setTimeout(()=> resolve(genGrapNodes(word, 0)), 200));\n\n\t\t// get nodes Async\n\t\tconst getPathAsync =(word, dest)=> new Promise((resolve, reject)=> setTimeout(()=> resolve(genPath(word, dest)), 200));\n\n\t\t/*\n\t\t// add a random nodes\n\t\tconst addNodesAsync = () => { \n\t\t\t\tgetWordAsync()\n\t\t\t\t\t\t.then( (result) => setTimeout(() =>  dispatchState({ type: 'SET_NEW_NODE', payload: result }), 200))\n\t\t\t\t\t\t.catch( () => dispatchState({ type: 'SET_FETCH_FAILED' }) );\n\t\t}\n\n\t\t// append nodes in a path \n\t\tasync function appendPathAsync(word, dest){ \n\t\t\t\tgetPathAsync(word, dest)\n\t\t\t\t\t\t.then(result => dispatchNodesAsync(result))\n\t\t\t\t\t\t.catch(() => dispatchState({ type: 'SET_FETCH_FAILED' }));\n\t\t}\n\n\t\t*/\n\n\t\t// fuction for make a persitant state\n\t\tconst useSemiPersistentSate = key => { \n\t\t\t\tconst [value, setValue] = React.useState( localStorage.getItem(key) || '');\n\t\t\t\tReact.useEffect( (key) => { localStorage.setItem(key, value)} , [value] );\n\t\t\t\treturn [value, setValue];\n\t\t}\n\n\t\t// get state fuctions\n\t\tconst [ searchTerm, setSearchTerm] = useSemiPersistentSate('search');\n\t\t// get state fuctions\n\t\tconst [ destinationTerm, setDestinationTerm] = useSemiPersistentSate('destination');\n\n\t\t// handle the change by seting the state variable to \n\t\tconst handleSearchChange = change => setSearchTerm(change.target.value);\n\t\t// handle the change by seting the state variable to \n\t\tconst handleDestinationChange = change => setDestinationTerm(change.target.value);\n\n\t\t// handle submit search button\n\t\tconst handleSearchSubmit = () => { \n\t\t\t\tdispatchState({ type: 'RESET_NODE', payload:{ node:{ id: searchTerm } } });\n\t\t\t\t// appendNodesAsync(searchTerm);\n\t\t};\n\n\t\t// get node info\n\n\t\t// handle path button\n\t\tconst handlePathSubmit = () => { \n\t\t\t\t//  reset graph\n\t\t\t\tdispatchState({ type: 'RESET_NODE', payload:{ node:{ id: searchTerm } } });\n\t\t\t\t// appendPathAsync(searchTerm, destinationTerm);\n\t\t};\n\n\t\tconst onClickNode = function(nodeId) {\n\t\t\t\tconsole.log(`clicked node ${nodeId}`);\n\t\t\t\t// appendNodesAsync(nodeId);\n\t\t};\n\n\t\tconst onRightClickNode = function(event, nodeId) {\n\t\t\t\twindow.alert(`Right clicked node ${nodeId}`);\n\t\t};\n\n\t\tconst onClickLink = function(source, target) {\n\t\t\t\twindow.alert(`Clicked link between ${source} and ${target}`);\n\t\t};\n\n\t\tconst onRightClickLink = function(event, source, target) {\n\t\t\t\twindow.alert(`Right clicked link between ${source} and ${target}`);\n\t\t};\n\n\t\treturn (\n\t\t\t\t<div className=\"App\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<InputWithLabel id=\"search\" type=\"text\" isFocuse value={searchTerm} onInputChange={handleSearchChange}>\n\t\t\t\t\t\t\t\t\t\t<strong>Search:</strong>\n\t\t\t\t\t\t\t\t</InputWithLabel>\n\t\t\t\t\t\t\t\t<button type=\"button\" disable={!searchTerm} onClick={handleSearchSubmit}>\n\t\t\t\t\t\t\t\t\t\tSearch\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" onClick={ () => requestNode(\"anxious\") }>\n\t\t\t\t\t\t\t\t\t\tAdd random Nodes\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<InputWithLabel id=\"destination\" type=\"text\" value={destinationTerm} onInputChange={handleDestinationChange}>\n\t\t\t\t\t\t\t\t\t\t<strong>Destination:</strong>\n\t\t\t\t\t\t\t\t</InputWithLabel>\n\t\t\t\t\t\t\t\t<button type=\"button\" disable={!destinationTerm} onClick={handlePathSubmit}>\n\t\t\t\t\t\t\t\t\t\tGet path\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<Graph\n\t\t\t\t\t\t\t\tid=\"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n\t\t\t\t\t\t\t\tdata={state}\n\t\t\t\t\t\t\t\tconfig={myConfig}\n\t\t\t\t\t\t\t\tonClickNode={onClickNode}\n\t\t\t\t\t\t\t\tonRightClickNode={onRightClickNode}\n\t\t\t\t\t\t\t\tonClickLink={onClickLink}\n\t\t\t\t\t\t\t\tonRightClickLink={onRightClickLink}\n\t\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t);\n}\n\nconst InputWithLabel = ({ id, type, value, onInputChange, isFocused, children }) => {\n\t\t/* A component with the Input and a Label */\n\t\t// Define an input ref for passing to input component\n\t\tconst inputRef = React.useRef()\n\t\t// set up a side effect it is updates if the focus changes\n\t\tReact.useEffect(() => { if(isFocused && inputRef.current) inputRef.current.focused(); }, [isFocused])\n\t\treturn <>\n\t\t\t\t<label htmlFor={id}> {children} </label>\n\t\t\t\t&nbsp;\n\t\t\t\t<input id={id} ref={inputRef} type={type} value={value} onChange={onInputChange}/>\n\t\t</>\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}
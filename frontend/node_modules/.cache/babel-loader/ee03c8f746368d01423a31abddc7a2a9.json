{"ast":null,"code":"// function for getting random num\nexport const getRandomInt = max => {\n  return Math.floor(Math.random() * Math.floor(max)) + 1;\n}; // fuction for getting a random string\n\nexport const getRandomStr = length => {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\n  return result;\n}; //generate random link\n\nexport const getRandomLinks = (link_number, word, nodes) => {\n  var seen_targets = [];\n  var links = [];\n\n  for (var i = 0; i < link_number; i++) {\n    var target = nodes[getRandomInt(nodes.length - 1)].id;\n\n    if (!seen_targets.includes(target)) {\n      links.push({\n        source: word,\n        target: target\n      });\n      seen_targets.push(target);\n    }\n  }\n\n  return links;\n}; // Generate a random node \n\nexport const genRandomNode = nodes => {\n  var title = getRandomStr(6);\n  var links = getRandomLinks(getRandomInt(6), title, nodes);\n  return {\n    node: {\n      id: title\n    },\n    links\n  };\n}; // generate a list of grapth recursibly\n\nexport const genGrapNodes = (word, depth = 0, data = []) => {\n  for (var i = 0; i < getRandomInt(3); i++) {\n    var adjacent_word = getRandomStr(8);\n    data.push({\n      node: {\n        id: adjacent_word\n      },\n      links: [{\n        source: word,\n        target: adjacent_word\n      }]\n    });\n    if (depth > 0) genGrapNodes(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};\nexport const makeNode = (curNode, nextNode, color = false) => {\n  return {\n    node: {\n      id: nextNode,\n      color: color\n    },\n    links: [{\n      source: currentNode,\n      target: nextNode,\n      color: color\n    }]\n  };\n}; // Generate a Nodes path from  node to the other\n\nexport const genPath = (start, destination) => {\n  selectedColor = 'red';\n  let distance = getRandomInt(10) + 5;\n  let currentNode = start;\n  let data = [];\n  data.push({\n    node: {\n      id: start,\n      color: selectedColor\n    }\n  });\n\n  for (var i = 0; i < distance; i++) {\n    var nextNode = getRandomStr(8);\n    data.push({\n      node: {\n        id: nextNode,\n        color: 'red'\n      },\n      links: [{\n        source: currentNode,\n        target: nextNode,\n        color: 'red'\n      }]\n    });\n\n    for (var j = 0; j < getRandomInt(5); j++) {\n      var adjacentNode = getRandomStr(8);\n      data.push({\n        node: {\n          id: adjacentNode\n        },\n        links: [{\n          source: nextNode,\n          target: adjacentNode\n        }]\n      });\n    }\n\n    currentNode = nextNode;\n  }\n\n  data.push({\n    node: {\n      id: destination,\n      color: 'red'\n    },\n    links: [{\n      source: currentNode,\n      target: destination,\n      color: 'red'\n    }]\n  });\n  return data;\n}; // generate a list of grapth recursibly sent them in lists \n\nexport const genGrapDepth = (word, depth = 0, data = {\n  nodes: [],\n  links: []\n}) => {\n  // Add word to data nodes \n  data.nodes.push({\n    id: word\n  }); //for word get adjacent words into link data\n\n  if (depth <= 0) return data;\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    //gen a adjecent word\n    var adjacent_word = getRandomStr(8); // Add link \n\n    data.links.push({\n      source: word,\n      target: adjacent_word\n    }); // be a recursive bitch\n\n    genGrapDepth(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/telix/dictio-grapho/src/RandomGenerator.js"],"names":["getRandomInt","max","Math","floor","random","getRandomStr","length","result","characters","charactersLength","i","charAt","getRandomLinks","link_number","word","nodes","seen_targets","links","target","id","includes","push","source","genRandomNode","title","node","genGrapNodes","depth","data","adjacent_word","makeNode","curNode","nextNode","color","currentNode","genPath","start","destination","selectedColor","distance","j","adjacentNode","genGrapDepth"],"mappings":"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","sourcesContent":["\n// function for getting random num\nexport const getRandomInt = (max) => {\n\t\treturn Math.floor(Math.random() * Math.floor(max))+1 ;\n}\n\n// fuction for getting a random string\nexport const getRandomStr = (length) => {\n\t\tvar result           = '';\n\t\tvar characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t\tvar charactersLength = characters.length;\n\t\tfor ( var i = 0; i < length; i++ ) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t\treturn result;\n}\n\n//generate random link\nexport const getRandomLinks = (link_number, word, nodes) => {\n\t\tvar seen_targets = [] \n\t\tvar links = [];\n\t\tfor (var i = 0; i < link_number; i++ ){\n\t\t\t\tvar target = nodes[getRandomInt(nodes.length-1)].id;\n\t\t\t\tif(!seen_targets.includes(target)){\n\t\t\t\t\t\tlinks.push({ source: word, target: target });\n\t\t\t\t\t\tseen_targets.push(target);\n\t\t\t\t}\n\t\t}\n\t\treturn links;\n}\n\n// Generate a random node \nexport const genRandomNode = (nodes) => {\n\t\tvar title = getRandomStr(6);\n\t\tvar links = getRandomLinks(getRandomInt(6), title, nodes);\n\t\treturn { node:{ id: title }, links };\n}\n\n\n// generate a list of grapth recursibly\nexport const genGrapNodes = (word, depth=0, data=[]) =>{\n\t\tfor(var i = 0; i < getRandomInt(3); i++){\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\tdata.push({  node:{id: adjacent_word }, links:[{ source: word, target: adjacent_word }] });\n\t\t\t\tif( depth > 0 ) genGrapNodes(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\nexport const makeNode = (curNode, nextNode, color=false) => {\n\t\t\t\treturn { \n\t\t\t\t\t\tnode:{ id: nextNode, color: color}, \n\t\t\t\t\t\tlinks:[{ source: currentNode, target: nextNode, color: color}] \n\t\t\t\t}\n\t\t};\n\n// Generate a Nodes path from  node to the other\nexport const genPath = (start, destination) =>{\n\t\tselectedColor = 'red';\n\t\t\n\t\tlet distance  = getRandomInt(10) + 5;\n\t\tlet currentNode = start;\n\t\tlet data = [];\n\t\tdata.push({node:{ id: start, color: selectedColor }})\n\t\tfor(var i = 0; i < distance; i++){\n\t\t\t\tvar nextNode = getRandomStr(8);\n\t\t\t\tdata.push({ node:{ id: nextNode, color: 'red' }, links:[{ source: currentNode, target: nextNode, color: 'red'}] })\n\t\t\t\tfor(var j = 0; j < getRandomInt(5); j++){\n\t\t\t\t\t\tvar adjacentNode = getRandomStr(8);\n\t\t\t\t\t\tdata.push({ node:{ id: adjacentNode }, links:[{ source: nextNode, target: adjacentNode }] })\n\t\t\t\t}\n\t\t\t\tcurrentNode = nextNode;\n\t\t}\n\t\tdata.push({ node:{ id: destination, color: 'red'},  links:[{ source: currentNode, target: destination, color: 'red'}] })\n\t\treturn data;\n}\n\n\n// generate a list of grapth recursibly sent them in lists \nexport const genGrapDepth = (word, depth=0, data={ nodes:[], links:[] }) =>{\n\t\t// Add word to data nodes \n\t\tdata.nodes.push({ id: word });\n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) return data;\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\t//gen a adjecent word\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\t// Add link \n\t\t\t\tdata.links.push({ source: word, target: adjacent_word });\n\t\t\t\t// be a recursive bitch\n\t\t\t\tgenGrapDepth(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export default function (x) {\n  if (isNaN(x = +x)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      x1 = this._x1; // If the binarytree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing half boundaries don’t change due to floating point error!\n\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n  } // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1) {\n      var z = x1 - x0,\n          node = this._root,\n          parent,\n          i;\n\n      switch (i = +(x < (x0 + x1) / 2)) {\n        case 0:\n          {\n            do {\n              parent = new Array(2), parent[i] = node, node = parent;\n            } while ((z *= 2, x1 = x0 + z, x > x1));\n\n            break;\n          }\n\n        case 1:\n          {\n            do {\n              parent = new Array(2), parent[i] = node, node = parent;\n            } while ((z *= 2, x0 = x1 - z, x0 > x));\n\n            break;\n          }\n      }\n\n      if (this._root && this._root.length) this._root = node;\n    } // If the binarytree covers the point already, just return.\n    else return this;\n\n  this._x0 = x0;\n  this._x1 = x1;\n  return this;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-binarytree/src/cover.js"],"names":["x","isNaN","x0","_x0","x1","_x1","Math","floor","z","node","_root","parent","i","Array","length"],"mappings":"AAAA,eAAe,UAASA,CAAT,EAAY;AACzB,MAAIC,KAAK,CAACD,CAAC,GAAG,CAACA,CAAN,CAAT,EAAmB,OAAO,IAAP,CADM,CACO;;AAEhC,MAAIE,EAAE,GAAG,KAAKC,GAAd;AAAA,MACIC,EAAE,GAAG,KAAKC,GADd,CAHyB,CAMzB;AACA;AACA;;AACA,MAAIJ,KAAK,CAACC,EAAD,CAAT,EAAe;AACbE,IAAAA,EAAE,GAAG,CAACF,EAAE,GAAGI,IAAI,CAACC,KAAL,CAAWP,CAAX,CAAN,IAAuB,CAA5B;AACD,GAFD,CAIA;AAJA,OAKK,IAAIE,EAAE,GAAGF,CAAL,IAAUA,CAAC,GAAGI,EAAlB,EAAsB;AACzB,UAAII,CAAC,GAAGJ,EAAE,GAAGF,EAAb;AAAA,UACIO,IAAI,GAAG,KAAKC,KADhB;AAAA,UAEIC,MAFJ;AAAA,UAGIC,CAHJ;;AAKA,cAAQA,CAAC,GAAG,EAAEZ,CAAC,GAAG,CAACE,EAAE,GAAGE,EAAN,IAAY,CAAlB,CAAZ;AACE,aAAK,CAAL;AAAQ;AACN;AAAGO,cAAAA,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD;AAAH,sBACOH,CAAC,IAAI,CAAL,EAAQJ,EAAE,GAAGF,EAAE,GAAGM,CAAlB,EAAqBR,CAAC,GAAGI,EADhC;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN;AAAGO,cAAAA,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD;AAAH,sBACOH,CAAC,IAAI,CAAL,EAAQN,EAAE,GAAGE,EAAE,GAAGI,CAAlB,EAAqBN,EAAE,GAAGF,CADjC;;AAEA;AACD;AAVH;;AAaA,UAAI,KAAKU,KAAL,IAAc,KAAKA,KAAL,CAAWI,MAA7B,EAAqC,KAAKJ,KAAL,GAAaD,IAAb;AACtC,KApBI,CAsBL;AAtBK,SAuBA,OAAO,IAAP;;AAEL,OAAKN,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,SAAO,IAAP;AACD","sourcesContent":["export default function(x) {\n  if (isNaN(x = +x)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      x1 = this._x1;\n\n  // If the binarytree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing half boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1) {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = +(x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(2), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, x > x1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(2), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, x0 > x);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the binarytree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._x1 = x1;\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}
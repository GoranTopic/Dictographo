{"ast":null,"code":"module.exports = createLayout;\nmodule.exports.simulator = require('./lib/createPhysicsSimulator');\n\nvar eventify = require('ngraph.events');\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\n\n\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = physicsSettings && physicsSettings.createSimulator || require('./lib/createPhysicsSimulator');\n\n  var physicsSimulator = createSimulator(physicsSettings);\n  if (Array.isArray(physicsSettings)) throw new Error('Physics settings is expected to be an object');\n  var nodeMass = defaultNodeMass;\n\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass;\n  }\n\n  var nodeBodies = new Map();\n  var springs = {};\n  var bodiesCount = 0;\n  var springTransform = physicsSimulator.settings.springTransform || noop; // Initialize physics with what we have in the graph:\n\n  initPhysics();\n  listenToEvents();\n  var wasStable = false;\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; False otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function () {\n      if (bodiesCount === 0) {\n        updateStableStatus(true);\n        return true;\n      }\n\n      var lastMove = physicsSimulator.step(); // Save the movement in case if someone wants to query it in the step\n      // callback.\n\n      api.lastMove = lastMove; // Allow listeners to perform low-level actions after nodes are updated.\n\n      api.fire('step');\n      var ratio = lastMove / bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n\n      updateStableStatus(isStableNow);\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n      body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function () {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is treated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is\n     */\n    getForceVectorLength: getForceVectorLength,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step operation\n     */\n    lastMove: 0\n  };\n  eventify(api);\n  return api;\n\n  function updateStableStatus(isStableNow) {\n    if (wasStable !== isStableNow) {\n      wasStable = isStableNow;\n      onStableChanged(isStableNow);\n    }\n  }\n\n  function forEachBody(cb) {\n    nodeBodies.forEach(function (body, bodyId) {\n      cb(body, bodyId);\n    });\n  }\n\n  function getForceVectorLength() {\n    var fx = 0,\n        fy = 0;\n    forEachBody(function (body) {\n      fx += Math.abs(body.force.x);\n      fy += Math.abs(body.force.y);\n    });\n    return Math.sqrt(fx * fx + fy * fy);\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies.get(nodeId);\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n\n    if (!body) {\n      var node = graph.getNode(nodeId);\n\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n      nodeBodies.set(nodeId, body);\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies.get(nodeId);\n\n    if (body) {\n      nodeBodies.delete(nodeId);\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n    var fromBody = nodeBodies.get(link.fromId),\n        toBody = nodeBodies.get(link.toId),\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n    springTransform(link, spring);\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n      delete springs[link.id];\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n\n    if (!node.links) {\n      return neighbors;\n    }\n\n    var maxNeighbors = Math.min(node.links.length, 2);\n\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);\n\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    body.mass = nodeMass(nodeId);\n\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number');\n    }\n  }\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be marked\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n\n\n  function isNodeOriginallyPinned(node) {\n    return node && (node.isPinned || node.data && node.data.isPinned);\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies.get(nodeId);\n    }\n\n    return body;\n  }\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n\n\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() {}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.forcelayout/index.js"],"names":["module","exports","createLayout","simulator","require","eventify","graph","physicsSettings","Error","createSimulator","physicsSimulator","Array","isArray","nodeMass","defaultNodeMass","nodeBodies","Map","springs","bodiesCount","springTransform","settings","noop","initPhysics","listenToEvents","wasStable","api","step","updateStableStatus","lastMove","fire","ratio","isStableNow","getNodePosition","nodeId","getInitializedBody","pos","setNodePosition","body","setPosition","apply","prototype","slice","call","arguments","getLinkPosition","linkId","spring","from","to","getGraphRect","getBBox","forEachBody","pinNode","node","isPinned","id","isNodePinned","dispose","off","onGraphChanged","getBody","getSpring","getForceVectorLength","onStableChanged","cb","forEach","bodyId","fx","fy","Math","abs","force","x","y","sqrt","fromId","toId","undefined","link","hasLink","get","on","isStable","changes","i","length","change","changeType","initBody","initLink","releaseNode","releaseLink","getNodesCount","forEachNode","forEachLink","getNode","position","neighbors","getNeighborBodies","getBestNewBodyPosition","addBodyAt","set","updateBodyMass","isNodeOriginallyPinned","delete","removeBody","fromBody","toBody","addSpring","removeSpring","links","maxNeighbors","min","otherBody","push","mass","Number","isNaN","data","getLinks"],"mappings":"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","sourcesContent":["module.exports = createLayout;\nmodule.exports.simulator = require('./lib/createPhysicsSimulator');\n\nvar eventify = require('ngraph.events');\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = (physicsSettings && physicsSettings.createSimulator) || require('./lib/createPhysicsSimulator');\n  var physicsSimulator = createSimulator(physicsSettings);\n  if (Array.isArray(physicsSettings)) throw new Error('Physics settings is expected to be an object');\n\n  var nodeMass = defaultNodeMass;\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass\n  }\n\n  var nodeBodies = new Map();\n  var springs = {};\n  var bodiesCount = 0;\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var wasStable = false;\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; False otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function() {\n      if (bodiesCount === 0) {\n        updateStableStatus(true);\n        return true;\n      }\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n\n      var ratio = lastMove/bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n      updateStableStatus(isStableNow);\n\n\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is treated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is\n     */\n    getForceVectorLength: getForceVectorLength,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step operation\n     */\n    lastMove: 0\n  };\n\n  eventify(api);\n\n  return api;\n\n  function updateStableStatus(isStableNow) {\n    if (wasStable !== isStableNow) {\n      wasStable = isStableNow;\n      onStableChanged(isStableNow);\n    }\n  }\n\n  function forEachBody(cb) {\n    nodeBodies.forEach(function(body, bodyId) {\n      cb(body, bodyId);\n    })\n  }\n\n  function getForceVectorLength() {\n    var fx = 0, fy = 0;\n    forEachBody(function(body) {\n      fx += Math.abs(body.force.x);\n      fy += Math.abs(body.force.y);\n    });\n    return Math.sqrt(fx * fx + fy * fy);\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies.get(nodeId);\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n\n      nodeBodies.set(nodeId, body);\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies.get(nodeId);\n    if (body) {\n      nodeBodies.delete(nodeId);\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies.get(link.fromId),\n        toBody  = nodeBodies.get(link.toId),\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number')\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be marked\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies.get(nodeId);\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() { }\n"]},"metadata":{},"sourceType":"script"}
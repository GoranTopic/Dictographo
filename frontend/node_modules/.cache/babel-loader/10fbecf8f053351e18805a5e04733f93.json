{"ast":null,"code":"const unselectedNodeColor = '#3D3C3A';\nconst unselectedLinkColor = '#d3d3d3';\nconst selectedNodeColor = '#E41B17';\nconst selectedLinkColor = '#E41B17';\nconst pathNodeColor = '#17E0E3';\nconst pathLinkColor = '#17E0E3'; //const pathLinkColor = '#E41B17'\n// function for getting random num\n\nconst getRandomInt = max => {\n  return Math.floor(Math.random() * Math.floor(max)) + 1;\n}; // fuction for getting a random string\n\n\nconst getRandomStr = length => {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\n  return result;\n}; //generate random link\n\n\nconst getRandomLinks = (link_number, word, nodes) => {\n  var seen_targets = [];\n  var links = [];\n\n  for (var i = 0; i < link_number; i++) {\n    var target = nodes[getRandomInt(nodes.length - 1)].id;\n\n    if (!seen_targets.includes(target)) {\n      links.push({\n        source: word,\n        target: target\n      });\n      seen_targets.push(target);\n    }\n  }\n\n  return links;\n}; // Generate a random node \n\n\nconst genRandomNode = nodes => {\n  var title = getRandomStr(6);\n  var links = getRandomLinks(getRandomInt(6), title, nodes);\n  return {\n    node: {\n      id: title\n    },\n    links\n  };\n}; // generate a list of grapth recursibly\n\n\nconst genGrapNodes = (word, depth = 0, data = []) => {\n  for (var i = 0; i < getRandomInt(3); i++) {\n    var adjacent_word = getRandomStr(8);\n    data.push({\n      node: {\n        id: adjacent_word\n      },\n      links: [{\n        source: word,\n        target: adjacent_word\n      }]\n    });\n    if (depth > 0) genGrapNodes(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};\n\nconst makeNewNode = (prevNode, newNode, path = false, selected = false) => {\n  var nodeColor = path ? pathNodeColor : selected ? selectedNodeColor : unselectedNodeColor;\n  var linkColor = path ? pathLinkColor : selected ? selectedLinkColor : unselectedLinkColor;\n  return {\n    node: {\n      id: newNode,\n      color: nodeColor\n    },\n    links: [{\n      source: prevNode,\n      target: newNode,\n      color: linkColor\n    }]\n  };\n}; // Generate a Nodes path from  node to the other\n\n\nconst genPath = (start, destination) => {\n  let distance = getRandomInt(10) + 5;\n  let currentNode = start;\n  let data = [];\n  data.push({\n    node: {\n      id: start,\n      color: pathNodeColor\n    },\n    links: []\n  });\n\n  for (var i = 0; i < distance; i++) {\n    var nextNode = getRandomStr(8);\n    data.push(makeNewNode(currentNode, nextNode, true));\n\n    for (var j = 0; j < getRandomInt(5); j++) {\n      var adjacentNode = getRandomStr(8);\n      data.push(makeNewNode(nextNode, adjacentNode));\n    }\n\n    currentNode = nextNode;\n  }\n\n  data.push(makeNewNode(currentNode, destination, true));\n  return data;\n}; // generate a list of grapth recursibly sent them in lists \n\n\nconst genGrapDepth = (word, depth = 0, data = {\n  nodes: [],\n  links: []\n}) => {\n  // Add word to data nodes \n  data.nodes.push({\n    id: word\n  }); //for word get adjacent words into link data\n\n  if (depth <= 0) return data;\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    //gen a adjecent word\n    var adjacent_word = getRandomStr(8); // Add link \n\n    data.links.push({\n      source: word,\n      target: adjacent_word\n    }); // be a recursive bitch\n\n    genGrapDepth(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};\n\nexport { getRandomInt, getRandomStr, getRandomLinks, genRandomNode, genGrapNodes, genPath, genGrapDepth };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/Components/RandomGenerator.js"],"names":["unselectedNodeColor","unselectedLinkColor","selectedNodeColor","selectedLinkColor","pathNodeColor","pathLinkColor","getRandomInt","max","Math","floor","random","getRandomStr","length","result","characters","charactersLength","i","charAt","getRandomLinks","link_number","word","nodes","seen_targets","links","target","id","includes","push","source","genRandomNode","title","node","genGrapNodes","depth","data","adjacent_word","makeNewNode","prevNode","newNode","path","selected","nodeColor","linkColor","color","genPath","start","destination","distance","currentNode","nextNode","j","adjacentNode","genGrapDepth"],"mappings":"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","sourcesContent":["const unselectedNodeColor = '#3D3C3A'\nconst unselectedLinkColor = '#d3d3d3'\nconst selectedNodeColor = '#E41B17'\nconst selectedLinkColor = '#E41B17'\nconst pathNodeColor = '#17E0E3'\nconst pathLinkColor = '#17E0E3'\n//const pathLinkColor = '#E41B17'\n\n// function for getting random num\nconst getRandomInt = (max) => {\n\t\treturn Math.floor(Math.random() * Math.floor(max))+1 ;\n}\n\n// fuction for getting a random string\nconst getRandomStr = (length) => {\n\t\tvar result           = '';\n\t\tvar characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t\tvar charactersLength = characters.length;\n\t\tfor ( var i = 0; i < length; i++ ) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t\treturn result;\n}\n\n//generate random link\nconst getRandomLinks = (link_number, word, nodes) => {\n\t\tvar seen_targets = [] \n\t\tvar links = [];\n\t\tfor (var i = 0; i < link_number; i++ ){\n\t\t\t\tvar target = nodes[getRandomInt(nodes.length-1)].id;\n\t\t\t\tif(!seen_targets.includes(target)){\n\t\t\t\t\t\tlinks.push({ source: word, target: target });\n\t\t\t\t\t\tseen_targets.push(target);\n\t\t\t\t}\n\t\t}\n\t\treturn links;\n}\n\n// Generate a random node \nconst genRandomNode = (nodes) => {\n\t\tvar title = getRandomStr(6);\n\t\tvar links = getRandomLinks(getRandomInt(6), title, nodes);\n\t\treturn { node:{ id: title }, links };\n}\n\n\n// generate a list of grapth recursibly\nconst genGrapNodes = (word, depth=0, data=[]) =>{\n\t\tfor(var i = 0; i < getRandomInt(3); i++){\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\tdata.push({  node:{id: adjacent_word }, links:[{ source: word, target: adjacent_word }] });\n\t\t\t\tif( depth > 0 ) genGrapNodes(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\nconst makeNewNode = (prevNode, newNode, path=false, selected=false) => {\n\t\tvar nodeColor = (path)? pathNodeColor : (selected)? selectedNodeColor : unselectedNodeColor\n\t\tvar linkColor = (path)? pathLinkColor : (selected)? selectedLinkColor : unselectedLinkColor\n\t\t\t\treturn { \n\t\t\t\t\t\tnode:{ id: newNode, color: nodeColor}, \n\t\t\t\t\t\tlinks:[{ source: prevNode, target: newNode, color: linkColor}] \n\t\t\t\t}\n\t\t};\n\n// Generate a Nodes path from  node to the other\nconst genPath = (start, destination) =>{\n\t\tlet distance  = getRandomInt(10) + 5;\n\t\tlet currentNode = start;\n\t\tlet data = [];\n\t\tdata.push({node:{ id: start, color: pathNodeColor}, links:[] });\n\t\tfor(var i = 0; i < distance; i++){\n\t\t\t\tvar nextNode = getRandomStr(8);\n\t\t\t\tdata.push(makeNewNode(currentNode, nextNode, true));\n\t\t\t\tfor(var j = 0; j < getRandomInt(5); j++){\n\t\t\t\t\t\tvar adjacentNode = getRandomStr(8);\n\t\t\t\t\t\tdata.push(makeNewNode(nextNode, adjacentNode));\n\t\t\t\t}\n\t\t\t\tcurrentNode = nextNode;\n\t\t}\n\t\tdata.push(makeNewNode(currentNode, destination, true));\n\t\treturn data;\n}\n\n\n// generate a list of grapth recursibly sent them in lists \nconst genGrapDepth = (word, depth=0, data={ nodes:[], links:[] }) =>{\n\t\t// Add word to data nodes \n\t\tdata.nodes.push({ id: word });\n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) return data;\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\t//gen a adjecent word\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\t// Add link \n\t\t\t\tdata.links.push({ source: word, target: adjacent_word });\n\t\t\t\t// be a recursive bitch\n\t\t\t\tgenGrapDepth(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n\nexport { getRandomInt, getRandomStr, getRandomLinks, genRandomNode, genGrapNodes, genPath, genGrapDepth }\n"]},"metadata":{},"sourceType":"module"}
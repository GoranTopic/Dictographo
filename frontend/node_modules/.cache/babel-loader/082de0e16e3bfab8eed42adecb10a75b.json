{"ast":null,"code":"export default function (x, y, z) {\n  if (isNaN(x = +x) || isNaN(y = +y) || isNaN(z = +z)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      z0 = this._z0,\n      x1 = this._x1,\n      y1 = this._y1,\n      z1 = this._z1; // If the octree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing octant boundaries don’t change due to floating point error!\n\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n    z1 = (z0 = Math.floor(z)) + 1;\n  } // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1 || z0 > z || z > z1) {\n      var t = x1 - x0,\n          node = this._root,\n          parent,\n          i;\n\n      switch (i = (z < (z0 + z1) / 2) << 2 | (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {\n        case 0:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x1 = x0 + t, y1 = y0 + t, z1 = z0 + t, x > x1 || y > y1 || z > z1));\n\n            break;\n          }\n\n        case 1:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x0 = x1 - t, y1 = y0 + t, z1 = z0 + t, x0 > x || y > y1 || z > z1));\n\n            break;\n          }\n\n        case 2:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x1 = x0 + t, y0 = y1 - t, z1 = z0 + t, x > x1 || y0 > y || z > z1));\n\n            break;\n          }\n\n        case 3:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x0 = x1 - t, y0 = y1 - t, z1 = z0 + t, x0 > x || y0 > y || z > z1));\n\n            break;\n          }\n\n        case 4:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x1 = x0 + t, y1 = y0 + t, z0 = z1 - t, x > x1 || y > y1 || z0 > z));\n\n            break;\n          }\n\n        case 5:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x0 = x1 - t, y1 = y0 + t, z0 = z1 - t, x0 > x || y > y1 || z0 > z));\n\n            break;\n          }\n\n        case 6:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x1 = x0 + t, y0 = y1 - t, z0 = z1 - t, x > x1 || y0 > y || z0 > z));\n\n            break;\n          }\n\n        case 7:\n          {\n            do parent = new Array(8), parent[i] = node, node = parent; while ((t *= 2, x0 = x1 - t, y0 = y1 - t, z0 = z1 - t, x0 > x || y0 > y || z0 > z));\n\n            break;\n          }\n      }\n\n      if (this._root && this._root.length) this._root = node;\n    } // If the octree covers the point already, just return.\n    else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._z0 = z0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._z1 = z1;\n  return this;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-octree/src/cover.js"],"names":["x","y","z","isNaN","x0","_x0","y0","_y0","z0","_z0","x1","_x1","y1","_y1","z1","_z1","Math","floor","t","node","_root","parent","i","Array","length"],"mappings":"AAAA,eAAe,UAASA,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB;AAC/B,MAAIC,KAAK,CAACH,CAAC,GAAG,CAACA,CAAN,CAAL,IAAiBG,KAAK,CAACF,CAAC,GAAG,CAACA,CAAN,CAAtB,IAAkCE,KAAK,CAACD,CAAC,GAAG,CAACA,CAAN,CAA3C,EAAqD,OAAO,IAAP,CADtB,CACmC;;AAElE,MAAIE,EAAE,GAAG,KAAKC,GAAd;AAAA,MACIC,EAAE,GAAG,KAAKC,GADd;AAAA,MAEIC,EAAE,GAAG,KAAKC,GAFd;AAAA,MAGIC,EAAE,GAAG,KAAKC,GAHd;AAAA,MAIIC,EAAE,GAAG,KAAKC,GAJd;AAAA,MAKIC,EAAE,GAAG,KAAKC,GALd,CAH+B,CAU/B;AACA;AACA;;AACA,MAAIZ,KAAK,CAACC,EAAD,CAAT,EAAe;AACbM,IAAAA,EAAE,GAAG,CAACN,EAAE,GAAGY,IAAI,CAACC,KAAL,CAAWjB,CAAX,CAAN,IAAuB,CAA5B;AACAY,IAAAA,EAAE,GAAG,CAACN,EAAE,GAAGU,IAAI,CAACC,KAAL,CAAWhB,CAAX,CAAN,IAAuB,CAA5B;AACAa,IAAAA,EAAE,GAAG,CAACN,EAAE,GAAGQ,IAAI,CAACC,KAAL,CAAWf,CAAX,CAAN,IAAuB,CAA5B;AACD,GAJD,CAMA;AANA,OAOK,IAAIE,EAAE,GAAGJ,CAAL,IAAUA,CAAC,GAAGU,EAAd,IAAoBJ,EAAE,GAAGL,CAAzB,IAA8BA,CAAC,GAAGW,EAAlC,IAAwCJ,EAAE,GAAGN,CAA7C,IAAkDA,CAAC,GAAGY,EAA1D,EAA8D;AACjE,UAAII,CAAC,GAAGR,EAAE,GAAGN,EAAb;AAAA,UACIe,IAAI,GAAG,KAAKC,KADhB;AAAA,UAEIC,MAFJ;AAAA,UAGIC,CAHJ;;AAKA,cAAQA,CAAC,GAAG,CAACpB,CAAC,GAAG,CAACM,EAAE,GAAGM,EAAN,IAAY,CAAjB,KAAuB,CAAvB,GAA2B,CAACb,CAAC,GAAG,CAACK,EAAE,GAAGM,EAAN,IAAY,CAAjB,KAAuB,CAAlD,GAAuDZ,CAAC,GAAG,CAACI,EAAE,GAAGM,EAAN,IAAY,CAAnF;AACE,aAAK,CAAL;AAAQ;AACN,eAAGW,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQR,EAAE,GAAGN,EAAE,GAAGc,CAAlB,EAAqBN,EAAE,GAAGN,EAAE,GAAGY,CAA/B,EAAkCJ,EAAE,GAAGN,EAAE,GAAGU,CAA5C,EAA+ClB,CAAC,GAAGU,EAAJ,IAAUT,CAAC,GAAGW,EAAd,IAAoBV,CAAC,GAAGY,EAD9E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGO,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQd,EAAE,GAAGM,EAAE,GAAGQ,CAAlB,EAAqBN,EAAE,GAAGN,EAAE,GAAGY,CAA/B,EAAkCJ,EAAE,GAAGN,EAAE,GAAGU,CAA5C,EAA+Cd,EAAE,GAAGJ,CAAL,IAAUC,CAAC,GAAGW,EAAd,IAAoBV,CAAC,GAAGY,EAD9E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGO,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQR,EAAE,GAAGN,EAAE,GAAGc,CAAlB,EAAqBZ,EAAE,GAAGM,EAAE,GAAGM,CAA/B,EAAkCJ,EAAE,GAAGN,EAAE,GAAGU,CAA5C,EAA+ClB,CAAC,GAAGU,EAAJ,IAAUJ,EAAE,GAAGL,CAAf,IAAoBC,CAAC,GAAGY,EAD9E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGO,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQd,EAAE,GAAGM,EAAE,GAAGQ,CAAlB,EAAqBZ,EAAE,GAAGM,EAAE,GAAGM,CAA/B,EAAkCJ,EAAE,GAAGN,EAAE,GAAGU,CAA5C,EAA+Cd,EAAE,GAAGJ,CAAL,IAAUM,EAAE,GAAGL,CAAf,IAAoBC,CAAC,GAAGY,EAD9E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGO,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQR,EAAE,GAAGN,EAAE,GAAGc,CAAlB,EAAqBN,EAAE,GAAGN,EAAE,GAAGY,CAA/B,EAAkCV,EAAE,GAAGM,EAAE,GAAGI,CAA5C,EAA+ClB,CAAC,GAAGU,EAAJ,IAAUT,CAAC,GAAGW,EAAd,IAAoBJ,EAAE,GAAGN,CAD/E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGmB,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQd,EAAE,GAAGM,EAAE,GAAGQ,CAAlB,EAAqBN,EAAE,GAAGN,EAAE,GAAGY,CAA/B,EAAkCV,EAAE,GAAGM,EAAE,GAAGI,CAA5C,EAA+Cd,EAAE,GAAGJ,CAAL,IAAUC,CAAC,GAAGW,EAAd,IAAoBJ,EAAE,GAAGN,CAD/E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGmB,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQR,EAAE,GAAGN,EAAE,GAAGc,CAAlB,EAAqBZ,EAAE,GAAGM,EAAE,GAAGM,CAA/B,EAAkCV,EAAE,GAAGM,EAAE,GAAGI,CAA5C,EAA+ClB,CAAC,GAAGU,EAAJ,IAAUJ,EAAE,GAAGL,CAAf,IAAoBO,EAAE,GAAGN,CAD/E;;AAEA;AACD;;AACD,aAAK,CAAL;AAAQ;AACN,eAAGmB,MAAM,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAT,EAAuBF,MAAM,CAACC,CAAD,CAAN,GAAYH,IAAnC,EAAyCA,IAAI,GAAGE,MAAhD,CAAH,SACOH,CAAC,IAAI,CAAL,EAAQd,EAAE,GAAGM,EAAE,GAAGQ,CAAlB,EAAqBZ,EAAE,GAAGM,EAAE,GAAGM,CAA/B,EAAkCV,EAAE,GAAGM,EAAE,GAAGI,CAA5C,EAA+Cd,EAAE,GAAGJ,CAAL,IAAUM,EAAE,GAAGL,CAAf,IAAoBO,EAAE,GAAGN,CAD/E;;AAEA;AACD;AAxCH;;AA2CA,UAAI,KAAKkB,KAAL,IAAc,KAAKA,KAAL,CAAWI,MAA7B,EAAqC,KAAKJ,KAAL,GAAaD,IAAb;AACtC,KAlDI,CAoDL;AApDK,SAqDA,OAAO,IAAP;;AAEL,OAAKd,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,OAAKG,GAAL,GAAWD,EAAX;AACA,SAAO,IAAP;AACD","sourcesContent":["export default function(x, y, z) {\n  if (isNaN(x = +x) || isNaN(y = +y) || isNaN(z = +z)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      z0 = this._z0,\n      x1 = this._x1,\n      y1 = this._y1,\n      z1 = this._z1;\n\n  // If the octree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing octant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n    z1 = (z0 = Math.floor(z)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1 || z0 > z || z > z1) {\n    var t = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = (z < (z0 + z1) / 2) << 2 | (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x1 = x0 + t, y1 = y0 + t, z1 = z0 + t, x > x1 || y > y1 || z > z1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x0 = x1 - t, y1 = y0 + t, z1 = z0 + t, x0 > x || y > y1 || z > z1);\n        break;\n      }\n      case 2: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x1 = x0 + t, y0 = y1 - t, z1 = z0 + t, x > x1 || y0 > y || z > z1);\n        break;\n      }\n      case 3: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x0 = x1 - t, y0 = y1 - t, z1 = z0 + t, x0 > x || y0 > y || z > z1);\n        break;\n      }\n      case 4: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x1 = x0 + t, y1 = y0 + t, z0 = z1 - t, x > x1 || y > y1 || z0 > z);\n        break;\n      }\n      case 5: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x0 = x1 - t, y1 = y0 + t, z0 = z1 - t, x0 > x || y > y1 || z0 > z);\n        break;\n      }\n      case 6: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x1 = x0 + t, y0 = y1 - t, z0 = z1 - t, x > x1 || y0 > y || z0 > z);\n        break;\n      }\n      case 7: {\n        do parent = new Array(8), parent[i] = node, node = parent;\n        while (t *= 2, x0 = x1 - t, y0 = y1 - t, z0 = z1 - t, x0 > x || y0 > y || z0 > z);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the octree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._z0 = z0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._z1 = z1;\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}
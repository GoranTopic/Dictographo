{"ast":null,"code":"import { colors, API_ENDPOINT } from \"./myConfig\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['color'] = colors.node.default;\n  return node;\n}; // retrive node with given node id from state \n\n\nconst getNode = (nodeId, state) => state.nodes.filter(node => node.id === nodeId)[0]; // attemps to return true id node is not in state\n\n\nconst isNewWord = (nodeId, state) => state.nodes.every(node => node.id !== nodeId);\n\nconst requestSynonymNodes = (nodeId, state, dispatchState) => {\n  /* askes the server for all the neiboring node from a given node id */\n  // if node is not complete\n  // otherwise request it\n  // unpack json\n  // check if not was found\n  // if it was for every node\n  // check if node is not alrady in state\t\n  // if not, process node, \n  // make an artificial wait \n  // dispatch to state\n  console.log(nodeId);\n  fetch(API_ENDPOINT + 'synonyms/' + nodeId).then(result => {\n    console.log(result);\n    return result;\n  }).then(result => result.json()).then(result => console.log(result)).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n/*\n\t\t\t\t\t\t.then(result => result.json())\n\t\t\t\t\t\t.then(result => processNode(result))\n\t\t\t\t\t\t.then(adjNode => {\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n\t\t*/\n\n\nconst isWordNotFound = (response, dispatchState) => {\n  // Set error to state when user search a word not found\n  if (response.detail === \"Not found.\") {\n    dispatchState({\n      type: 'SET_WORD_NOT_FOUND'\n    });\n    throw new Error(\"word not found\");\n  } else {\n    return response;\n  }\n};\n\nconst onClickNode = function (nodeId, dispatchState) {\n  // when user clicks on a node\n  requestSynonymNodes(getNode(nodeId));\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: nodeId\n  });\n};\n\nconst onMouseOverNode = function (nodeId, dispatchState) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, isNewWord, requestSynonymNodes, onClickNode, onMouseOverNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","processNode","node","w_id","default","getNode","nodeId","state","nodes","filter","id","isNewWord","every","requestSynonymNodes","dispatchState","console","log","fetch","then","result","json","catch","type","isWordNotFound","response","detail","Error","onClickNode","payload","onMouseOverNode"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,YAAjB,QAAsC,YAAtC;AAEA;;;;;;;AAQA,MAAMC,WAAW,GAAIC,IAAD,IAAS;AAC3B;;AAEAA,EAAAA,IAAI,CAAC,IAAD,CAAJ,GAAaA,IAAI,CAACC,IAAlB;AACAD,EAAAA,IAAI,CAAC,KAAD,CAAJ,GAAcA,IAAI,CAACC,IAAnB;AACAD,EAAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,KAArB;AACAA,EAAAA,IAAI,CAAC,OAAD,CAAJ,GAAgBH,MAAM,CAACG,IAAP,CAAYE,OAA5B;AACA,SAAOF,IAAP;AACD,CARD,C,CAUA;;;AACA,MAAMG,OAAO,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmBA,KAAK,CAACC,KAAN,CAAYC,MAAZ,CAAoBP,IAAI,IAAIA,IAAI,CAACQ,EAAL,KAAYJ,MAAxC,EAAiD,CAAjD,CAAnC,C,CAEA;;;AACA,MAAMK,SAAS,GAAG,CAACL,MAAD,EAASC,KAAT,KAAmBA,KAAK,CAACC,KAAN,CAAYI,KAAZ,CAAmBV,IAAI,IAAIA,IAAI,CAACQ,EAAL,KAAYJ,MAAvC,CAArC;;AAEA,MAAMO,mBAAmB,GAAG,CAACP,MAAD,EAASC,KAAT,EAAgBO,aAAhB,KAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYV,MAAZ;AACAW,EAAAA,KAAK,CAACjB,YAAY,GAAG,WAAf,GAA6BM,MAA9B,CAAL,CACGY,IADH,CACQC,MAAM,IAAI;AACdJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,MAAZ;AACA,WAAOA,MAAP;AACD,GAJH,EAKGD,IALH,CAKQC,MAAM,IAAIA,MAAM,CAACC,IAAP,EALlB,EAMGF,IANH,CAMQC,MAAM,IAAIJ,OAAO,CAACC,GAAR,CAAYG,MAAZ,CANlB,EAOGE,KAPH,CAOS,MAAMP,aAAa,CAAC;AAACQ,IAAAA,IAAI,EAAC;AAAN,GAAD,CAP5B;AAQD,CApBD;AAsBE;;;;;;;;;;;;;;;;;;;AAkBF,MAAMC,cAAc,GAAG,CAACC,QAAD,EAAWV,aAAX,KAA4B;AACjD;AACA,MAAIU,QAAQ,CAACC,MAAT,KAAoB,YAAxB,EAAuC;AACrCX,IAAAA,aAAa,CAAC;AAACQ,MAAAA,IAAI,EAAE;AAAP,KAAD,CAAb;AACA,UAAM,IAAII,KAAJ,CAAU,gBAAV,CAAN;AACD,GAHD,MAGK;AACH,WAAOF,QAAP;AACD;AACF,CARD;;AAUA,MAAMG,WAAW,GAAG,UAASrB,MAAT,EAAiBQ,aAAjB,EAAgC;AAClD;AACAD,EAAAA,mBAAmB,CAACR,OAAO,CAACC,MAAD,CAAR,CAAnB;AACAQ,EAAAA,aAAa,CAAC;AAACQ,IAAAA,IAAI,EAAC,sBAAN;AAA8BM,IAAAA,OAAO,EAAEtB;AAAvC,GAAD,CAAb;AACD,CAJD;;AAMA,MAAMuB,eAAe,GAAG,UAASvB,MAAT,EAAiBQ,aAAjB,EAAgC;AACtDA,EAAAA,aAAa,CAAC;AAACQ,IAAAA,IAAI,EAAC,kBAAN;AAA0BM,IAAAA,OAAO,EAAEtB;AAAnC,GAAD,CAAb,CADsD,CAEtD;AACD,CAHD;;AAKA,SAASL,WAAT,EAAsBsB,cAAtB,EAAsCZ,SAAtC,EAAiDE,mBAAjD,EAAsEc,WAAtE,EAAmFE,eAAnF","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\n\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n// retrive node with given node id from state \nconst getNode = (nodeId, state) => state.nodes.filter( node => node.id === nodeId )[0];\n\n// attemps to return true id node is not in state\nconst isNewWord = (nodeId, state) => state.nodes.every( node => node.id !== nodeId );\n\nconst requestSynonymNodes = (nodeId, state, dispatchState) => {\n\t\t/* askes the server for all the neiboring node from a given node id */\n\t\t// if node is not complete\n\t\t// otherwise request it\n\t\t// unpack json\n\t\t// check if not was found\n\t\t// if it was for every node\n\t\t// check if node is not alrady in state\t\n\t\t// if not, process node, \n\t\t// make an artificial wait \n\t\t// dispatch to state\n\t\tconsole.log(nodeId)\n\t\tfetch(API_ENDPOINT + 'synonyms/' + nodeId)\n\t\t\t\t.then(result => {  \n\t\t\t\t\t\tconsole.log(result);\n\t\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t\t.then(result => result.json())\n\t\t\t\t.then(result => console.log(result))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\t\t\n\t\t/*\n\t\t\t\t\t\t\t\t.then(result => result.json())\n\t\t\t\t\t\t\t\t.then(result => processNode(result))\n\t\t\t\t\t\t\t\t.then(adjNode => {\n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n\t\t\t\t*/\n\nconst isWordNotFound = (response, dispatchState) =>{\n\t\t// Set error to state when user search a word not found\n\t\tif( response.detail === \"Not found.\" ) {\n\t\t\t\tdispatchState({type: 'SET_WORD_NOT_FOUND'})\n\t\t\t\tthrow new Error(\"word not found\")\n\t\t}else{\n\t\t\t\treturn response\n\t\t}\n}\n\nconst onClickNode = function(nodeId, dispatchState) {\n\t\t// when user clicks on a node\n\t\trequestSynonymNodes(getNode(nodeId))\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})  \n};\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, isNewWord, requestSynonymNodes, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
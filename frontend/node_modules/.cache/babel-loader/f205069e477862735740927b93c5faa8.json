{"ast":null,"code":"import { colors, API_ENDPOINT } from \"./myConfig\";\nimport { getRandomInt } from \"./Components/RandomGenerator\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['color'] = colors.node.default;\n  return node;\n}; // retrive node with given node id from state \n\n\nconst getNode = (nodeId, state) => state.nodes.filter(node => node.id === nodeId)[0]; // attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\n\n\nconst isNewNode = (nodeId, state) => state.nodes.every(node => node.id !== nodeId);\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n  // when user clicks on a node\n  queryAdjecentNodes(getNode(nodeId, state), state, dispatchState);\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: nodeId\n  });\n};\n\nconst timelyDispatch = (dispatchFunc, waitTime = 0, random = 10) => {\n  /* takes a dispachState functions and dispaches it in a \n   * random timply fashion this is usefulf for node not to \n   * appear all at once in the graph and make it easier on \n   * the browser. Returns nothing*/\n  setTimeout(dispatchFunc, waitTime + getRandomInt(random));\n};\n\nconst queryNewWord = (word, state, dispatchState) => {\n  /* reset the graph state and start a new query into a word, \n   * sometime this stymes when it is called a second time,\n   * this might be because of dispatchState being called twice\n   * must investigate.  */\n  fetch(API_ENDPOINT + word) // unpack json\n  .then(result => result.json()) //unpack word\n  .then(result => catchError(result, state, dispatchState)) //check if word was found\n  .then(result => processNode(result)) //process node\n  .then(node => {\n    //dispatch word\n    dispatchState({\n      type: 'SET_NEW_NODE',\n      payload: node\n    });\n    return node;\n  }) // get the surrounding words\n  .then(node => queryAdjecentNodes(node, state, dispatchState)).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst queryPath = (words, state, dispatchState) => {\n  /* gets passesed a set of two words, \n   * queries the server for the path and \n   * dispateches the result to state */\n  //split words into arrays\n  console.log(\"this ran\");\n  let prevNode = null;\n  let first;\n  let second;\n\n  for (var i = 0; i + 1 <= words.length - 1; i++) {\n    first = words[i];\n    second = words[i + 1]; //console.log(words)\n    //console.log(i)\n    //console.log(first);\n    //console.log(second);\n\n    fetch(API_ENDPOINT + 'path/' + first + \"/\" + second).then(result => result.json()) // unpack json\n    .then(nodes => {\n      console.log(nodes);\n      return catchError(nodes, state, dispatchState);\n    }) //check if words not found\n    .then(pathNodes => {\n      //console.log(pathNodes)\n      pathNodes.forEach((node, index) => timelyDispatch(() => {\n        node = processNode(node);\n\n        if (prevNode === null) {\n          // if this is the first node\n          dispatchState({\n            type: 'SET_NEW_NODE',\n            payload: node\n          });\n        } else {\n          //console.log(prevNode.id)\n          //console.log(\" --> \")\n          //console.log(node.id)\n          //console.log(\"\\n\")\n          //if there is already other nodes\n          dispatchState({\n            type: 'SET_PATH_NODE',\n            payload: {\n              node: node,\n              link: {\n                source: prevNode.id,\n                target: node.id\n              }\n            }\n          });\n        }\n\n        prevNode = node;\n      }, 25, 0)); //se the time as 25 and the random to 0\n    }).catch(() => dispatchState({\n      type: 'SET_FETCH_FAILED'\n    }));\n  }\n};\n\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n  /* for every node request the adjecent node to it */\n  let linkAll = state.isDeepLinks; // define whether we should link te deeper\n\n  let graph_type = 'synonyms/'; // define which type of graph we are requesting\n\n  fetch(API_ENDPOINT + graph_type + node.id) // request the synonyms\n  .then(result => result.json()).then(result => catchError(result, state, dispatchState)).then(adjNodes => adjNodes.forEach( // for every node in the array\n  adjNode => timelyDispatch(() => {\n    //for each of the nodes in the list \t\t\n    adjNode = processNode(adjNode); //process node \n\n    if (linkAll || isNewNode(adjNode.id, state)) {\n      // proces is it is new node, or deep link set\n      dispatchState({\n        type: 'SET_NODE_LINK',\n        payload: {\n          node: adjNode,\n          link: {\n            source: node.id,\n            target: adjNode.id\n          }\n        }\n      });\n    }\n  }))).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst catchError = (response, state, dispatchState) => {\n  /* Set error to state when user search a word not found */\n  console.log(response);\n\n  if (response instanceof Array) {\n    console.log(\"words was not found\");\n    console.log(response); // if it has the response for many words\n\n    response.forEach((msg, index, msgs) => {\n      if (msg.detail === \"Not Found.\") {\n        dispatchState({\n          type: 'SET_WORD_NOT_FOUND',\n          payload: msg.w_id\n        });\n        msgs.splice(index, 1); // remove from the list\n      }\n    });\n    throw new Error(\"word not found\");\n  } else {\n    // if it only one elment\n    if (response.detail === \"Not found.\") {\n      dispatchState({\n        type: 'SET_WORD_NOT_FOUND',\n        payload: state.searchTerm\n      });\n      throw new Error(\"word not found\");\n    } else if (response.detail === \"Path not found.\") {\n      // if the error is path not found\n      console.log(\"path was not found\");\n      dispatchState({\n        type: 'SET_PATH_NOT_FOUND',\n        payload: {\n          'first': response.first,\n          'last': response.last\n        }\n      });\n      throw new Error(\"path not found\");\n    } else {\n      return response;\n    }\n  }\n};\n\nconst onMouseOverNode = function (nodeId, dispatchState) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","getRandomInt","processNode","node","w_id","default","getNode","nodeId","state","nodes","filter","id","isNewNode","every","onClickNode","dispatchState","queryAdjecentNodes","type","payload","timelyDispatch","dispatchFunc","waitTime","random","setTimeout","queryNewWord","word","fetch","then","result","json","catchError","catch","queryPath","words","console","log","prevNode","first","second","i","length","pathNodes","forEach","index","link","source","target","linkAll","isDeepLinks","graph_type","adjNodes","adjNode","response","Array","msg","msgs","detail","splice","Error","searchTerm","last","onMouseOverNode"],"mappings":"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","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\nimport { getRandomInt }  from \"./Components/RandomGenerator\";\n\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n// retrive node with given node id from state \nconst getNode = (nodeId, state) => state.nodes.filter( node => node.id === nodeId )[0]\n\n// attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\nconst isNewNode = (nodeId, state) => state.nodes.every( node => node.id !== nodeId )\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n\t\t// when user clicks on a node\n\t\tqueryAdjecentNodes(getNode(nodeId, state), state, dispatchState)\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})  \n};\n\nconst timelyDispatch = (dispatchFunc , waitTime=0, random=10) => {\n\t/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/\n\t\tsetTimeout(dispatchFunc, waitTime + getRandomInt(random));\n}\n\nconst queryNewWord = (word, state, dispatchState) => {\n\t\t/* reset the graph state and start a new query into a word, \n\t\t * sometime this stymes when it is called a second time,\n\t\t * this might be because of dispatchState being called twice\n\t\t * must investigate.  */\n\t\tfetch(API_ENDPOINT + word)\n\t\t// unpack json\n\t\t\t\t.then(result => result.json()) //unpack word\n\t\t\t\t.then(result => catchError(result, state, dispatchState))//check if word was found\n\t\t\t\t.then(result => processNode(result)) //process node\n\t\t\t\t.then(node => { //dispatch word\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\tpayload: node\n\t\t\t\t\t\t}); \n\t\t\t\t\t\treturn node; })\n\t\t// get the surrounding words\n\t\t\t\t.then(node => queryAdjecentNodes(node, state, dispatchState))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n}\n\nconst queryPath = (words, state, dispatchState) => {\n\t\t/* gets passesed a set of two words, \n\t\t * queries the server for the path and \n\t\t * dispateches the result to state */\n\t\t//split words into arrays\n\t\tconsole.log(\"this ran\")\n\t\tlet prevNode = null;\n\t\tlet first;\n\t\tlet second;\n\t\tfor( var i = 0; i+1 <= words.length-1; i++){\n\t\t\t\tfirst = words[i];\n\t\t\t\tsecond = words[i + 1];\n\t\t\t\t//console.log(words)\n\t\t\t\t//console.log(i)\n\t\t\t\t//console.log(first);\n\t\t\t\t//console.log(second);\n\t\t\t\tfetch(API_ENDPOINT + 'path/' +  first  + \"/\" + second) \n\t\t\t\t\t\t.then(result => result.json()) // unpack json\n\t\t\t\t\t\t.then(nodes => { console.log(nodes); return catchError(nodes, state, dispatchState)}) \n\t\t\t\t\t\t\t//check if words not found\n\t\t\t\t\t\t.then(pathNodes => {\n\t\t\t\t\t\t\t\t//console.log(pathNodes)\n\t\t\t\t\t\t\t\tpathNodes.forEach((node, index) => \n\t\t\t\t\t\t\t\t\t\ttimelyDispatch(() => {  \n\t\t\t\t\t\t\t\t\t\t\t\tnode = processNode(node);\n\t\t\t\t\t\t\t\t\t\t\t\tif (prevNode === null){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if this is the first node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log(prevNode.id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log(\" --> \")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log(node.id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log(\"\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if there is already other nodes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: prevNode.id, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tprevNode = node;\n\t\t\t\t\t\t\t\t\t\t}, 25,0)\n\t\t\t\t\t\t\t\t) //se the time as 25 and the random to 0\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n\t\t}\n}\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n\t\t/* for every node request the adjecent node to it */\n\t\tlet linkAll = state.isDeepLinks;\n\t\t// define whether we should link te deeper\n\t\tlet graph_type = 'synonyms/';\n\t\t// define which type of graph we are requesting\n\t\tfetch(API_ENDPOINT + graph_type + node.id )\n\t\t// request the synonyms\n\t\t\t\t.then(result => result.json())\n\t\t\t\t.then(result => catchError(result, state, dispatchState))\n\t\t\t\t.then(adjNodes => adjNodes.forEach( \n\t\t\t\t\t\t// for every node in the array\n\t\t\t\t\t\tadjNode => timelyDispatch(() => {  \n\t\t\t\t\t\t\t\t//for each of the nodes in the list \t\t\n\t\t\t\t\t\t\t\tadjNode = processNode(adjNode); //process node \n\t\t\t\t\t\t\t\tif(linkAll || isNewNode(adjNode.id, state)){\n\t\t\t\t\t\t\t\t\t\t// proces is it is new node, or deep link set\n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t\n\t\t\t\t))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\nconst catchError = (response, state, dispatchState) =>{\n\t\t/* Set error to state when user search a word not found */\n\t\tconsole.log(response)\n\t\tif(response instanceof Array){\n\t\t\t\tconsole.log(\"words was not found\")\n\t\t\t\tconsole.log(response)\n\t\t\t\t// if it has the response for many words\n\t\t\t\tresponse.forEach((msg, index, msgs) => {\n\t\t\t\t\t\tif(msg.detail === \"Not Found.\"){\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: msg.w_id})\n\t\t\t\t\t\t\t\tmsgs.splice(index, 1); // remove from the list\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tthrow new Error(\"word not found\");\n\t\t}else{ // if it only one elment\n\t\t\t\tif(response.detail === \"Not found.\") {\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: state.searchTerm})\n\t\t\t\t\t\tthrow new Error(\"word not found\");\n\t\t\t\t}else if(response.detail === \"Path not found.\"){\n\t\t\t\t\t\t// if the error is path not found\n\t\t\t\t\t\tconsole.log(\"path was not found\")\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t'first': response.first,\n\t\t\t\t\t\t\t\t\t\t'last': response.last,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthrow new Error(\"path not found\");\n\t\t\t\t}else{\n\t\t\t\t\t\treturn response\n\t\t\t\t}\n\t\t}\n}\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// function for getting random num\nexport const getRandomInt = max => {\n  return Math.floor(Math.random() * Math.floor(max)) + 1;\n}; // fuction for getting a random string\n\nexport const getRandomStr = length => {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\n  return result;\n}; //generate random link\n\nexport const getRandomLinks = (link_number, word, nodes) => {\n  var seen_targets = [];\n  var links = [];\n\n  for (var i = 0; i < link_number; i++) {\n    var target = nodes[getRandomInt(nodes.length - 1)].id;\n\n    if (!seen_targets.includes(target)) {\n      links.push({\n        source: word,\n        target: target\n      });\n      seen_targets.push(target);\n    }\n  }\n\n  return links;\n}; // Generate a random node \n\nexport const genRandomNode = nodes => {\n  var title = getRandomStr(6);\n  var links = getRandomLinks(getRandomInt(6), title, nodes);\n  return {\n    node: {\n      id: title\n    },\n    links\n  };\n}; // generate a list of grapth recursibly\n\nexport const genGrapNodes = (word, depth = 0, data = []) => {\n  for (var i = 0; i < getRandomInt(3); i++) {\n    var adjacent_word = getRandomStr(8);\n    data.push({\n      node: {\n        id: adjacent_word\n      },\n      links: [{\n        source: word,\n        target: adjacent_word\n      }]\n    });\n    if (depth > 0) genGrapNodes(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n}; // Generate a Nodes path from  node to the other\n\nexport const genPath = (start, destination) => {\n  let distance = getRandomInt(10) + 5;\n  let currentNode = start;\n  let data = [];\n\n  for (var i = 0; i < distance; i++) {\n    var nextNode = getRandomStr(8);\n    data.push({\n      node: {\n        id: nextNode,\n        color: 'red'\n      },\n      links: [{\n        source: currentNode,\n        target: nextNode\n      }]\n    });\n\n    for (var j = 0; j < getRandomInt(5); j++) {\n      var adjacentNode = getRandomStr(8);\n      data.push({\n        node: {\n          id: adjacentNode\n        },\n        links: [{\n          source: nextNode,\n          target: adjacentNode\n        }]\n      });\n    }\n\n    currentNode = nextNode;\n  }\n\n  data.push({\n    node: {\n      id: destination,\n      color: 'red'\n    },\n    links: [{\n      source: currentNode,\n      target: destination\n    }]\n  });\n  return data;\n}; // generate a list of grapth recursibly sent them in lists \n\nexport const genGrapDepth = (word, depth = 0, data = {\n  nodes: [],\n  links: []\n}) => {\n  // Add word to data nodes \n  data.nodes.push({\n    id: word\n  }); //for word get adjacent words into link data\n\n  if (depth <= 0) return data;\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    //gen a adjecent word\n    var adjacent_word = getRandomStr(8); // Add link \n\n    data.links.push({\n      source: word,\n      target: adjacent_word\n    }); // be a recursive bitch\n\n    genGrapDepth(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/telix/dictio-grapho/src/RandomGenerator.js"],"names":["getRandomInt","max","Math","floor","random","getRandomStr","length","result","characters","charactersLength","i","charAt","getRandomLinks","link_number","word","nodes","seen_targets","links","target","id","includes","push","source","genRandomNode","title","node","genGrapNodes","depth","data","adjacent_word","genPath","start","destination","distance","currentNode","nextNode","color","j","adjacentNode","genGrapDepth"],"mappings":"AACA;AACA,OAAO,MAAMA,YAAY,GAAIC,GAAD,IAAS;AACnC,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBF,IAAI,CAACC,KAAL,CAAWF,GAAX,CAA3B,IAA4C,CAAnD;AACD,CAFM,C,CAIP;;AACA,OAAO,MAAMI,YAAY,GAAIC,MAAD,IAAY;AACtC,MAAIC,MAAM,GAAa,EAAvB;AACA,MAAIC,UAAU,GAAS,gEAAvB;AACA,MAAIC,gBAAgB,GAAGD,UAAU,CAACF,MAAlC;;AACA,OAAM,IAAII,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,MAArB,EAA6BI,CAAC,EAA9B,EAAmCH,MAAM,IAAIC,UAAU,CAACG,MAAX,CAAkBT,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBK,gBAA3B,CAAlB,CAAV;;AACnC,SAAOF,MAAP;AACD,CANM,C,CAQP;;AACA,OAAO,MAAMK,cAAc,GAAG,CAACC,WAAD,EAAcC,IAAd,EAAoBC,KAApB,KAA8B;AAC1D,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,WAApB,EAAiCH,CAAC,EAAlC,EAAsC;AACpC,QAAIQ,MAAM,GAAGH,KAAK,CAACf,YAAY,CAACe,KAAK,CAACT,MAAN,GAAa,CAAd,CAAb,CAAL,CAAoCa,EAAjD;;AACA,QAAG,CAACH,YAAY,CAACI,QAAb,CAAsBF,MAAtB,CAAJ,EAAkC;AAChCD,MAAAA,KAAK,CAACI,IAAN,CAAW;AAAEC,QAAAA,MAAM,EAAER,IAAV;AAAgBI,QAAAA,MAAM,EAAEA;AAAxB,OAAX;AACAF,MAAAA,YAAY,CAACK,IAAb,CAAkBH,MAAlB;AACD;AACF;;AACD,SAAOD,KAAP;AACD,CAXM,C,CAaP;;AACA,OAAO,MAAMM,aAAa,GAAIR,KAAD,IAAW;AACtC,MAAIS,KAAK,GAAGnB,YAAY,CAAC,CAAD,CAAxB;AACA,MAAIY,KAAK,GAAGL,cAAc,CAACZ,YAAY,CAAC,CAAD,CAAb,EAAkBwB,KAAlB,EAAyBT,KAAzB,CAA1B;AACA,SAAO;AAAEU,IAAAA,IAAI,EAAC;AAAEN,MAAAA,EAAE,EAAEK;AAAN,KAAP;AAAsBP,IAAAA;AAAtB,GAAP;AACD,CAJM,C,CAOP;;AACA,OAAO,MAAMS,YAAY,GAAG,CAACZ,IAAD,EAAOa,KAAK,GAAC,CAAb,EAAgBC,IAAI,GAAC,EAArB,KAA2B;AACrD,OAAI,IAAIlB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGV,YAAY,CAAC,CAAD,CAA/B,EAAoCU,CAAC,EAArC,EAAwC;AACtC,QAAImB,aAAa,GAAGxB,YAAY,CAAC,CAAD,CAAhC;AACAuB,IAAAA,IAAI,CAACP,IAAL,CAAU;AAAGI,MAAAA,IAAI,EAAC;AAACN,QAAAA,EAAE,EAAEU;AAAL,OAAR;AAA8BZ,MAAAA,KAAK,EAAC,CAAC;AAAEK,QAAAA,MAAM,EAAER,IAAV;AAAgBI,QAAAA,MAAM,EAAEW;AAAxB,OAAD;AAApC,KAAV;AACA,QAAIF,KAAK,GAAG,CAAZ,EAAgBD,YAAY,CAACG,aAAD,EAAgBF,KAAK,GAAE,CAAvB,EAA0BC,IAA1B,CAAZ;AACjB;;AACD,SAAOA,IAAP;AACD,CAPM,C,CASP;;AACA,OAAO,MAAME,OAAO,GAAG,CAACC,KAAD,EAAQC,WAAR,KAAuB;AAC5C,MAAIC,QAAQ,GAAIjC,YAAY,CAAC,EAAD,CAAZ,GAAmB,CAAnC;AACA,MAAIkC,WAAW,GAAGH,KAAlB;AACA,MAAIH,IAAI,GAAG,EAAX;;AACA,OAAI,IAAIlB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGuB,QAAnB,EAA6BvB,CAAC,EAA9B,EAAiC;AAC/B,QAAIyB,QAAQ,GAAG9B,YAAY,CAAC,CAAD,CAA3B;AACAuB,IAAAA,IAAI,CAACP,IAAL,CAAU;AAAEI,MAAAA,IAAI,EAAC;AAAEN,QAAAA,EAAE,EAAEgB,QAAN;AAAgBC,QAAAA,KAAK,EAAE;AAAvB,OAAP;AAAuCnB,MAAAA,KAAK,EAAC,CAAC;AAAEK,QAAAA,MAAM,EAAEY,WAAV;AAAuBhB,QAAAA,MAAM,EAAEiB;AAA/B,OAAD;AAA7C,KAAV;;AACA,SAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGrC,YAAY,CAAC,CAAD,CAA/B,EAAoCqC,CAAC,EAArC,EAAwC;AACtC,UAAIC,YAAY,GAAGjC,YAAY,CAAC,CAAD,CAA/B;AACAuB,MAAAA,IAAI,CAACP,IAAL,CAAU;AAAEI,QAAAA,IAAI,EAAC;AAAEN,UAAAA,EAAE,EAAEmB;AAAN,SAAP;AAA6BrB,QAAAA,KAAK,EAAC,CAAC;AAAEK,UAAAA,MAAM,EAAEa,QAAV;AAAoBjB,UAAAA,MAAM,EAAEoB;AAA5B,SAAD;AAAnC,OAAV;AACD;;AACDJ,IAAAA,WAAW,GAAGC,QAAd;AACD;;AACDP,EAAAA,IAAI,CAACP,IAAL,CAAU;AAAEI,IAAAA,IAAI,EAAC;AAAEN,MAAAA,EAAE,EAAEa,WAAN;AAAmBI,MAAAA,KAAK,EAAE;AAA1B,KAAP;AAA0CnB,IAAAA,KAAK,EAAC,CAAC;AAAEK,MAAAA,MAAM,EAAEY,WAAV;AAAuBhB,MAAAA,MAAM,EAAEc;AAA/B,KAAD;AAAhD,GAAV;AACA,SAAOJ,IAAP;AACD,CAfM,C,CAkBP;;AACA,OAAO,MAAMW,YAAY,GAAG,CAACzB,IAAD,EAAOa,KAAK,GAAC,CAAb,EAAgBC,IAAI,GAAC;AAAEb,EAAAA,KAAK,EAAC,EAAR;AAAYE,EAAAA,KAAK,EAAC;AAAlB,CAArB,KAA+C;AACzE;AACAW,EAAAA,IAAI,CAACb,KAAL,CAAWM,IAAX,CAAgB;AAAEF,IAAAA,EAAE,EAAEL;AAAN,GAAhB,EAFyE,CAGzE;;AACA,MAAIa,KAAK,IAAI,CAAb,EAAiB,OAAOC,IAAP;;AACjB,OAAI,IAAIlB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGV,YAAY,CAAC,CAAD,CAA/B,EAAoCU,CAAC,EAArC,EAAwC;AACtC;AACA,QAAImB,aAAa,GAAGxB,YAAY,CAAC,CAAD,CAAhC,CAFsC,CAGtC;;AACAuB,IAAAA,IAAI,CAACX,KAAL,CAAWI,IAAX,CAAgB;AAAEC,MAAAA,MAAM,EAAER,IAAV;AAAgBI,MAAAA,MAAM,EAAEW;AAAxB,KAAhB,EAJsC,CAKtC;;AACAU,IAAAA,YAAY,CAACV,aAAD,EAAgBF,KAAK,GAAE,CAAvB,EAA0BC,IAA1B,CAAZ;AACD;;AACD,SAAOA,IAAP;AACD,CAdM","sourcesContent":["\n// function for getting random num\nexport const getRandomInt = (max) => {\n\t\treturn Math.floor(Math.random() * Math.floor(max))+1 ;\n}\n\n// fuction for getting a random string\nexport const getRandomStr = (length) => {\n\t\tvar result           = '';\n\t\tvar characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t\tvar charactersLength = characters.length;\n\t\tfor ( var i = 0; i < length; i++ ) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t\treturn result;\n}\n\n//generate random link\nexport const getRandomLinks = (link_number, word, nodes) => {\n\t\tvar seen_targets = [] \n\t\tvar links = [];\n\t\tfor (var i = 0; i < link_number; i++ ){\n\t\t\t\tvar target = nodes[getRandomInt(nodes.length-1)].id;\n\t\t\t\tif(!seen_targets.includes(target)){\n\t\t\t\t\t\tlinks.push({ source: word, target: target });\n\t\t\t\t\t\tseen_targets.push(target);\n\t\t\t\t}\n\t\t}\n\t\treturn links;\n}\n\n// Generate a random node \nexport const genRandomNode = (nodes) => {\n\t\tvar title = getRandomStr(6);\n\t\tvar links = getRandomLinks(getRandomInt(6), title, nodes);\n\t\treturn { node:{ id: title }, links };\n}\n\n\n// generate a list of grapth recursibly\nexport const genGrapNodes = (word, depth=0, data=[]) =>{\n\t\tfor(var i = 0; i < getRandomInt(3); i++){\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\tdata.push({  node:{id: adjacent_word }, links:[{ source: word, target: adjacent_word }] });\n\t\t\t\tif( depth > 0 ) genGrapNodes(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n// Generate a Nodes path from  node to the other\nexport const genPath = (start, destination) =>{\n\t\tlet distance  = getRandomInt(10) + 5;\n\t\tlet currentNode = start;\n\t\tlet data = [];\n\t\tfor(var i = 0; i < distance; i++){\n\t\t\t\tvar nextNode = getRandomStr(8);\n\t\t\t\tdata.push({ node:{ id: nextNode, color: 'red' }, links:[{ source: currentNode, target: nextNode }] })\n\t\t\t\tfor(var j = 0; j < getRandomInt(5); j++){\n\t\t\t\t\t\tvar adjacentNode = getRandomStr(8);\n\t\t\t\t\t\tdata.push({ node:{ id: adjacentNode }, links:[{ source: nextNode, target: adjacentNode }] })\n\t\t\t\t}\n\t\t\t\tcurrentNode = nextNode;\n\t\t}\n\t\tdata.push({ node:{ id: destination, color: 'red'},  links:[{ source: currentNode, target: destination }] })\n\t\treturn data;\n}\n\n\n// generate a list of grapth recursibly sent them in lists \nexport const genGrapDepth = (word, depth=0, data={ nodes:[], links:[] }) =>{\n\t\t// Add word to data nodes \n\t\tdata.nodes.push({ id: word });\n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) return data;\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\t//gen a adjecent word\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\t// Add link \n\t\t\t\tdata.links.push({ source: word, target: adjacent_word });\n\t\t\t\t// be a recursive bitch\n\t\t\t\tgenGrapDepth(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export default function (d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d),\n      z = +this._z.call(null, d);\n  return add(this.cover(x, y, z), x, y, z, d);\n}\n\nfunction add(tree, x, y, z, d) {\n  if (isNaN(x) || isNaN(y) || isNaN(z)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {\n    data: d\n  },\n      x0 = tree._x0,\n      y0 = tree._y0,\n      z0 = tree._z0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      z1 = tree._z1,\n      xm,\n      ym,\n      zm,\n      xp,\n      yp,\n      zp,\n      right,\n      bottom,\n      deep,\n      i,\n      j; // If the tree is empty, initialize the root as a leaf.\n\n  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.\n\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;\n    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm;else z1 = zm;\n    if (parent = node, !(node = node[i = deep << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;\n  } // Is the new point is exactly coincident with the existing point?\n\n\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  zp = +tree._z.call(null, node.data);\n  if (x === xp && y === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.\n\n  do {\n    parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;\n    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm;else z1 = zm;\n  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));\n\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d,\n      i,\n      n = data.length,\n      x,\n      y,\n      z,\n      xz = new Array(n),\n      yz = new Array(n),\n      zz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      z0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity,\n      z1 = -Infinity; // Compute the points and their extent.\n\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    zz[i] = z;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n    if (z < z0) z0 = z;\n    if (z > z1) z1 = z;\n  } // If there were no (valid) points, inherit the existing extent.\n\n\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n  if (z1 < z0) z0 = this._z0, z1 = this._z1; // Expand the tree to cover the new points.\n\n  this.cover(x0, y0, z0).cover(x1, y1, z1); // Add the new points.\n\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], zz[i], data[i]);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-octree/src/add.js"],"names":["d","x","_x","call","y","_y","z","_z","add","cover","tree","isNaN","parent","node","_root","leaf","data","x0","_x0","y0","_y0","z0","_z0","x1","_x1","y1","_y1","z1","_z1","xm","ym","zm","xp","yp","zp","right","bottom","deep","i","j","length","next","Array","addAll","n","xz","yz","zz","Infinity"],"mappings":"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","sourcesContent":["export default function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d),\n      z = +this._z.call(null, d);\n  return add(this.cover(x, y, z), x, y, z, d);\n}\n\nfunction add(tree, x, y, z, d) {\n  if (isNaN(x) || isNaN(y) || isNaN(z)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      z0 = tree._z0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      z1 = tree._z1,\n      xm,\n      ym,\n      zm,\n      xp,\n      yp,\n      zp,\n      right,\n      bottom,\n      deep,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;\n    if (parent = node, !(node = node[i = deep << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  zp = +tree._z.call(null, node.data);\n  if (x === xp && y === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;\n  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      z,\n      xz = new Array(n),\n      yz = new Array(n),\n      zz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      z0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity,\n      z1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    zz[i] = z;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n    if (z < z0) z0 = z;\n    if (z > z1) z1 = z;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n  if (z1 < z0) z0 = this._z0, z1 = this._z1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0, z0).cover(x1, y1, z1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], zz[i], data[i]);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}
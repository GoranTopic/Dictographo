{"ast":null,"code":"/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['color'] = colors.node.default;\n  return node;\n}; // retrive node with given node id from state \n\n\nconst getNode = (state, nodeId) => state.nodes.filter(node => node.id === nodeId)[0]; // attemps to return true id node is not in state\n\n\nconst isNotInState = (state, nodeId) => state.nodes.every(node => node.id !== nodeId);\n\nconst requestSynonymNodes = (node, dispatchState) => {\n  /* for every node request the adjecent node to it */\n  node.synonyms.forEach(synonym => {\n    if (isNotInState(synonym['synonym'])) {\n      fetch(API_ENDPOINT + synonym[\"synonym\"]).then(result => result.json()).then(result => processNode(result)).then(adjNode => {\n        dispatchState({\n          type: 'SET_NODE_LINK',\n          payload: {\n            node: adjNode,\n            link: {\n              source: node.id,\n              target: adjNode.id\n            }\n          }\n        });\n      }).catch(() => dispatchState({\n        type: 'SET_FETCH_FAILED'\n      }));\n    }\n  });\n};\n\nconst isWordNotFound = result => {\n  // Set error to state when user search a word not found\n  if (result.detail === \"Not found.\") {\n    dispatchState({\n      type: 'SET_WORD_NOT_FOUND'\n    });\n    throw new Error(\"word not found\");\n  } else {\n    return result;\n  }\n};\n\nconst onClickNode = function (dispatchState, nodeId) {\n  // when user clicks on a node\n  requestSynonymNodes(getNode(nodeId));\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: nodeId\n  });\n};\n\nconst onMouseOverNode = function (nodeId) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, requestSynonymNodes, onClickNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["processNode","node","w_id","colors","default","getNode","state","nodeId","nodes","filter","id","isNotInState","every","requestSynonymNodes","dispatchState","synonyms","forEach","synonym","fetch","API_ENDPOINT","then","result","json","adjNode","type","payload","link","source","target","catch","isWordNotFound","detail","Error","onClickNode","onMouseOverNode"],"mappings":"AAAA;;;;;;AAQA,MAAMA,WAAW,GAAIC,IAAD,IAAS;AAC3B;;AAEAA,EAAAA,IAAI,CAAC,IAAD,CAAJ,GAAaA,IAAI,CAACC,IAAlB;AACAD,EAAAA,IAAI,CAAC,KAAD,CAAJ,GAAcA,IAAI,CAACC,IAAnB;AACAD,EAAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,KAArB;AACAA,EAAAA,IAAI,CAAC,OAAD,CAAJ,GAAgBE,MAAM,CAACF,IAAP,CAAYG,OAA5B;AACA,SAAOH,IAAP;AACD,CARD,C,CAUA;;;AACA,MAAMI,OAAO,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmBD,KAAK,CAACE,KAAN,CAAYC,MAAZ,CAAoBR,IAAI,IAAIA,IAAI,CAACS,EAAL,KAAYH,MAAxC,EAAiD,CAAjD,CAAnC,C,CAEA;;;AACA,MAAMI,YAAY,GAAG,CAACL,KAAD,EAAQC,MAAR,KAAmBD,KAAK,CAACE,KAAN,CAAYI,KAAZ,CAAmBX,IAAI,IAAIA,IAAI,CAACS,EAAL,KAAYH,MAAvC,CAAxC;;AAEA,MAAMM,mBAAmB,GAAG,CAACZ,IAAD,EAAOa,aAAP,KAAyB;AACnD;AACAb,EAAAA,IAAI,CAACc,QAAL,CAAcC,OAAd,CAAsBC,OAAO,IAAI;AAC/B,QAAGN,YAAY,CAACM,OAAO,CAAC,SAAD,CAAR,CAAf,EAAoC;AAClCC,MAAAA,KAAK,CAACC,YAAY,GAAGF,OAAO,CAAC,SAAD,CAAvB,CAAL,CACGG,IADH,CACQC,MAAM,IAAIA,MAAM,CAACC,IAAP,EADlB,EAEGF,IAFH,CAEQC,MAAM,IAAIrB,WAAW,CAACqB,MAAD,CAF7B,EAGGD,IAHH,CAGQG,OAAO,IAAI;AACfT,QAAAA,aAAa,CAAC;AACZU,UAAAA,IAAI,EAAE,eADM;AAEZC,UAAAA,OAAO,EAAE;AACPxB,YAAAA,IAAI,EAAEsB,OADC;AAEPG,YAAAA,IAAI,EAAE;AACJC,cAAAA,MAAM,EAAE1B,IAAI,CAACS,EADT;AAEJkB,cAAAA,MAAM,EAAEL,OAAO,CAACb;AAFZ;AAFC;AAFG,SAAD,CAAb;AAUD,OAdH,EAeGmB,KAfH,CAeS,MAAMf,aAAa,CAAC;AAACU,QAAAA,IAAI,EAAC;AAAN,OAAD,CAf5B;AAgBD;AACF,GAnBD;AAoBD,CAtBD;;AAwBA,MAAMM,cAAc,GAAIT,MAAD,IAAa;AAClC;AACA,MAAIA,MAAM,CAACU,MAAP,KAAkB,YAAtB,EAAqC;AACnCjB,IAAAA,aAAa,CAAC;AAACU,MAAAA,IAAI,EAAE;AAAP,KAAD,CAAb;AACA,UAAM,IAAIQ,KAAJ,CAAU,gBAAV,CAAN;AACD,GAHD,MAGK;AACH,WAAOX,MAAP;AACD;AACF,CARD;;AAUA,MAAMY,WAAW,GAAG,UAASnB,aAAT,EAAwBP,MAAxB,EAAgC;AAClD;AACAM,EAAAA,mBAAmB,CAACR,OAAO,CAACE,MAAD,CAAR,CAAnB;AACAO,EAAAA,aAAa,CAAC;AAACU,IAAAA,IAAI,EAAC,sBAAN;AAA8BC,IAAAA,OAAO,EAAElB;AAAvC,GAAD,CAAb;AACD,CAJD;;AAMA,MAAM2B,eAAe,GAAG,UAAS3B,MAAT,EAAiB;AACvCO,EAAAA,aAAa,CAAC;AAACU,IAAAA,IAAI,EAAC,kBAAN;AAA0BC,IAAAA,OAAO,EAAElB;AAAnC,GAAD,CAAb,CADuC,CAEvC;AACD,CAHD;;AAKA,SAASP,WAAT,EAAsB8B,cAAtB,EAAsCjB,mBAAtC,EAA2DoB,WAA3D","sourcesContent":["/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n// retrive node with given node id from state \nconst getNode = (state, nodeId) => state.nodes.filter( node => node.id === nodeId )[0]\n\n// attemps to return true id node is not in state\nconst isNotInState = (state, nodeId) => state.nodes.every( node => node.id !== nodeId )\n\nconst requestSynonymNodes = (node, dispatchState) => {\n\t\t/* for every node request the adjecent node to it */\n\t\tnode.synonyms.forEach(synonym => {\n\t\t\t\tif(isNotInState(synonym['synonym'])){\n\t\t\t\t\t\tfetch(API_ENDPOINT + synonym[\"synonym\"])\n\t\t\t\t\t\t\t\t.then(result => result.json())\n\t\t\t\t\t\t\t\t.then(result => processNode(result))\n\t\t\t\t\t\t\t\t.then(adjNode => {\n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n\t\t\t\t}\n\t\t})\n}\n\nconst isWordNotFound = (result, ) =>{\n\t\t// Set error to state when user search a word not found\n\t\tif( result.detail === \"Not found.\" ) {\n\t\t\t\tdispatchState({type: 'SET_WORD_NOT_FOUND'})\n\t\t\t\tthrow new Error(\"word not found\")\n\t\t}else{\n\t\t\t\treturn result\n\t\t}\n}\n\nconst onClickNode = function(dispatchState, nodeId) {\n\t\t// when user clicks on a node\n\t\trequestSynonymNodes(getNode(nodeId))\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})  \n};\n\nconst onMouseOverNode = function(nodeId) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, requestSynonymNodes, onClickNode }\n\n"]},"metadata":{},"sourceType":"module"}
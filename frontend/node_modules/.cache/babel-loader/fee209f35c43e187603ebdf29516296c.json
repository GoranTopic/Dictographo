{"ast":null,"code":"import tree_add, { addAll as tree_addAll } from \"./add\";\nimport tree_cover from \"./cover\";\nimport tree_data from \"./data\";\nimport tree_extent from \"./extent\";\nimport tree_find from \"./find\";\nimport tree_remove, { removeAll as tree_removeAll } from \"./remove\";\nimport tree_root from \"./root\";\nimport tree_size from \"./size\";\nimport tree_visit from \"./visit\";\nimport tree_visitAfter from \"./visitAfter\";\nimport tree_x, { defaultX } from \"./x\";\nexport default function binarytree(nodes, x) {\n  var tree = new Binarytree(x == null ? defaultX : x, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Binarytree(x, x0, x1) {\n  this._x = x;\n  this._x0 = x0;\n  this._x1 = x1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {\n    data: leaf.data\n  },\n      next = copy;\n\n  while (leaf = leaf.next) next = next.next = {\n    data: leaf.data\n  };\n\n  return copy;\n}\n\nvar treeProto = binarytree.prototype = Binarytree.prototype;\n\ntreeProto.copy = function () {\n  var copy = new Binarytree(this._x, this._x0, this._x1),\n      node = this._root,\n      nodes,\n      child;\n  if (!node) return copy;\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n  nodes = [{\n    source: node,\n    target: copy._root = new Array(2)\n  }];\n\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 2; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({\n          source: child,\n          target: node.target[i] = new Array(2)\n        });else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = tree_addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = tree_removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-binarytree/src/binarytree.js"],"names":["tree_add","addAll","tree_addAll","tree_cover","tree_data","tree_extent","tree_find","tree_remove","removeAll","tree_removeAll","tree_root","tree_size","tree_visit","tree_visitAfter","tree_x","defaultX","binarytree","nodes","x","tree","Binarytree","NaN","x0","x1","_x","_x0","_x1","_root","undefined","leaf_copy","leaf","copy","data","next","treeProto","prototype","node","child","length","source","target","Array","pop","i","push","add","cover","extent","find","remove","root","size","visit","visitAfter"],"mappings":"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","sourcesContent":["import tree_add, {addAll as tree_addAll} from \"./add\";\nimport tree_cover from \"./cover\";\nimport tree_data from \"./data\";\nimport tree_extent from \"./extent\";\nimport tree_find from \"./find\";\nimport tree_remove, {removeAll as tree_removeAll} from \"./remove\";\nimport tree_root from \"./root\";\nimport tree_size from \"./size\";\nimport tree_visit from \"./visit\";\nimport tree_visitAfter from \"./visitAfter\";\nimport tree_x, {defaultX} from \"./x\";\n\nexport default function binarytree(nodes, x) {\n  var tree = new Binarytree(x == null ? defaultX : x, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Binarytree(x, x0, x1) {\n  this._x = x;\n  this._x0 = x0;\n  this._x1 = x1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = binarytree.prototype = Binarytree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Binarytree(this._x, this._x0, this._x1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(2)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 2; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(2)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = tree_addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = tree_removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;"]},"metadata":{},"sourceType":"module"}
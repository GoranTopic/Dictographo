{"ast":null,"code":"export default function (d) {\n  var x = +this._x.call(null, d);\n  return add(this.cover(x), x, d);\n}\n\nfunction add(tree, x, d) {\n  if (isNaN(x)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {\n    data: d\n  },\n      x0 = tree._x0,\n      x1 = tree._x1,\n      xm,\n      xp,\n      right,\n      i,\n      j; // If the tree is empty, initialize the root as a leaf.\n\n  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.\n\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (parent = node, !(node = node[i = +right])) return parent[i] = leaf, tree;\n  } // Is the new point is exactly coincident with the existing point?\n\n\n  xp = +tree._x.call(null, node.data);\n  if (x === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.\n\n  do {\n    parent = parent ? parent[i] = new Array(2) : tree._root = new Array(2);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n  } while ((i = +right) === (j = +(xp >= xm)));\n\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var i,\n      n = data.length,\n      x,\n      xz = new Array(n),\n      x0 = Infinity,\n      x1 = -Infinity; // Compute the points and their extent.\n\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, data[i]))) continue;\n    xz[i] = x;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n  } // If there were no (valid) points, inherit the existing extent.\n\n\n  if (x1 < x0) x0 = this._x0, x1 = this._x1; // Expand the tree to cover the new points.\n\n  this.cover(x0).cover(x1); // Add the new points.\n\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], data[i]);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-binarytree/src/add.js"],"names":["d","x","_x","call","add","cover","tree","isNaN","parent","node","_root","leaf","data","x0","_x0","x1","_x1","xm","xp","right","i","j","length","next","Array","addAll","n","xz","Infinity"],"mappings":"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","sourcesContent":["export default function(d) {\n  var x = +this._x.call(null, d);\n  return add(this.cover(x), x, d);\n}\n\nfunction add(tree, x, d) {\n  if (isNaN(x)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      x1 = tree._x1,\n      xm,\n      xp,\n      right,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (parent = node, !(node = node[i = +right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  if (x === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(2) : tree._root = new Array(2);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n  } while ((i = +right) === (j = +(xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var i, n = data.length,\n      x,\n      xz = new Array(n),\n      x0 = Infinity,\n      x1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, data[i]))) continue;\n    xz[i] = x;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0).cover(x1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], data[i]);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { colors, API_ENDPOINT } from \"./myConfig\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['color'] = colors.node.default;\n  return node;\n}; // retrive node with given node id from state \n\n\nconst getNode = (nodeId, state) => state.nodes.filter(node => node.id === nodeId)[0]; // attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\n\n\nconst isNewNode = (nodeId, state) => state.nodes.every(node => node.id !== nodeId);\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n  // when user clicks on a node\n  requestAdjecentNodes(getNode(nodeId, state), state, dispatchState);\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: nodeId\n  });\n};\n\nconst queryNewWord = (word, state, dispatchState) => {\n  /* reset the graph state and start a new query into a word, \n   * sometime this stymes when it is called a second time,\n   * this might be because of dispatchState being called twice\n   * must investigate.  */\n  fetch(API_ENDPOINT + word) // unpack json\n  .then(result => result.json()).then(result => isWordNotFound(result)).then(result => processNode(result)).then(node => {\n    dispatchState({\n      type: 'SET_NEW_NODE',\n      payload: node\n    });\n    return node;\n  }).then(node => requestAdjecentNodes(node, state, dispatchState)).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst requestAdjecentNodes = (node, state, dispatchState) => {\n  /* for every node request the adjecent node to it */\n  let linkAll = state.isDeepLinks; // define whether we should link te deeper\n\n  let time = 1;\n  let graph_type = 'synonyms/'; // define which type of graph we are requesting\n\n  let timeoutWait = 0;\n  fetch(API_ENDPOINT + graph_type + node.id) // request the synonyms\n  .then(result => result.json()).then(result => isWordNotFound(result)).then(adjNodes => adjNodes.forEach(adjNode => {\n    setTimeout(() => {\n      //for each of the nodes in the list \t\t\n      adjNode = processNode(adjNode); //process node \n\n      console.log(timeoutWait);\n\n      if (linkAll || isNewNode(adjNode.id, state)) {\n        console.log(time);\n        dispatchState({\n          type: 'SET_NODE_LINK',\n          payload: {\n            node: adjNode,\n            link: {\n              source: node.id,\n              target: adjNode.id\n            }\n          }\n        });\n      }\n    }, timeoutWait);\n    timeoutWait = timeoutWait + 1;\n    time = time + 1;\n  })).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst isWordNotFound = (response, dispatchState) => {\n  // Set error to state when user search a word not found\n  if (response.detail === \"Not found.\") {\n    dispatchState({\n      type: 'SET_WORD_NOT_FOUND'\n    });\n    throw new Error(\"word not found\");\n  } else {\n    return response;\n  }\n};\n\nconst onMouseOverNode = function (nodeId, dispatchState) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, queryNewWord, requestAdjecentNodes, onClickNode, onMouseOverNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","processNode","node","w_id","default","getNode","nodeId","state","nodes","filter","id","isNewNode","every","onClickNode","dispatchState","requestAdjecentNodes","type","payload","queryNewWord","word","fetch","then","result","json","isWordNotFound","catch","linkAll","isDeepLinks","time","graph_type","timeoutWait","adjNodes","forEach","adjNode","setTimeout","console","log","link","source","target","response","detail","Error","onMouseOverNode"],"mappings":"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","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\n\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n// retrive node with given node id from state \nconst getNode = (nodeId, state) => state.nodes.filter( node => node.id === nodeId )[0]\n\n// attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\nconst isNewNode = (nodeId, state) => state.nodes.every( node => node.id !== nodeId )\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n\t\t// when user clicks on a node\n\t\trequestAdjecentNodes(getNode(nodeId, state), state, dispatchState)\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})  \n};\n\nconst queryNewWord = (word, state, dispatchState) => {\n\t\t\t\t/* reset the graph state and start a new query into a word, \n\t\t\t\t * sometime this stymes when it is called a second time,\n\t\t\t\t * this might be because of dispatchState being called twice\n\t\t\t\t * must investigate.  */\n\t\t\t\tfetch(API_ENDPOINT + word)\n\t\t\t\t// unpack json\n\t\t\t\t\t\t.then(result => result.json())\n\t\t\t\t\t\t.then(result => isWordNotFound(result))\n\t\t\t\t\t\t.then(result => processNode(result))\n\t\t\t\t\t\t.then(node => { \n\t\t\t\t\t\t\t\tdispatchState({type: 'SET_NEW_NODE', payload: node}); \n\t\t\t\t\t\t\t\treturn node; })\n\t\t\t\t\t\t.then(node => requestAdjecentNodes(node, state, dispatchState))\n\t\t\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n\t\t}\n\nconst requestAdjecentNodes = (node, state, dispatchState) => {\n\t\t/* for every node request the adjecent node to it */\n\t\tlet linkAll = state.isDeepLinks;\n\t\t// define whether we should link te deeper\n\t\tlet time = 1\n\t\tlet graph_type = 'synonyms/';\n\t\t// define which type of graph we are requesting\n\t\tlet timeoutWait = 0;\n\t\tfetch(API_ENDPOINT + graph_type + node.id )\n\t\t// request the synonyms\n\t\t\t\t.then(result => result.json())\n\t\t\t\t.then(result => isWordNotFound(result))\n\t\t\t\t.then(adjNodes => adjNodes.forEach( \n\t\t\t\t\t\tadjNode => { setTimeout(() => {  \n\t\t\t\t\t\t\t\t//for each of the nodes in the list \t\t\n\t\t\t\t\t\t\t\tadjNode = processNode(adjNode); //process node \n\t\t\t\t\t\t\t\tconsole.log(timeoutWait);\n\t\t\t\t\t\t\t\tif(linkAll || isNewNode(adjNode.id, state)){\n\t\t\t\t\t\t\t\t\t\tconsole.log(time);\n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, timeoutWait)\n\t\t\t\t\t\t\t\ttimeoutWait = timeoutWait + 1;\n\t\t\t\t\t\t\t\ttime = time + 1;\n\t\t\t\t\t\t}\n\t\t\t\t))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\nconst isWordNotFound = (response, dispatchState) =>{\n\t\t// Set error to state when user search a word not found\n\t\tif( response.detail === \"Not found.\" ) {\n\t\t\t\tdispatchState({type: 'SET_WORD_NOT_FOUND'})\n\t\t\t\tthrow new Error(\"word not found\")\n\t\t}else{\n\t\t\t\treturn response\n\t\t}\n}\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, isWordNotFound, queryNewWord, requestAdjecentNodes, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
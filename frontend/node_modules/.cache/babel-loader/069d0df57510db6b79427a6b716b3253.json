{"ast":null,"code":"var createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  var code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  var pattern = createPatternBuilder(dimension);\n  var code = \"\\n  var length = bodies.length;\\n  if (length === 0) return 0;\\n\\n  \".concat(pattern('var d{var} = 0, t{var} = 0;', {\n    indent: 2\n  }), \"\\n\\n  for (var i = 0; i < length; ++i) {\\n    var body = bodies[i];\\n    if (body.isPinned) continue;\\n\\n    if (adaptiveTimeStepWeight && body.springCount) {\\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\\n    }\\n\\n    var coeff = timeStep / body.mass;\\n\\n    \").concat(pattern('body.velocity.{var} += coeff * body.force.{var};', {\n    indent: 4\n  }), \"\\n    \").concat(pattern('var v{var} = body.velocity.{var};', {\n    indent: 4\n  }), \"\\n    var v = Math.sqrt(\").concat(pattern('v{var} * v{var}', {\n    join: ' + '\n  }), \");\\n\\n    if (v > 1) {\\n      // We normalize it so that we move within timeStep range. \\n      // for the case when v <= 1 - we let velocity to fade out.\\n      \").concat(pattern('body.velocity.{var} = v{var} / v;', {\n    indent: 6\n  }), \"\\n    }\\n\\n    \").concat(pattern('d{var} = timeStep * body.velocity.{var};', {\n    indent: 4\n  }), \"\\n\\n    \").concat(pattern('body.pos.{var} += d{var};', {\n    indent: 4\n  }), \"\\n\\n    \").concat(pattern('t{var} += Math.abs(d{var});', {\n    indent: 4\n  }), \"\\n  }\\n\\n  return (\").concat(pattern('t{var} * t{var}', {\n    join: ' + '\n  }), \")/length;\\n\");\n  return code;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js"],"names":["createPatternBuilder","require","module","exports","generateIntegratorFunction","generateIntegratorFunctionBody","dimension","code","Function","pattern","indent","join"],"mappings":"AAAA,IAAMA,oBAAoB,GAAGC,OAAO,CAAC,wBAAD,CAApC;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,0BAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,8BAAf,GAAgDA,8BAAhD;;AAEA,SAASD,0BAAT,CAAoCE,SAApC,EAA+C;AAC7C,MAAIC,IAAI,GAAGF,8BAA8B,CAACC,SAAD,CAAzC;AACA,SAAO,IAAIE,QAAJ,CAAa,QAAb,EAAuB,UAAvB,EAAmC,wBAAnC,EAA6DD,IAA7D,CAAP;AACD;;AAED,SAASF,8BAAT,CAAwCC,SAAxC,EAAmD;AACjD,MAAIG,OAAO,GAAGT,oBAAoB,CAACM,SAAD,CAAlC;AACA,MAAIC,IAAI,iFAINE,OAAO,CAAC,6BAAD,EAAgC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAhC,CAJD,oTAgBJD,OAAO,CAAC,kDAAD,EAAqD;AAACC,IAAAA,MAAM,EAAE;AAAT,GAArD,CAhBH,mBAiBJD,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAjBH,qCAkBcD,OAAO,CAAC,iBAAD,EAAoB;AAACE,IAAAA,IAAI,EAAE;AAAP,GAApB,CAlBrB,+KAuBFF,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAvBL,4BA0BJD,OAAO,CAAC,0CAAD,EAA6C;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA7C,CA1BH,qBA4BJD,OAAO,CAAC,2BAAD,EAA8B;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA9B,CA5BH,qBA8BJD,OAAO,CAAC,6BAAD,EAAgC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAhC,CA9BH,gCAiCED,OAAO,CAAC,iBAAD,EAAoB;AAACE,IAAAA,IAAI,EAAE;AAAP,GAApB,CAjCT,gBAAR;AAmCA,SAAOJ,IAAP;AACD","sourcesContent":["const createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {indent: 2})}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {indent: 4})}\n    ${pattern('var v{var} = body.velocity.{var};', {indent: 4})}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {join: ' + '})});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {indent: 6})}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {indent: 4})}\n\n    ${pattern('body.pos.{var} += d{var};', {indent: 4})}\n\n    ${pattern('t{var} += Math.abs(d{var});', {indent: 4})}\n  }\n\n  return (${pattern('t{var} * t{var}', {join: ' + '})})/length;\n`\n  return code;\n}\n"]},"metadata":{},"sourceType":"script"}
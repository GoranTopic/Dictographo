{"ast":null,"code":"import { colors, API_ENDPOINT } from \"./myConfig\";\nimport { getRandomInt } from \"./Components/RandomGenerator\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['color'] = colors.node.default;\n  return node;\n}; // retrive node with given node id from state \n\n\nconst getNode = (nodeId, state) => state.nodes.filter(node => node.id === nodeId)[0]; // attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\n\n\nconst isNewNode = (nodeId, state) => state.nodes.every(node => node.id !== nodeId);\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n  // when user clicks on a node\n  queryAdjecentNodes(getNode(nodeId, state), state, dispatchState);\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: nodeId\n  });\n};\n\nconst timelyDispatch = (dispatchFunc, waitTime = 0, random = 10) => {\n  /* takes a dispachState functions and dispaches it in a \n   * random timply fashion this is usefulf for node not to \n   * appear all at once in the graph and make it easier on \n   * the browser. Returns nothing*/\n  setTimeout(dispatchFunc, waitTime + getRandomInt(random));\n};\n\nconst queryNewWord = (word, state, dispatchState) => {\n  /* reset the graph state and start a new query into a word, \n   * sometime this stymes when it is called a second time,\n   * this might be because of dispatchState being called twice\n   * must investigate.  */\n  fetch(API_ENDPOINT + word) // unpack json\n  .then(result => result.json()) //unpack word\n  .then(result => catchError(result, state, dispatchState)) //check if word was found\n  .then(result => processNode(result)) //process node\n  .then(node => {\n    //dispatch word\n    dispatchState({\n      type: 'SET_NEW_NODE',\n      payload: node\n    });\n    return node;\n  }) // get the surrounding words\n  .then(node => queryAdjecentNodes(node, state, dispatchState)).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst pairUp = list => {\n  /* takes a list of inputs and \n   * divied it into pairs */\n  let pairs = [];\n\n  for (let i = 0; i + 1 <= list.length - 1; i++) pairs.push({\n    'first': list[i],\n    'last': list[i + 1]\n  });\n\n  return pairs;\n};\n\nconst getFoundWords = async (words, dispatchState) => {\n  /* gets a list of word and removes the\n   * this seemly simplet task is hard to do with promises\n   * one whihc are not in api*/\n  var foundWords = new Array(words.lenght); // make a empty array of as long as\n  // the origial to mantain the same order\n\n  await Promise.all(words.map((word, index) => // for every word check the api, \n  // await untill all promises are returned\n  fetch(API_ENDPOINT + 'check/' + word + \"/\").then(response => response.json()).then(response => {\n    if (response.detail === \"Found.\") {\n      foundWords[index] = word;\n    } else {\n      dispatchState({\n        type: 'SET_WORD_NOT_FOUND',\n        payload: word\n      });\n    }\n  }).catch(err => console.log(err))));\n  return foundWords.filter(Boolean);\n};\n\nconst processPath = path => {\n  /* add for each node in the path where it comming from */\n  let prevNode = null;\n\n  if (path instanceof Array) {\n    path.forEach(node => {\n      node = processNode(node);\n      node['prevNode'] = prevNode;\n      prevNode = node.id;\n    });\n  }\n\n  return path;\n};\n\nconst fetchPathsParts = async (pathRequests, dispatchState) => {\n  /* gets a list of pair request for paths an queryes the api \n   * then is saves those paths in a order list and returns*/\n  var paths = new Array(pathRequests.length);\n  await Promise.all(pathRequests.map((request, index) => fetch(API_ENDPOINT + 'path/' + request.first + \"/\" + request.last).then(response => response.json()).then(response => processPath(response)).then(response => {\n    if (response.detail === \"Path not found.\") {\n      dispatchState({\n        type: 'SET_PATH_NOT_FOUND',\n        payload: request\n      });\n      paths[index] = null;\n    } else {\n      paths[index] = response;\n    }\n  }).catch(err => console.log(err))));\n  return paths;\n};\n\nconst amendPath = async paths => {\n  const getGaps = paths => {\n    let gaps = [];\n    let gap = {\n      start: null,\n      end: null\n    };\n    let wasPath = false;\n    let wasGap = false;\n    paths.forEach((path, index) => {\n      if (path === null) {\n        // if it is gap\n        if (wasPath) {\n          // comes from gap\n          gap.start = index; //save start\n        } // and comes from path\n\n\n        wasGap = true; // switch to gap\n\n        wasPath = false;\n      } else {\n        //if is path\n        if (wasGap) {\n          // and comes from gap\n          gap.end = index; // record end\n\n          gaps.push({ ...gap\n          }); //save gap\n        }\n\n        wasPath = true; // switch to path \n\n        wasGap = false;\n      }\n    });\n    return gaps;\n  };\n\n  const bridgeGap = async (start, end, paths) => {\n    /* gets a set of indexes indicating the gap, \n     * make fetch request to attempt to find a \n     * conncetion */\n    let pathL = paths[start - 1];\n    let pathR = paths[end];\n    let lastWord = pathL[pathL.length - 1].word;\n    let bridgeFound = false;\n    let index = end - start > 1 ? 0 : 1;\n\n    while (!bridgeFound && index < pathR.length - 1) {\n      //need to user while loop there is one fetch at the time \n      await fetch(API_ENDPOINT + 'path/' + lastWord + \"/\" + pathR[index].word).then(response => response.json()).then(response => processPath(response)).then(response => {\n        if (response.detail === \"Path not found.\") {\n          index++;\n        } else {\n          bridgeFound = true; //break loop\n\n          paths[start] = response; //set the bridge\n        }\n      }).catch(err => console.log(err));\n    }\n  };\n\n  let gaps = getGaps(paths);\n  await Promise.all(gaps.map(gap => bridgeGap(gap.start, gap.end, paths)));\n  return paths;\n};\n\nconst dispatchPath = (paths, state, dispatchState) => {\n  // paths all list together\n  let finalPath = [];\n  paths = paths.filter(Boolean);\n  paths.forEach(path => finalPath.push(...path)); // add all paths together\n\n  console.log(finalPath);\n  finalPath.forEach((node, index) => timelyDispatch(() => {\n    console.log(state.isEmpty);\n\n    if (index === 0) {\n      // if this is the first node\n      dispatchState({\n        type: 'SET_NEW_NODE',\n        payload: node\n      });\n    } else {\n      console.log(node.prevNode);\n      console.log(\" --> \");\n      console.log(node.id);\n      console.log(\"\\n\"); //if there is already other nodes\n\n      let msg = {\n        type: 'SET_PATH_NODE',\n        payload: {\n          node: node,\n          link: {\n            target: node.id,\n            source: node.prevNode\n          }\n        }\n      };\n      if (node.prevNode) msg.payload.link['source'] = node.prevNode;\n      dispatchState(msg);\n    }\n  }, 25, 0)); //se the time as 25 and the random to 0\n};\n\nconst queryPath = async (words, state, dispatchState) => {\n  /* gets passesed a set of two words, \n   * queries the server for the path and \n   * dispateches the result to state */\n  //split words into arrays\n  words = await getFoundWords(words, dispatchState).catch(err => {\n    dispatchState({\n      type: 'SET_ERROR',\n      payload: \"Could not get words\"\n    });\n  });\n  let pathRequests = pairUp(words);\n  let pathParts = await fetchPathsParts(pathRequests, dispatchState).catch(err => {\n    dispatchState({\n      type: 'SET_ERROR',\n      payload: \"could not get paths\"\n    });\n  });\n  console.log(pathParts);\n  let finalPaths = await amendPath(pathParts).catch(err => {\n    dispatchState({\n      type: 'SET_ERROR',\n      payload: \"Could not amend path\"\n    });\n  });\n  dispatchPath(finalPaths, state, dispatchState); //let first = words[i];\n  //let second = words[i+1];\n  //console.log(first)\n  //console.log(second)\n  //let request = fetch(API_ENDPOINT+'path/'+ first +\"/\"+second)\n  //let result = request.json(); // unpack json\n  //if(result.detail === \"Path not found.\"){\n  //console.log(\"path not found\")\n  //}\n\n  /*\n   *\n  \t\t\t\t\t\tconsole.log(\"this ran\")\n  \t\t\t\tlet prevNode = null;\n  \t\t\t\tlet first;\n  \t\t\t\tlet second;\n  \tfor( var i = 0; i+1 <= words.length-1; i++){\n  \t\tfirst = words[i];\n  \t\tsecond = words[i + 1];\n  \t\t//console.log(words)\n  \t\t//console.log(i)\n  \t\tconsole.log(first);\n  \t\tconsole.log(second);\n  \t\tfetch(API_ENDPOINT + 'path/' +  first  + \"/\" + second) \n  \t\t\t\t.then(result => result.json()) // unpack json\n  \t\t\t\t.then(nodes => {console.log(nodes); return nodes })\n  \t\t\t\t.then(nodes => catchError(nodes, state, dispatchState)) \n  \t\t\t\t\t//check if words not found\n  \t\t\t\t.then(pathNodes => {\n  \t\t\t\t\t\t//console.log(pathNodes)\n  \t\t\t\t\t\tpathNodes.forEach((node, index) => \n  \t\t\t\t\t\t\t\ttimelyDispatch(() => {  \n  \t\t\t\t\t\t\t\t\t\tnode = processNode(node);\n  \t\t\t\t\t\t\t\t\t\tif (prevNode === null){ \n  \t\t\t\t\t\t\t\t\t\t\t\t// if this is the first node\n  \t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: node,\n  \t\t\t\t\t\t\t\t\t\t\t\t})\n  \t\t\t\t\t\t\t\t\t\t}else{\n  \t\t\t\t\t\t\t\t\t\t\t\tconsole.log(prevNode.id)\n  \t\t\t\t\t\t\t\t\t\t\t\tconsole.log(\" --> \")\n  \t\t\t\t\t\t\t\t\t\t\t\tconsole.log(node.id)\n  \t\t\t\t\t\t\t\t\t\t\t\tconsole.log(\"\\n\")\n  \t\t\t\t\t\t\t\t\t\t\t\t//if there is already other nodes\n  \t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: prevNode.id, \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t\t\t\t\t\t})\n  \t\t\t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t\t\t\tprevNode = node;\n  \t\t\t\t\t\t\t\t}, 25,0)\n  \t\t\t\t\t\t) //se the time as 25 and the random to 0\n  \t\t\t\t})\n  \t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n  }\n  */\n};\n\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n  /* for every node request the adjecent node to it */\n  let linkAll = state.isDeepLinks; // define whether we should link te deeper\n\n  let graph_type = 'synonyms/'; // define which type of graph we are requesting\n\n  fetch(API_ENDPOINT + graph_type + node.id) // request the synonyms\n  .then(result => result.json()).then(result => catchError(result, state, dispatchState)).then(adjNodes => adjNodes.forEach( // for every node in the array\n  adjNode => timelyDispatch(() => {\n    //for each of the nodes in the list \t\t\n    adjNode = processNode(adjNode); //process node \n\n    if (linkAll || isNewNode(adjNode.id, state)) {\n      // proces is it is new node, or deep link set\n      dispatchState({\n        type: 'SET_NODE_LINK',\n        payload: {\n          node: adjNode,\n          link: {\n            source: node.id,\n            target: adjNode.id\n          }\n        }\n      });\n    }\n  }))).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n\nconst catchError = (response, state, dispatchState) => {\n  /* Set error to state when user search a word not found */\n  //console.log(\"got to cath error:\")\n  //console.log(response)\n  if (response instanceof Array) {\n    let foundWords = []; //console.log(\"words was not found\")\n    // if it has the response for many words\n\n    response.forEach((word, index, words) => {\n      if (word.detail === \"Not Found.\") {\n        dispatchState({\n          type: 'SET_WORD_NOT_FOUND',\n          payload: word.w_id\n        });\n      } else {\n        foundWords.push(word);\n      }\n    });\n    return foundWords;\n  } else {\n    // if it only one elment\n    if (response.detail === \"Not found.\") {\n      dispatchState({\n        type: 'SET_WORD_NOT_FOUND',\n        payload: state.searchTerm\n      });\n      throw new Error(\"word not found\");\n    } else if (response.detail === \"Path not found.\") {\n      // if the error is path not found\n      //console.log(\"path was not found\")\n      dispatchState({\n        type: 'SET_PATH_NOT_FOUND',\n        payload: {\n          'first': response.first,\n          'last': response.last\n        }\n      });\n      throw new Error(\"path not found\");\n    } else {\n      return response;\n    }\n  }\n};\n\nconst onMouseOverNode = function (nodeId, dispatchState) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","getRandomInt","processNode","node","w_id","default","getNode","nodeId","state","nodes","filter","id","isNewNode","every","onClickNode","dispatchState","queryAdjecentNodes","type","payload","timelyDispatch","dispatchFunc","waitTime","random","setTimeout","queryNewWord","word","fetch","then","result","json","catchError","catch","pairUp","list","pairs","i","length","push","getFoundWords","words","foundWords","Array","lenght","Promise","all","map","index","response","detail","err","console","log","Boolean","processPath","path","prevNode","forEach","fetchPathsParts","pathRequests","paths","request","first","last","amendPath","getGaps","gaps","gap","start","end","wasPath","wasGap","bridgeGap","pathL","pathR","lastWord","bridgeFound","dispatchPath","finalPath","isEmpty","msg","link","target","source","queryPath","pathParts","finalPaths","linkAll","isDeepLinks","graph_type","adjNodes","adjNode","searchTerm","Error","onMouseOverNode"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,YAAjB,QAAsC,YAAtC;AACA,SAASC,YAAT,QAA8B,8BAA9B;AAEA;;;;;;;AAQA,MAAMC,WAAW,GAAIC,IAAD,IAAS;AAC3B;;AAEAA,EAAAA,IAAI,CAAC,IAAD,CAAJ,GAAaA,IAAI,CAACC,IAAlB;AACAD,EAAAA,IAAI,CAAC,KAAD,CAAJ,GAAcA,IAAI,CAACC,IAAnB;AACAD,EAAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,KAArB;AACAA,EAAAA,IAAI,CAAC,OAAD,CAAJ,GAAgBJ,MAAM,CAACI,IAAP,CAAYE,OAA5B;AACA,SAAOF,IAAP;AACD,CARD,C,CAUA;;;AACA,MAAMG,OAAO,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmBA,KAAK,CAACC,KAAN,CAAYC,MAAZ,CAAoBP,IAAI,IAAIA,IAAI,CAACQ,EAAL,KAAYJ,MAAxC,EAAiD,CAAjD,CAAnC,C,CAEA;AACA;;;AACA,MAAMK,SAAS,GAAG,CAACL,MAAD,EAASC,KAAT,KAAmBA,KAAK,CAACC,KAAN,CAAYI,KAAZ,CAAmBV,IAAI,IAAIA,IAAI,CAACQ,EAAL,KAAYJ,MAAvC,CAArC;;AAEA,MAAMO,WAAW,GAAG,CAACP,MAAD,EAASC,KAAT,EAAgBO,aAAhB,KAAkC;AACpD;AACAC,EAAAA,kBAAkB,CAACV,OAAO,CAACC,MAAD,EAASC,KAAT,CAAR,EAAyBA,KAAzB,EAAgCO,aAAhC,CAAlB;AACAA,EAAAA,aAAa,CAAC;AAACE,IAAAA,IAAI,EAAC,sBAAN;AAA8BC,IAAAA,OAAO,EAAEX;AAAvC,GAAD,CAAb;AACD,CAJD;;AAMA,MAAMY,cAAc,GAAG,CAACC,YAAD,EAAgBC,QAAQ,GAAC,CAAzB,EAA4BC,MAAM,GAAC,EAAnC,KAA0C;AAChE;;;;AAICC,EAAAA,UAAU,CAACH,YAAD,EAAeC,QAAQ,GAAGpB,YAAY,CAACqB,MAAD,CAAtC,CAAV;AACD,CAND;;AAQA,MAAME,YAAY,GAAG,CAACC,IAAD,EAAOjB,KAAP,EAAcO,aAAd,KAAgC;AACnD;;;;AAIAW,EAAAA,KAAK,CAAC1B,YAAY,GAAGyB,IAAhB,CAAL,CACA;AADA,GAEGE,IAFH,CAEQC,MAAM,IAAIA,MAAM,CAACC,IAAP,EAFlB,EAEiC;AAFjC,GAGGF,IAHH,CAGQC,MAAM,IAAIE,UAAU,CAACF,MAAD,EAASpB,KAAT,EAAgBO,aAAhB,CAH5B,EAG2D;AAH3D,GAIGY,IAJH,CAIQC,MAAM,IAAI1B,WAAW,CAAC0B,MAAD,CAJ7B,EAIuC;AAJvC,GAKGD,IALH,CAKQxB,IAAI,IAAI;AAAE;AACdY,IAAAA,aAAa,CAAC;AACZE,MAAAA,IAAI,EAAE,cADM;AAEZC,MAAAA,OAAO,EAAEf;AAFG,KAAD,CAAb;AAIA,WAAOA,IAAP;AAAc,GAVlB,EAWA;AAXA,GAYGwB,IAZH,CAYQxB,IAAI,IAAIa,kBAAkB,CAACb,IAAD,EAAOK,KAAP,EAAcO,aAAd,CAZlC,EAaGgB,KAbH,CAaS,MAAMhB,aAAa,CAAC;AAACE,IAAAA,IAAI,EAAC;AAAN,GAAD,CAb5B;AAcD,CAnBD;;AAqBA,MAAMe,MAAM,GAAIC,IAAD,IAAU;AACvB;;AAEA,MAAIC,KAAK,GAAG,EAAZ;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAC,CAAF,IAAOF,IAAI,CAACG,MAAL,GAAc,CAApC,EAAuCD,CAAC,EAAxC,EACED,KAAK,CAACG,IAAN,CAAW;AAAC,aAASJ,IAAI,CAACE,CAAD,CAAd;AAAmB,YAAOF,IAAI,CAACE,CAAC,GAAC,CAAH;AAA9B,GAAX;;AACD,SAAOD,KAAP;AACF,CAPD;;AAUA,MAAMI,aAAa,GAAG,OAAOC,KAAP,EAAcxB,aAAd,KAAgC;AACpD;;;AAGA,MAAIyB,UAAU,GAAG,IAAIC,KAAJ,CAAUF,KAAK,CAACG,MAAhB,CAAjB,CAJoD,CAKpD;AACA;;AACA,QAAMC,OAAO,CAACC,GAAR,CAAaL,KAAK,CAACM,GAAN,CAAW,CAACpB,IAAD,EAAOqB,KAAP,KAC5B;AACA;AACApB,EAAAA,KAAK,CAAC1B,YAAY,GAAC,QAAb,GAAuByB,IAAvB,GAA6B,GAA9B,CAAL,CACCE,IADD,CACOoB,QAAQ,IAAIA,QAAQ,CAAClB,IAAT,EADnB,EAECF,IAFD,CAEOoB,QAAQ,IAAI;AACjB,QAAGA,QAAQ,CAACC,MAAT,KAAoB,QAAvB,EAAgC;AAC9BR,MAAAA,UAAU,CAACM,KAAD,CAAV,GAAoBrB,IAApB;AACD,KAFD,MAEK;AACHV,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAC,oBADO;AAEZC,QAAAA,OAAO,EAAEO;AAFG,OAAD,CAAb;AAGD;AACF,GAVD,EAWCM,KAXD,CAWOkB,GAAG,IAAIC,OAAO,CAACC,GAAR,CAAYF,GAAZ,CAXd,CAHiB,CAAb,CAAN;AAgBA,SAAOT,UAAU,CAAC9B,MAAX,CAAmB0C,OAAnB,CAAP;AACD,CAxBD;;AA0BA,MAAMC,WAAW,GAAIC,IAAD,IAAS;AAC3B;AACA,MAAIC,QAAQ,GAAG,IAAf;;AACA,MAAGD,IAAI,YAAYb,KAAnB,EAAyB;AACvBa,IAAAA,IAAI,CAACE,OAAL,CAAcrD,IAAD,IAAU;AACrBA,MAAAA,IAAI,GAAGD,WAAW,CAACC,IAAD,CAAlB;AACAA,MAAAA,IAAI,CAAC,UAAD,CAAJ,GAAmBoD,QAAnB;AACAA,MAAAA,QAAQ,GAAGpD,IAAI,CAACQ,EAAhB;AACD,KAJD;AAKD;;AACD,SAAO2C,IAAP;AACD,CAXD;;AAaA,MAAMG,eAAe,GAAG,OAAOC,YAAP,EAAqB3C,aAArB,KAAuC;AAC7D;;AAEA,MAAI4C,KAAK,GAAG,IAAIlB,KAAJ,CAAUiB,YAAY,CAACtB,MAAvB,CAAZ;AACA,QAAMO,OAAO,CAACC,GAAR,CACJc,YAAY,CAACb,GAAb,CAAiB,CAACe,OAAD,EAAUd,KAAV,KACfpB,KAAK,CAAC1B,YAAY,GAAC,OAAb,GAAqB4D,OAAO,CAACC,KAA7B,GAAmC,GAAnC,GAAuCD,OAAO,CAACE,IAAhD,CAAL,CACCnC,IADD,CACOoB,QAAQ,IAAIA,QAAQ,CAAClB,IAAT,EADnB,EAECF,IAFD,CAEOoB,QAAQ,IAAIM,WAAW,CAACN,QAAD,CAF9B,EAGCpB,IAHD,CAGOoB,QAAQ,IAAI;AACjB,QAAGA,QAAQ,CAACC,MAAT,KAAoB,iBAAvB,EAAyC;AACvCjC,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAC,oBADO;AAEZC,QAAAA,OAAO,EAAE0C;AAFG,OAAD,CAAb;AAGAD,MAAAA,KAAK,CAACb,KAAD,CAAL,GAAe,IAAf;AACD,KALD,MAKK;AACHa,MAAAA,KAAK,CAACb,KAAD,CAAL,GAAeC,QAAf;AACD;AACF,GAZD,EAaChB,KAbD,CAaOkB,GAAG,IAAIC,OAAO,CAACC,GAAR,CAAYF,GAAZ,CAbd,CADF,CADI,CAAN;AAiBA,SAAOU,KAAP;AACD,CAtBD;;AAwBA,MAAMI,SAAS,GAAG,MAAOJ,KAAP,IAAiB;AACjC,QAAMK,OAAO,GAAIL,KAAD,IAAW;AACzB,QAAIM,IAAI,GAAG,EAAX;AACA,QAAIC,GAAG,GAAG;AAACC,MAAAA,KAAK,EAAC,IAAP;AAAaC,MAAAA,GAAG,EAAC;AAAjB,KAAV;AACA,QAAIC,OAAO,GAAG,KAAd;AACA,QAAIC,MAAM,GAAG,KAAb;AACAX,IAAAA,KAAK,CAACH,OAAN,CAAc,CAACF,IAAD,EAAOR,KAAP,KAAiB;AAC7B,UAAGQ,IAAI,KAAK,IAAZ,EAAkB;AAAC;AACjB,YAAGe,OAAH,EAAW;AAAG;AACZH,UAAAA,GAAG,CAACC,KAAJ,GAAYrB,KAAZ,CADS,CACS;AACnB,SAHe,CAIhB;;;AACAwB,QAAAA,MAAM,GAAG,IAAT,CALgB,CAKD;;AACfD,QAAAA,OAAO,GAAG,KAAV;AACD,OAPD,MAOK;AAAE;AACL,YAAGC,MAAH,EAAU;AAAI;AACZJ,UAAAA,GAAG,CAACE,GAAJ,GAAUtB,KAAV,CADQ,CACS;;AACjBmB,UAAAA,IAAI,CAAC5B,IAAL,CAAU,EAAC,GAAG6B;AAAJ,WAAV,EAFQ,CAEa;AACtB;;AACDG,QAAAA,OAAO,GAAG,IAAV,CALG,CAKa;;AAChBC,QAAAA,MAAM,GAAG,KAAT;AACD;AACF,KAhBD;AAiBA,WAAOL,IAAP;AACD,GAvBD;;AAyBA,QAAMM,SAAS,GAAG,OAAOJ,KAAP,EAAcC,GAAd,EAAmBT,KAAnB,KAA6B;AAC9C;;;AAGC,QAAIa,KAAK,GAAGb,KAAK,CAACQ,KAAK,GAAC,CAAP,CAAjB;AACA,QAAIM,KAAK,GAAGd,KAAK,CAACS,GAAD,CAAjB;AACA,QAAIM,QAAQ,GAAGF,KAAK,CAACA,KAAK,CAACpC,MAAN,GAAa,CAAd,CAAL,CAAsBX,IAArC;AACA,QAAIkD,WAAW,GAAG,KAAlB;AACA,QAAI7B,KAAK,GAAIsB,GAAG,GAACD,KAAJ,GAAW,CAAZ,GAAe,CAAf,GAAiB,CAA7B;;AACA,WAAM,CAACQ,WAAD,IAAgB7B,KAAK,GAAG2B,KAAK,CAACrC,MAAN,GAAa,CAA3C,EAA6C;AAC3C;AACA,YAAMV,KAAK,CAAC1B,YAAY,GAAC,OAAb,GAAqB0E,QAArB,GAA8B,GAA9B,GAAkCD,KAAK,CAAC3B,KAAD,CAAL,CAAarB,IAAhD,CAAL,CACLE,IADK,CACCoB,QAAQ,IAAIA,QAAQ,CAAClB,IAAT,EADb,EAELF,IAFK,CAECoB,QAAQ,IAAIM,WAAW,CAACN,QAAD,CAFxB,EAGLpB,IAHK,CAGCoB,QAAQ,IAAI;AACjB,YAAGA,QAAQ,CAACC,MAAT,KAAoB,iBAAvB,EAAyC;AACvCF,UAAAA,KAAK;AACN,SAFD,MAEK;AACH6B,UAAAA,WAAW,GAAG,IAAd,CADG,CACiB;;AACpBhB,UAAAA,KAAK,CAACQ,KAAD,CAAL,GAAepB,QAAf,CAFG,CAEsB;AAC1B;AACF,OAVK,EAWLhB,KAXK,CAWCkB,GAAG,IAAIC,OAAO,CAACC,GAAR,CAAYF,GAAZ,CAXR,CAAN;AAYD;AACF,GAxBD;;AAyBA,MAAIgB,IAAI,GAAGD,OAAO,CAACL,KAAD,CAAlB;AACA,QAAMhB,OAAO,CAACC,GAAR,CAAYqB,IAAI,CAACpB,GAAL,CAAUqB,GAAG,IAAIK,SAAS,CAACL,GAAG,CAACC,KAAL,EAAYD,GAAG,CAACE,GAAhB,EAAqBT,KAArB,CAA1B,CAAZ,CAAN;AACA,SAAOA,KAAP;AACD,CAtDD;;AAyDA,MAAMiB,YAAY,GAAG,CAACjB,KAAD,EAAQnD,KAAR,EAAeO,aAAf,KAAiC;AACpD;AACA,MAAI8D,SAAS,GAAG,EAAhB;AACAlB,EAAAA,KAAK,GAAGA,KAAK,CAACjD,MAAN,CAAc0C,OAAd,CAAR;AACAO,EAAAA,KAAK,CAACH,OAAN,CAAcF,IAAI,IAAIuB,SAAS,CAACxC,IAAV,CAAe,GAAGiB,IAAlB,CAAtB,EAJoD,CAIL;;AAC/CJ,EAAAA,OAAO,CAACC,GAAR,CAAY0B,SAAZ;AACAA,EAAAA,SAAS,CAACrB,OAAV,CAAkB,CAACrD,IAAD,EAAO2C,KAAP,KAChB3B,cAAc,CAAC,MAAM;AACnB+B,IAAAA,OAAO,CAACC,GAAR,CAAY3C,KAAK,CAACsE,OAAlB;;AACA,QAAGhC,KAAK,KAAK,CAAb,EAAe;AACb;AACA/B,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAE,cADM;AAEZC,QAAAA,OAAO,EAAEf;AAFG,OAAD,CAAb;AAID,KAND,MAMK;AACH+C,MAAAA,OAAO,CAACC,GAAR,CAAYhD,IAAI,CAACoD,QAAjB;AACAL,MAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAYhD,IAAI,CAACQ,EAAjB;AACAuC,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ,EAJG,CAKH;;AACA,UAAI4B,GAAG,GAAG;AACR9D,QAAAA,IAAI,EAAE,eADE;AAERC,QAAAA,OAAO,EAAE;AACPf,UAAAA,IAAI,EAAEA,IADC;AAEP6E,UAAAA,IAAI,EAAE;AACJC,YAAAA,MAAM,EAAE9E,IAAI,CAACQ,EADT;AAEJuE,YAAAA,MAAM,EAAE/E,IAAI,CAACoD;AAFT;AAFC;AAFD,OAAV;AAUA,UAAGpD,IAAI,CAACoD,QAAR,EAAkBwB,GAAG,CAAC7D,OAAJ,CAAY8D,IAAZ,CAAiB,QAAjB,IAA6B7E,IAAI,CAACoD,QAAlC;AAClBxC,MAAAA,aAAa,CAACgE,GAAD,CAAb;AACD;AACF,GA3Ba,EA2BX,EA3BW,EA2BR,CA3BQ,CADhB,EANoD,CAmClD;AACH,CApCD;;AAuCA,MAAMI,SAAS,GAAG,OAAO5C,KAAP,EAAc/B,KAAd,EAAqBO,aAArB,KAAuC;AACvD;;;AAGA;AACAwB,EAAAA,KAAK,GAAG,MAAMD,aAAa,CAACC,KAAD,EAAQxB,aAAR,CAAb,CACXgB,KADW,CACLkB,GAAG,IAAI;AAAElC,IAAAA,aAAa,CAAC;AAC5BE,MAAAA,IAAI,EAAC,WADuB;AAE5BC,MAAAA,OAAO,EAAC;AAFoB,KAAD,CAAb;AAGf,GAJW,CAAd;AAKA,MAAIwC,YAAY,GAAG1B,MAAM,CAACO,KAAD,CAAzB;AACA,MAAI6C,SAAS,GAAG,MAAM3B,eAAe,CAACC,YAAD,EAAe3C,aAAf,CAAf,CACnBgB,KADmB,CACbkB,GAAG,IAAI;AAAClC,IAAAA,aAAa,CAAC;AAC3BE,MAAAA,IAAI,EAAC,WADsB;AAE3BC,MAAAA,OAAO,EAAE;AAFkB,KAAD,CAAb;AAGb,GAJkB,CAAtB;AAKAgC,EAAAA,OAAO,CAACC,GAAR,CAAYiC,SAAZ;AACA,MAAIC,UAAU,GAAG,MAAMtB,SAAS,CAACqB,SAAD,CAAT,CACpBrD,KADoB,CACdkB,GAAG,IAAI;AAAClC,IAAAA,aAAa,CAAC;AAC3BE,MAAAA,IAAI,EAAC,WADsB;AAE3BC,MAAAA,OAAO,EAAE;AAFkB,KAAD,CAAb;AAGb,GAJmB,CAAvB;AAKA0D,EAAAA,YAAY,CAACS,UAAD,EAAa7E,KAAb,EAAoBO,aAApB,CAAZ,CAtBuD,CAyBvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDD,CAzFD;;AA4FA,MAAMC,kBAAkB,GAAG,CAACb,IAAD,EAAOK,KAAP,EAAcO,aAAd,KAAgC;AACzD;AACA,MAAIuE,OAAO,GAAG9E,KAAK,CAAC+E,WAApB,CAFyD,CAGzD;;AACA,MAAIC,UAAU,GAAG,WAAjB,CAJyD,CAKzD;;AACA9D,EAAAA,KAAK,CAAC1B,YAAY,GAAGwF,UAAf,GAA4BrF,IAAI,CAACQ,EAAlC,CAAL,CACA;AADA,GAEGgB,IAFH,CAEQC,MAAM,IAAIA,MAAM,CAACC,IAAP,EAFlB,EAGGF,IAHH,CAGQC,MAAM,IAAIE,UAAU,CAACF,MAAD,EAASpB,KAAT,EAAgBO,aAAhB,CAH5B,EAIGY,IAJH,CAIQ8D,QAAQ,IAAIA,QAAQ,CAACjC,OAAT,EAChB;AACAkC,EAAAA,OAAO,IAAIvE,cAAc,CAAC,MAAM;AAC9B;AACAuE,IAAAA,OAAO,GAAGxF,WAAW,CAACwF,OAAD,CAArB,CAF8B,CAEE;;AAChC,QAAGJ,OAAO,IAAI1E,SAAS,CAAC8E,OAAO,CAAC/E,EAAT,EAAaH,KAAb,CAAvB,EAA2C;AACzC;AACAO,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAE,eADM;AAEZC,QAAAA,OAAO,EAAE;AACPf,UAAAA,IAAI,EAAEuF,OADC;AAEPV,UAAAA,IAAI,EAAE;AACJE,YAAAA,MAAM,EAAE/E,IAAI,CAACQ,EADT;AAEJsE,YAAAA,MAAM,EAAES,OAAO,CAAC/E;AAFZ;AAFC;AAFG,OAAD,CAAb;AAWD;AACF,GAjBwB,CAFT,CAJpB,EA0BGoB,KA1BH,CA0BS,MAAMhB,aAAa,CAAC;AAACE,IAAAA,IAAI,EAAC;AAAN,GAAD,CA1B5B;AA2BD,CAjCD;;AAmCA,MAAMa,UAAU,GAAG,CAACiB,QAAD,EAAWvC,KAAX,EAAkBO,aAAlB,KAAmC;AACpD;AACA;AACA;AACA,MAAGgC,QAAQ,YAAYN,KAAvB,EAA6B;AAC3B,QAAID,UAAU,GAAG,EAAjB,CAD2B,CAE3B;AACA;;AACAO,IAAAA,QAAQ,CAACS,OAAT,CAAiB,CAAC/B,IAAD,EAAOqB,KAAP,EAAcP,KAAd,KAAwB;AACvC,UAAGd,IAAI,CAACuB,MAAL,KAAgB,YAAnB,EAAgC;AAC9BjC,QAAAA,aAAa,CAAC;AACZE,UAAAA,IAAI,EAAE,oBADM;AAEZC,UAAAA,OAAO,EAAEO,IAAI,CAACrB;AAFF,SAAD,CAAb;AAGD,OAJD,MAIK;AACHoC,QAAAA,UAAU,CAACH,IAAX,CAAgBZ,IAAhB;AACD;AACF,KARD;AASA,WAAOe,UAAP;AACD,GAdD,MAcK;AAAE;AACL,QAAGO,QAAQ,CAACC,MAAT,KAAoB,YAAvB,EAAqC;AACnCjC,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAE,oBADM;AAEZC,QAAAA,OAAO,EAAEV,KAAK,CAACmF;AAFH,OAAD,CAAb;AAGA,YAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACD,KALD,MAKM,IAAG7C,QAAQ,CAACC,MAAT,KAAoB,iBAAvB,EAAyC;AAC7C;AACA;AACAjC,MAAAA,aAAa,CAAC;AACZE,QAAAA,IAAI,EAAE,oBADM;AAEZC,QAAAA,OAAO,EAAE;AACP,mBAAS6B,QAAQ,CAACc,KADX;AAEP,kBAAQd,QAAQ,CAACe;AAFV;AAFG,OAAD,CAAb;AAOA,YAAM,IAAI8B,KAAJ,CAAU,gBAAV,CAAN;AACD,KAXK,MAWD;AACH,aAAO7C,QAAP;AACD;AACF;AACF,CAvCD;;AAyCA,MAAM8C,eAAe,GAAG,UAAStF,MAAT,EAAiBQ,aAAjB,EAAgC;AACtDA,EAAAA,aAAa,CAAC;AAACE,IAAAA,IAAI,EAAC,kBAAN;AAA0BC,IAAAA,OAAO,EAAEX;AAAnC,GAAD,CAAb,CADsD,CAEtD;AACD,CAHD;;AAKA,SAASL,WAAT,EAAsB4B,UAAtB,EAAkCN,YAAlC,EAAgDR,kBAAhD,EAAoEmE,SAApE,EAA+ErE,WAA/E,EAA4F+E,eAA5F","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\nimport { getRandomInt }  from \"./Components/RandomGenerator\";\n\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n// retrive node with given node id from state \nconst getNode = (nodeId, state) => state.nodes.filter( node => node.id === nodeId )[0]\n\n// attemps to return true id node is not in state, \n// maybe make a dic so that is it not n time\nconst isNewNode = (nodeId, state) => state.nodes.every( node => node.id !== nodeId )\n\nconst onClickNode = (nodeId, state, dispatchState) => {\n\t\t// when user clicks on a node\n\t\tqueryAdjecentNodes(getNode(nodeId, state), state, dispatchState)\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})  \n};\n\nconst timelyDispatch = (dispatchFunc , waitTime=0, random=10) => {\n\t/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/\n\t\tsetTimeout(dispatchFunc, waitTime + getRandomInt(random));\n}\n\nconst queryNewWord = (word, state, dispatchState) => {\n\t\t/* reset the graph state and start a new query into a word, \n\t\t * sometime this stymes when it is called a second time,\n\t\t * this might be because of dispatchState being called twice\n\t\t * must investigate.  */\n\t\tfetch(API_ENDPOINT + word)\n\t\t// unpack json\n\t\t\t\t.then(result => result.json()) //unpack word\n\t\t\t\t.then(result => catchError(result, state, dispatchState))//check if word was found\n\t\t\t\t.then(result => processNode(result)) //process node\n\t\t\t\t.then(node => { //dispatch word\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\tpayload: node\n\t\t\t\t\t\t}); \n\t\t\t\t\t\treturn node; })\n\t\t// get the surrounding words\n\t\t\t\t.then(node => queryAdjecentNodes(node, state, dispatchState))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n}\n\nconst pairUp = (list) => {\n\t\t/* takes a list of inputs and \n\t\t * divied it into pairs */\n\t\tlet pairs = []\n\t\tfor(let i = 0; i+1 <= list.length - 1; i++)\n\t\t\t\tpairs.push({'first': list[i], 'last':list[i+1]})\n\t\t\treturn pairs\n}\n\n\nconst getFoundWords = async (words, dispatchState) => {\n\t\t/* gets a list of word and removes the\n\t\t * this seemly simplet task is hard to do with promises\n\t\t * one whihc are not in api*/\n\t\tvar foundWords = new Array(words.lenght)\n\t\t// make a empty array of as long as\n\t\t// the origial to mantain the same order\n\t\tawait Promise.all( words.map( (word, index) => \n\t\t\t\t// for every word check the api, \n\t\t\t\t// await untill all promises are returned\n\t\t\t\tfetch(API_ENDPOINT+'check/'+ word +\"/\")\n\t\t\t\t.then( response => response.json())\n\t\t\t\t.then( response => { \n\t\t\t\t\t\tif(response.detail === \"Found.\"){ \n\t\t\t\t\t\t\t\tfoundWords[index] = word \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype:'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word})\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(err => console.log(err))\n\t\t))\n\t\treturn foundWords.filter( Boolean )\n}\n\nconst processPath = (path) =>{\n\t\t/* add for each node in the path where it comming from */\n\t\tlet prevNode = null;\n\t\tif(path instanceof Array){  \n\t\t\t\tpath.forEach((node) => {\n\t\t\t\t\t\tnode = processNode(node);\n\t\t\t\t\t\tnode['prevNode'] = prevNode;\n\t\t\t\t\t\tprevNode = node.id;\n\t\t\t\t})\n\t\t}\n\t\treturn path\n}\n\nconst fetchPathsParts = async (pathRequests, dispatchState) => {\n\t\t/* gets a list of pair request for paths an queryes the api \n\t\t * then is saves those paths in a order list and returns*/\n\t\tvar paths = new Array(pathRequests.length)\n\t\tawait Promise.all( \n\t\t\t\tpathRequests.map((request, index) =>\n\t\t\t\t\t\tfetch(API_ENDPOINT+'path/'+request.first+\"/\"+request.last)\n\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t.then( response => processPath(response))\n\t\t\t\t\t\t.then( response => { \n\t\t\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype:'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: request});\n\t\t\t\t\t\t\t\t\t\tpaths[index] = null;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tpaths[index] = response;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t))\n\t\treturn paths;\n}\n\nconst amendPath = async (paths) => {\n\t\tconst getGaps = (paths) => {\n\t\t\t\tlet gaps = [];\n\t\t\t\tlet gap = {start:null, end:null}\n\t\t\t\tlet wasPath = false;\n\t\t\t\tlet wasGap = false;\n\t\t\t\tpaths.forEach((path, index) => {\n\t\t\t\t\t\tif(path === null ){// if it is gap\n\t\t\t\t\t\t\t\tif(wasPath){  // comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.start = index //save start\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// and comes from path\n\t\t\t\t\t\t\t\twasGap = true; // switch to gap\n\t\t\t\t\t\t\t\twasPath = false \n\t\t\t\t\t\t}else{ //if is path\n\t\t\t\t\t\t\t\tif(wasGap){   // and comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.end = index; // record end\n\t\t\t\t\t\t\t\t\t\tgaps.push({...gap}); //save gap\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\twasPath = true; // switch to path \n\t\t\t\t\t\t\t\twasGap = false;\n\t\t\t\t\t\t}\n\t\t\t\t}) \n\t\t\t\treturn gaps;\n\t\t}\n\n\t\tconst bridgeGap = async (start, end, paths) => {\n\t\t\t/* gets a set of indexes indicating the gap, \n\t\t\t * make fetch request to attempt to find a \n\t\t\t * conncetion */\n\t\t\t\tlet pathL = paths[start-1];\n\t\t\t\tlet pathR = paths[end]\n\t\t\t\tlet lastWord = pathL[pathL.length-1].word;\n\t\t\t\tlet bridgeFound = false;\n\t\t\t\tlet index = (end-start >1)?0:1;\n\t\t\t\twhile(!bridgeFound && index < pathR.length-1){ \n\t\t\t\t\t\t//need to user while loop there is one fetch at the time \n\t\t\t\t\t\tawait fetch(API_ENDPOINT+'path/'+lastWord+\"/\"+pathR[index].word)\n\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t.then( response => processPath(response))\n\t\t\t\t\t\t.then( response => { \n\t\t\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tbridgeFound = true; //break loop\n\t\t\t\t\t\t\t\t\t\tpaths[start] = response; //set the bridge\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t}\n\t\t}\n\t\tlet gaps = getGaps(paths);\n\t\tawait Promise.all(gaps.map( gap => bridgeGap(gap.start, gap.end, paths)))\n\t\treturn paths\n}\n\n\nconst dispatchPath = (paths, state, dispatchState) => {\n\t\t// paths all list together\n\t\tlet finalPath = [];\n\t\tpaths = paths.filter( Boolean );\n\t\tpaths.forEach(path => finalPath.push(...path)) // add all paths together\n\t\tconsole.log(finalPath)\n\t\tfinalPath.forEach((node, index) => \n\t\t\t\ttimelyDispatch(() => {  \n\t\t\t\t\t\tconsole.log(state.isEmpty)\n\t\t\t\t\t\tif(index === 0){ \n\t\t\t\t\t\t\t\t// if this is the first node\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: node,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tconsole.log(node.prevNode)\n\t\t\t\t\t\t\t\tconsole.log(\" --> \")\n\t\t\t\t\t\t\t\tconsole.log(node.id)\n\t\t\t\t\t\t\t\tconsole.log(\"\\n\")\n\t\t\t\t\t\t\t\t//if there is already other nodes\n\t\t\t\t\t\t\t\tlet msg = {\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.prevNode, \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(node.prevNode) msg.payload.link['source'] = node.prevNode\n\t\t\t\t\t\t\t\tdispatchState(msg)\n\t\t\t\t\t\t}\n\t\t\t\t}, 25,0)\n\t\t) //se the time as 25 and the random to 0\n}\n\n\nconst queryPath = async (words, state, dispatchState) => {\n\t\t/* gets passesed a set of two words, \n\t\t * queries the server for the path and \n\t\t * dispateches the result to state */\n\t\t//split words into arrays\n\t\twords = await getFoundWords(words, dispatchState)\n\t\t\t\t.catch(err => { dispatchState({\n\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\tpayload:\"Could not get words\"})\n\t\t\t\t});\n\t\tlet pathRequests = pairUp(words)\n\t\tlet pathParts = await fetchPathsParts(pathRequests, dispatchState)\n\t\t\t\t.catch(err => {dispatchState({\n\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\tpayload: \"could not get paths\"} \n\t\t\t\t)})\n\t\tconsole.log(pathParts);\n\t\tlet finalPaths = await amendPath(pathParts)\n\t\t\t\t.catch(err => {dispatchState({\n\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\tpayload: \"Could not amend path\"} \n\t\t\t\t)})\n\t\tdispatchPath(finalPaths, state, dispatchState);\n\t\t\n\t\t\n\t\t//let first = words[i];\n\t\t//let second = words[i+1];\n\t\t//console.log(first)\n\t\t//console.log(second)\n\t\t//let request = fetch(API_ENDPOINT+'path/'+ first +\"/\"+second)\n\t\t//let result = request.json(); // unpack json\n\t\t//if(result.detail === \"Path not found.\"){\n\t\t//console.log(\"path not found\")\n\t\t//}\n\n\t\t/*\n\t\t *\n\t\t\t\t\t\t\t\tconsole.log(\"this ran\")\n\t\t\t\t\t\tlet prevNode = null;\n\t\t\t\t\t\tlet first;\n\t\t\t\t\t\tlet second;\n\n\t\tfor( var i = 0; i+1 <= words.length-1; i++){\n\t\t\t\tfirst = words[i];\n\t\t\t\tsecond = words[i + 1];\n\t\t\t\t//console.log(words)\n\t\t\t\t//console.log(i)\n\t\t\t\tconsole.log(first);\n\t\t\t\tconsole.log(second);\n\t\t\t\tfetch(API_ENDPOINT + 'path/' +  first  + \"/\" + second) \n\t\t\t\t\t\t.then(result => result.json()) // unpack json\n\t\t\t\t\t\t.then(nodes => {console.log(nodes); return nodes })\n\t\t\t\t\t\t.then(nodes => catchError(nodes, state, dispatchState)) \n\t\t\t\t\t\t\t//check if words not found\n\t\t\t\t\t\t.then(pathNodes => {\n\t\t\t\t\t\t\t\t//console.log(pathNodes)\n\t\t\t\t\t\t\t\tpathNodes.forEach((node, index) => \n\t\t\t\t\t\t\t\t\t\ttimelyDispatch(() => {  \n\t\t\t\t\t\t\t\t\t\t\t\tnode = processNode(node);\n\t\t\t\t\t\t\t\t\t\t\t\tif (prevNode === null){ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if this is the first node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(prevNode.id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(\" --> \")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(node.id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(\"\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//if there is already other nodes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: prevNode.id, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tprevNode = node;\n\t\t\t\t\t\t\t\t\t\t}, 25,0)\n\t\t\t\t\t\t\t\t) //se the time as 25 and the random to 0\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n\t\t}\n\t\t*/\n}\n\n\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n\t\t/* for every node request the adjecent node to it */\n\t\tlet linkAll = state.isDeepLinks;\n\t\t// define whether we should link te deeper\n\t\tlet graph_type = 'synonyms/';\n\t\t// define which type of graph we are requesting\n\t\tfetch(API_ENDPOINT + graph_type + node.id )\n\t\t// request the synonyms\n\t\t\t\t.then(result => result.json())\n\t\t\t\t.then(result => catchError(result, state, dispatchState))\n\t\t\t\t.then(adjNodes => adjNodes.forEach( \n\t\t\t\t\t\t// for every node in the array\n\t\t\t\t\t\tadjNode => timelyDispatch(() => {  \n\t\t\t\t\t\t\t\t//for each of the nodes in the list \t\t\n\t\t\t\t\t\t\t\tadjNode = processNode(adjNode); //process node \n\t\t\t\t\t\t\t\tif(linkAll || isNewNode(adjNode.id, state)){\n\t\t\t\t\t\t\t\t\t\t// proces is it is new node, or deep link set\n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t\n\t\t\t\t))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\nconst catchError = (response, state, dispatchState) =>{\n\t\t/* Set error to state when user search a word not found */\n\t\t//console.log(\"got to cath error:\")\n\t\t//console.log(response)\n\t\tif(response instanceof Array){\n\t\t\t\tlet foundWords = []\n\t\t\t\t//console.log(\"words was not found\")\n\t\t\t\t// if it has the response for many words\n\t\t\t\tresponse.forEach((word, index, words) => {\n\t\t\t\t\t\tif(word.detail === \"Not Found.\"){\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word.w_id});\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfoundWords.push(word);\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn foundWords;\n\t\t}else{ // if it only one elment\n\t\t\t\tif(response.detail === \"Not found.\") {\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: state.searchTerm});\n\t\t\t\t\t\tthrow new Error(\"word not found\");\n\t\t\t\t}else if(response.detail === \"Path not found.\"){\n\t\t\t\t\t\t// if the error is path not found\n\t\t\t\t\t\t//console.log(\"path was not found\")\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t'first': response.first,\n\t\t\t\t\t\t\t\t\t\t'last': response.last,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthrow new Error(\"path not found\");\n\t\t\t\t}else{\n\t\t\t\t\t\treturn response\n\t\t\t\t}\n\t\t}\n}\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
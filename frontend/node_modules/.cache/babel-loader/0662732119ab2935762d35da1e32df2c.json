{"ast":null,"code":"var _jsxFileName = \"/home/telix/dictio-grapho/frontend/src/App.js\";\nimport React from 'react';\nimport './App.css';\nimport { Graph } from \"react-d3-graph\";\nimport myConfig from \"./myConfig\";\nconst API_ENDPOINT = 'http://127.0.0.1:8000/api/v1/';\n/* graph payload (with minimalist structure)\nconst state_guide = {\n\t\tnodes: [{ id: \"zine\", }, { id: \"cool\" }, { id: \"world\" }],\n\t\tlinks: [\n\t\t\t\t{ source: \"zine\", target: \"cool\"  },\n\t\t\t\t{ source: \"zine\", target: \"world\" },\n\t\t],\n\t\tisError: false,\n\t\tisLoading: true,\n\t\tsearchTerm: '',\n\t\tDestinationTerm: '',\n};\n*/\n// graph payload (with minimalist structure)\n\nconst initial_state = {\n  nodes: [{\n    id: \"zine\",\n    synonyms: [{\n      synonym: 'anxious'\n    }]\n  }, {\n    id: \"cool\",\n    synonyms: [{\n      synonym: 'anxious'\n    }]\n  }, {\n    id: \"world\",\n    synonyms: []\n  }],\n  links: [{\n    source: \"zine\",\n    target: \"cool\"\n  }, {\n    source: \"zine\",\n    target: \"world\"\n  }],\n  isError: false,\n  isLoading: true,\n  searchTerm: '',\n  DestinationTerm: ''\n};\n\nfunction App() {\n  // make reducer for the words data and internal state \n  const stateReducer = (state, action) => {\n    switch (action.type) {\n      case 'SET_NEW_NODES':\n        return { ...state,\n          nodes: [...state.nodes, ...action.payload]\n        };\n\n      case 'SET_NEW_LINKS':\n        return { ...state,\n          links: [...state.links, ...action.payload]\n        };\n\n      case 'SET_SEARCH_NODE':\n        return { ...state,\n          nodes: [action.payload],\n          links: []\n        };\n\n      case 'ERASE_NODES':\n        return { ...state,\n          nodes: [],\n          links: []\n        };\n\n      case 'SET_SEARCH_TERM':\n        return { ...state,\n          searchTerm: action.payload\n        };\n\n      case 'SET_DEST_TERM':\n        return { ...state,\n          destinationTerm: action.payload\n        };\n\n      case 'SET_FETCH_FAILED':\n        return { ...state,\n          isError: true\n        };\n\n      default:\n        throw new Error();\n    }\n  };\n\n  const [state, dispatchState] = React.useReducer(stateReducer, initial_state);\n  /* define dispatcher for the Internal data */\n\n  const processNode = node => {\n    /* process a node from the api into one for the dispatcher\n     * it changes title for id, for instance */\n    node['id'] = node.title;\n    return node;\n  };\n\n  const createShallowLinks = node => node.synonyms.map(synonym => ({\n    source: synonym['synonym'],\n    target: node.id\n  }));\n\n  const createDeepLinks = newNode => {\n    /* This is pornography, but it basically check if a new word is a synonym of one already \n    \tor if the new word has synonyms one of the words already in state */\n    let newLinks = []; // look if state nodes are synonym of new word\n\n    state.nodes.forEach(node => node.synonyms.forEach(synonym => synonym[\"synonym\"] === newNode.id && newLinks.push({\n      source: node.id,\n      target: newNode.id\n    }))); // look if new word has a synonym to to state word\n\n    newNode.synonyms.forEach(synonym => state.nodes.forEach(node => node.id === synonym[\"synonym\"] && newLinks.push({\n      source: node.id,\n      target: newNode.id\n    })));\n    return newLinks;\n  };\n\n  const loadNodesCallBack = (nodes, withLinks = true) => {\n    /* append array of nodes with a waiting time in between them so that they flow\n     * also create new links and append them to state */\n    let links;\n    if (!(nodes instanceof Array)) nodes = [nodes]; // if a single node was passed\n\n    nodes.forEach(node => {\n      // if passed is an array\n      node = processNode(node);\n      withLinks ? links = createDeepLinks(node) : links = false;\n      dispatchState({\n        type: 'SET_NEW_NODES',\n        payload: [node]\n      });\n      links && dispatchState({\n        type: 'SET_NEW_LINKS',\n        payload: links\n      });\n    });\n  };\n\n  const newSearchCallback = node => {\n    /* call back for creating a new node */\n    node = { ...processNode(node)\n    };\n    dispatchState({\n      type: 'SET_SEARCH_NODE',\n      payload: node\n    });\n  };\n\n  const ShallowCallBack = (nodes, withLinks = true) => {\n    /* append array of nodes with a waiting time in between them so that they flow\n     * also create new links and append them to state */\n    let links;\n    if (!(nodes instanceof Array)) nodes = [nodes]; // if a single node was passed\n\n    nodes.forEach(node => {\n      // if passed is an array\n      node = processNode(node);\n      withLinks ? links = createDeepLinks(node) : links = false;\n      dispatchState({\n        type: 'SET_NEW_NODES',\n        payload: [node]\n      });\n      links && dispatchState({\n        type: 'SET_NEW_LINKS',\n        payload: links\n      });\n    });\n  };\n\n  const getNode = nodeId => state.nodes.filter(node => node.id === nodeId)[0];\n  /* get node with given node id from state */\n\n\n  const requestNode = (word, callback = result => loadNodesCallBack(result, true)) => {\n    /* request a single node to the api and dispatch to state */\n    fetch(API_ENDPOINT + word).then(result => result.json()).then(result => processNode(result)).then(result => callback(result)).catch(() => dispatchState({\n      type: 'SET_FETCH_FAILED'\n    }));\n  };\n\n  const requestSurroundingNodes = nodeId => {\n    // can be optimised by having a sorted list and using binary search\n    let node = getNode(nodeId);\n    node.synonyms.forEach(synonym => requestNode(synonym['synonym']));\n  }; // handle the change by seting the state variable to \n\n\n  const handleSearchChange = change => dispatchState({\n    type: 'SET_SEARCH_TERM',\n    payload: change.target.value\n  }); // handle the change by seting the state variable to \n\n\n  const handleDestinationChange = change => dispatchState({\n    type: 'SET_DEST_TERM',\n    payload: change.target.value\n  }); // handle submit search button\n\n\n  const handleSearchSubmit = () => {\n    console.log(state.searchTerm);\n    requestNode(state.searchTerm, newSearchCallback);\n    console.log(\"got here\");\n  }; // get node info\n  // handle path button\n\n\n  const handlePathSubmit = () => {\n    dispatchState({\n      type: 'RESET_NODE'\n    });\n  };\n\n  const onClickNode = function (nodeId) {\n    console.log(`clicked node ${nodeId}`);\n    requestSurroundingNodes(nodeId);\n  };\n\n  const onRightClickNode = function (event, nodeId) {\n    window.alert(`Right clicked node ${nodeId}`);\n  };\n\n  const onClickLink = function (source, target) {\n    window.alert(`Clicked link between ${source} and ${target}`);\n  };\n\n  const onRightClickLink = function (event, source, target) {\n    window.alert(`Right clicked link between ${source} and ${target}`);\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 206,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(InputWithLabel, {\n    id: \"search\",\n    type: \"text\",\n    isFocuse: true,\n    value: state.searchTerm,\n    onInputChange: handleSearchChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 208,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 11\n    }\n  }, \"Search:\")), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    disable: !state.searchTerm,\n    onClick: handleSearchSubmit,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 9\n    }\n  }, \"Search\"), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    onClick: () => requestNode(\"anxious\"),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 9\n    }\n  }, \"Add random Nodes\")), /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 218,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(InputWithLabel, {\n    id: \"destination\",\n    type: \"text\",\n    value: state.destinationTerm,\n    onInputChange: handleDestinationChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 219,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 220,\n      columnNumber: 11\n    }\n  }, \"Destination:\")), /*#__PURE__*/React.createElement(\"button\", {\n    type: \"button\",\n    disable: !state.destinationTerm,\n    onClick: handlePathSubmit,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 9\n    }\n  }, \"Get path\")), /*#__PURE__*/React.createElement(Graph, {\n    id: \"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n    ,\n    data: state,\n    config: myConfig,\n    onClickNode: onClickNode,\n    onRightClickNode: onRightClickNode,\n    onClickLink: onClickLink,\n    onRightClickLink: onRightClickLink,\n    backgroundColor: \"black\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 7\n    }\n  }));\n}\n\nconst InputWithLabel = ({\n  id,\n  type,\n  value,\n  onInputChange,\n  isFocused,\n  children\n}) => {\n  /* A component with the Input and a Label */\n  // Define an input ref for passing to input component\n  const inputRef = React.useRef(); // set up a side effect it is updates if the focus changes\n\n  React.useEffect(() => {\n    if (isFocused && inputRef.current) inputRef.current.focused();\n  }, [isFocused]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"label\", {\n    htmlFor: id,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 5\n    }\n  }, \" \", children, \" \"), \"\\xA0\", /*#__PURE__*/React.createElement(\"input\", {\n    id: id,\n    ref: inputRef,\n    type: type,\n    value: value,\n    onChange: onInputChange,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 249,\n      columnNumber: 5\n    }\n  }));\n};\n\nexport default App;","map":{"version":3,"sources":["/home/telix/dictio-grapho/frontend/src/App.js"],"names":["React","Graph","myConfig","API_ENDPOINT","initial_state","nodes","id","synonyms","synonym","links","source","target","isError","isLoading","searchTerm","DestinationTerm","App","stateReducer","state","action","type","payload","destinationTerm","Error","dispatchState","useReducer","processNode","node","title","createShallowLinks","map","createDeepLinks","newNode","newLinks","forEach","push","loadNodesCallBack","withLinks","Array","newSearchCallback","ShallowCallBack","getNode","nodeId","filter","requestNode","word","callback","result","fetch","then","json","catch","requestSurroundingNodes","handleSearchChange","change","value","handleDestinationChange","handleSearchSubmit","console","log","handlePathSubmit","onClickNode","onRightClickNode","event","window","alert","onClickLink","onRightClickLink","InputWithLabel","onInputChange","isFocused","children","inputRef","useRef","useEffect","current","focused"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,WAAP;AACA,SAASC,KAAT,QAAsB,gBAAtB;AACA,OAAQC,QAAR,MAAuB,YAAvB;AACA,MAAMC,YAAY,GAAG,+BAArB;AAEA;;;;;;;;;;;;;AAcA;;AACA,MAAMC,aAAa,GAAG;AACpBC,EAAAA,KAAK,EAAE,CAAC;AAAEC,IAAAA,EAAE,EAAE,MAAN;AAAcC,IAAAA,QAAQ,EAAC,CAAE;AAACC,MAAAA,OAAO,EAAE;AAAV,KAAF;AAAvB,GAAD,EAAqD;AAAEF,IAAAA,EAAE,EAAE,MAAN;AAAcC,IAAAA,QAAQ,EAAC,CAAE;AAACC,MAAAA,OAAO,EAAE;AAAV,KAAF;AAAvB,GAArD,EAAwG;AAAEF,IAAAA,EAAE,EAAE,OAAN;AAAeC,IAAAA,QAAQ,EAAC;AAAxB,GAAxG,CADa;AAEpBE,EAAAA,KAAK,EAAE,CACL;AAAEC,IAAAA,MAAM,EAAE,MAAV;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GADK,EAEL;AAAED,IAAAA,MAAM,EAAE,MAAV;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAFK,CAFa;AAMpBC,EAAAA,OAAO,EAAE,KANW;AAOpBC,EAAAA,SAAS,EAAE,IAPS;AAQpBC,EAAAA,UAAU,EAAE,EARQ;AASpBC,EAAAA,eAAe,EAAE;AATG,CAAtB;;AAYA,SAASC,GAAT,GAAe;AAGb;AACA,QAAMC,YAAY,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAkB;AACrC,YAAQA,MAAM,CAACC,IAAf;AACE,WAAK,eAAL;AACE,eAAO,EACL,GAAGF,KADE;AAELb,UAAAA,KAAK,EAAE,CAAE,GAAGa,KAAK,CAACb,KAAX,EAAkB,GAAGc,MAAM,CAACE,OAA5B;AAFF,SAAP;;AAIF,WAAK,eAAL;AACE,eAAO,EACL,GAAGH,KADE;AAELT,UAAAA,KAAK,EAAE,CAAE,GAAGS,KAAK,CAACT,KAAX,EAAkB,GAAGU,MAAM,CAACE,OAA5B;AAFF,SAAP;;AAIF,WAAK,iBAAL;AACE,eAAO,EACL,GAAGH,KADE;AAELb,UAAAA,KAAK,EAAE,CAAEc,MAAM,CAACE,OAAT,CAFF;AAGLZ,UAAAA,KAAK,EAAE;AAHF,SAAP;;AAKF,WAAK,aAAL;AACE,eAAO,EACL,GAAGS,KADE;AAELb,UAAAA,KAAK,EAAE,EAFF;AAGLI,UAAAA,KAAK,EAAE;AAHF,SAAP;;AAOF,WAAK,iBAAL;AACE,eAAO,EACL,GAAGS,KADE;AAELJ,UAAAA,UAAU,EAAEK,MAAM,CAACE;AAFd,SAAP;;AAKF,WAAK,eAAL;AACE,eAAO,EACL,GAAGH,KADE;AAELI,UAAAA,eAAe,EAAEH,MAAM,CAACE;AAFnB,SAAP;;AAIF,WAAK,kBAAL;AACE,eAAO,EACL,GAAGH,KADE;AAELN,UAAAA,OAAO,EAAE;AAFJ,SAAP;;AAIF;AACE,cAAM,IAAIW,KAAJ,EAAN;AA1CJ;AA4CD,GA7CD;;AA+CA,QAAM,CAACL,KAAD,EAAQM,aAAR,IAAyBxB,KAAK,CAACyB,UAAN,CAAkBR,YAAlB,EAAgCb,aAAhC,CAA/B;AACA;;AAEA,QAAMsB,WAAW,GAAIC,IAAD,IAAS;AAC3B;;AAEAA,IAAAA,IAAI,CAAC,IAAD,CAAJ,GAAaA,IAAI,CAACC,KAAlB;AACA,WAAOD,IAAP;AACD,GALD;;AAOA,QAAME,kBAAkB,GAAIF,IAAD,IACzBA,IAAI,CAACpB,QAAL,CAAcuB,GAAd,CAAmBtB,OAAO,KAAK;AAAEE,IAAAA,MAAM,EAAEF,OAAO,CAAC,SAAD,CAAjB;AAA8BG,IAAAA,MAAM,EAAEgB,IAAI,CAACrB;AAA3C,GAAL,CAA1B,CADF;;AAIA,QAAMyB,eAAe,GAAIC,OAAD,IAAa;AACnC;;AAEA,QAAIC,QAAQ,GAAG,EAAf,CAHmC,CAInC;;AACAf,IAAAA,KAAK,CAACb,KAAN,CAAY6B,OAAZ,CACEP,IAAI,IAAIA,IAAI,CAACpB,QAAL,CAAc2B,OAAd,CACN1B,OAAO,IAAIA,OAAO,CAAC,SAAD,CAAP,KAAuBwB,OAAO,CAAC1B,EAA/B,IAAqC2B,QAAQ,CAACE,IAAT,CAAc;AAAEzB,MAAAA,MAAM,EAACiB,IAAI,CAACrB,EAAd;AAAkBK,MAAAA,MAAM,EAACqB,OAAO,CAAC1B;AAAjC,KAAd,CAD1C,CADV,EALmC,CAUnC;;AACA0B,IAAAA,OAAO,CAACzB,QAAR,CAAiB2B,OAAjB,CACC1B,OAAO,IACNU,KAAK,CAACb,KAAN,CAAY6B,OAAZ,CACEP,IAAI,IAAIA,IAAI,CAACrB,EAAL,KAAYE,OAAO,CAAC,SAAD,CAAnB,IAAkCyB,QAAQ,CAACE,IAAT,CAAc;AAACzB,MAAAA,MAAM,EAACiB,IAAI,CAACrB,EAAb;AAAiBK,MAAAA,MAAM,EAACqB,OAAO,CAAC1B;AAAhC,KAAd,CAD5C,CAFF;AAMA,WAAO2B,QAAP;AACD,GAlBD;;AAoBA,QAAOG,iBAAiB,GAAG,CAAC/B,KAAD,EAAQgC,SAAS,GAAC,IAAlB,KAA2B;AACpD;;AAEA,QAAI5B,KAAJ;AACA,QAAG,EAAEJ,KAAK,YAAYiC,KAAnB,CAAH,EAA8BjC,KAAK,GAAG,CAACA,KAAD,CAAR,CAJsB,CAIJ;;AAChDA,IAAAA,KAAK,CAAC6B,OAAN,CAAgBP,IAAD,IAAU;AAAE;AACzBA,MAAAA,IAAI,GAAGD,WAAW,CAACC,IAAD,CAAlB;AACCU,MAAAA,SAAD,GAAa5B,KAAK,GAAGsB,eAAe,CAACJ,IAAD,CAApC,GAA6ClB,KAAK,GAAG,KAArD;AACAe,MAAAA,aAAa,CAAC;AAAEJ,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,OAAO,EAAE,CAACM,IAAD;AAAlC,OAAD,CAAb;AACAlB,MAAAA,KAAK,IAAIe,aAAa,CAAC;AAAEJ,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,OAAO,EAAEZ;AAAlC,OAAD,CAAtB;AACD,KALD;AAMD,GAXD;;AAaA,QAAO8B,iBAAiB,GAAIZ,IAAD,IAAU;AACnC;AACAA,IAAAA,IAAI,GAAI,EAAG,GAAGD,WAAW,CAACC,IAAD;AAAjB,KAAR;AAEAH,IAAAA,aAAa,CAAC;AAAEJ,MAAAA,IAAI,EAAE,iBAAR;AAA2BC,MAAAA,OAAO,EAAEM;AAApC,KAAD,CAAb;AACD,GALD;;AAOA,QAAOa,eAAe,GAAG,CAACnC,KAAD,EAAQgC,SAAS,GAAC,IAAlB,KAA2B;AAClD;;AAEA,QAAI5B,KAAJ;AACA,QAAG,EAAEJ,KAAK,YAAYiC,KAAnB,CAAH,EAA8BjC,KAAK,GAAG,CAACA,KAAD,CAAR,CAJoB,CAIF;;AAChDA,IAAAA,KAAK,CAAC6B,OAAN,CAAgBP,IAAD,IAAU;AAAE;AACzBA,MAAAA,IAAI,GAAGD,WAAW,CAACC,IAAD,CAAlB;AACCU,MAAAA,SAAD,GAAa5B,KAAK,GAAGsB,eAAe,CAACJ,IAAD,CAApC,GAA6ClB,KAAK,GAAG,KAArD;AACAe,MAAAA,aAAa,CAAC;AAAEJ,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,OAAO,EAAE,CAACM,IAAD;AAAlC,OAAD,CAAb;AACAlB,MAAAA,KAAK,IAAIe,aAAa,CAAC;AAAEJ,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,OAAO,EAAEZ;AAAlC,OAAD,CAAtB;AACD,KALD;AAMD,GAXD;;AAaA,QAAMgC,OAAO,GAAIC,MAAD,IAAYxB,KAAK,CAACb,KAAN,CAAYsC,MAAZ,CAAoBhB,IAAI,IAAIA,IAAI,CAACrB,EAAL,KAAYoC,MAAxC,EAAiD,CAAjD,CAA5B;AACA;;;AAEA,QAAME,WAAW,GAAG,CAACC,IAAD,EAAOC,QAAQ,GAAIC,MAAD,IAAWX,iBAAiB,CAACW,MAAD,EAAS,IAAT,CAA9C,KAAiE;AACnF;AACAC,IAAAA,KAAK,CAAC7C,YAAY,GAAG0C,IAAhB,CAAL,CACGI,IADH,CACSF,MAAM,IAAIA,MAAM,CAACG,IAAP,EADnB,EAEGD,IAFH,CAESF,MAAM,IAAIrB,WAAW,CAACqB,MAAD,CAF9B,EAGGE,IAHH,CAGSF,MAAM,IAAID,QAAQ,CAACC,MAAD,CAH3B,EAIGI,KAJH,CAIU,MAAM3B,aAAa,CAAC;AAAEJ,MAAAA,IAAI,EAAE;AAAR,KAAD,CAJ7B;AAKD,GAPD;;AASA,QAAMgC,uBAAuB,GAAIV,MAAD,IAAW;AACzC;AACA,QAAIf,IAAI,GAAGc,OAAO,CAACC,MAAD,CAAlB;AACAf,IAAAA,IAAI,CAACpB,QAAL,CAAc2B,OAAd,CAAwB1B,OAAD,IAAaoC,WAAW,CAACpC,OAAO,CAAC,SAAD,CAAR,CAA/C;AACD,GAJD,CAlIa,CAwIb;;;AACA,QAAM6C,kBAAkB,GAAGC,MAAM,IAAI9B,aAAa,CAAC;AAAEJ,IAAAA,IAAI,EAAE,iBAAR;AAA2BC,IAAAA,OAAO,EAAEiC,MAAM,CAAC3C,MAAP,CAAc4C;AAAlD,GAAD,CAAlD,CAzIa,CA0Ib;;;AACA,QAAMC,uBAAuB,GAAGF,MAAM,IAAI9B,aAAa,CAAC;AAAEJ,IAAAA,IAAI,EAAE,eAAR;AAAyBC,IAAAA,OAAO,EAAEiC,MAAM,CAAC3C,MAAP,CAAc4C;AAAhD,GAAD,CAAvD,CA3Ia,CA6Ib;;;AACA,QAAME,kBAAkB,GAAG,MAAM;AAC/BC,IAAAA,OAAO,CAACC,GAAR,CAAYzC,KAAK,CAACJ,UAAlB;AACA8B,IAAAA,WAAW,CAAC1B,KAAK,CAACJ,UAAP,EAAmByB,iBAAnB,CAAX;AACAmB,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ;AACD,GAJD,CA9Ia,CAoJb;AACA;;;AACA,QAAMC,gBAAgB,GAAG,MAAM;AAC7BpC,IAAAA,aAAa,CAAC;AAAEJ,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAb;AACD,GAFD;;AAIA,QAAMyC,WAAW,GAAG,UAASnB,MAAT,EAAiB;AACnCgB,IAAAA,OAAO,CAACC,GAAR,CAAa,gBAAejB,MAAO,EAAnC;AACAU,IAAAA,uBAAuB,CAACV,MAAD,CAAvB;AACD,GAHD;;AAKA,QAAMoB,gBAAgB,GAAG,UAASC,KAAT,EAAgBrB,MAAhB,EAAwB;AAC/CsB,IAAAA,MAAM,CAACC,KAAP,CAAc,sBAAqBvB,MAAO,EAA1C;AACD,GAFD;;AAIA,QAAMwB,WAAW,GAAG,UAASxD,MAAT,EAAiBC,MAAjB,EAAyB;AAC3CqD,IAAAA,MAAM,CAACC,KAAP,CAAc,wBAAuBvD,MAAO,QAAOC,MAAO,EAA1D;AACD,GAFD;;AAIA,QAAMwD,gBAAgB,GAAG,UAASJ,KAAT,EAAgBrD,MAAhB,EAAwBC,MAAxB,EAAgC;AACvDqD,IAAAA,MAAM,CAACC,KAAP,CAAc,8BAA6BvD,MAAO,QAAOC,MAAO,EAAhE;AACD,GAFD;;AAIA,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,cAAD;AAAgB,IAAA,EAAE,EAAC,QAAnB;AAA4B,IAAA,IAAI,EAAC,MAAjC;AAAwC,IAAA,QAAQ,MAAhD;AAAiD,IAAA,KAAK,EAAEO,KAAK,CAACJ,UAA9D;AAA0E,IAAA,aAAa,EAAEuC,kBAAzF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eADF,CADF,eAIE;AAAQ,IAAA,IAAI,EAAC,QAAb;AAAsB,IAAA,OAAO,EAAE,CAACnC,KAAK,CAACJ,UAAtC;AAAkD,IAAA,OAAO,EAAE2C,kBAA3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAJF,eAOE;AAAQ,IAAA,IAAI,EAAC,QAAb;AAAsB,IAAA,OAAO,EAAG,MAAMb,WAAW,CAAC,SAAD,CAAjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAPF,CADF,eAYE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,cAAD;AAAgB,IAAA,EAAE,EAAC,aAAnB;AAAiC,IAAA,IAAI,EAAC,MAAtC;AAA6C,IAAA,KAAK,EAAE1B,KAAK,CAACI,eAA1D;AAA2E,IAAA,aAAa,EAAEkC,uBAA1F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBADF,CADF,eAIE;AAAQ,IAAA,IAAI,EAAC,QAAb;AAAsB,IAAA,OAAO,EAAE,CAACtC,KAAK,CAACI,eAAtC;AAAuD,IAAA,OAAO,EAAEsC,gBAAhE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAJF,CAZF,eAoBE,oBAAC,KAAD;AACE,IAAA,EAAE,EAAC,UADL,CACgB;AADhB;AAEE,IAAA,IAAI,EAAE1C,KAFR;AAGE,IAAA,MAAM,EAAEhB,QAHV;AAIE,IAAA,WAAW,EAAE2D,WAJf;AAKE,IAAA,gBAAgB,EAAEC,gBALpB;AAME,IAAA,WAAW,EAAEI,WANf;AAOE,IAAA,gBAAgB,EAAEC,gBAPpB;AAQE,IAAA,eAAe,EAAE,OARnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IApBF,CADF;AAiCD;;AAED,MAAMC,cAAc,GAAG,CAAC;AAAE9D,EAAAA,EAAF;AAAMc,EAAAA,IAAN;AAAYmC,EAAAA,KAAZ;AAAmBc,EAAAA,aAAnB;AAAkCC,EAAAA,SAAlC;AAA6CC,EAAAA;AAA7C,CAAD,KAA6D;AAClF;AACA;AACA,QAAMC,QAAQ,GAAGxE,KAAK,CAACyE,MAAN,EAAjB,CAHkF,CAIlF;;AACAzE,EAAAA,KAAK,CAAC0E,SAAN,CAAgB,MAAM;AAAE,QAAGJ,SAAS,IAAIE,QAAQ,CAACG,OAAzB,EAAkCH,QAAQ,CAACG,OAAT,CAAiBC,OAAjB;AAA6B,GAAvF,EAAyF,CAACN,SAAD,CAAzF;AACA,sBAAO,uDACL;AAAO,IAAA,OAAO,EAAEhE,EAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAsBiE,QAAtB,MADK,uBAGL;AAAO,IAAA,EAAE,EAAEjE,EAAX;AAAe,IAAA,GAAG,EAAEkE,QAApB;AAA8B,IAAA,IAAI,EAAEpD,IAApC;AAA0C,IAAA,KAAK,EAAEmC,KAAjD;AAAwD,IAAA,QAAQ,EAAEc,aAAlE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAHK,CAAP;AAKD,CAXD;;AAaA,eAAerD,GAAf","sourcesContent":["import React from 'react';\nimport './App.css';\nimport { Graph } from \"react-d3-graph\";\nimport  myConfig  from \"./myConfig\";\nconst API_ENDPOINT = 'http://127.0.0.1:8000/api/v1/'\n\n/* graph payload (with minimalist structure)\nconst state_guide = {\n\t\tnodes: [{ id: \"zine\", }, { id: \"cool\" }, { id: \"world\" }],\n\t\tlinks: [\n\t\t\t\t{ source: \"zine\", target: \"cool\"  },\n\t\t\t\t{ source: \"zine\", target: \"world\" },\n\t\t],\n\t\tisError: false,\n\t\tisLoading: true,\n\t\tsearchTerm: '',\n\t\tDestinationTerm: '',\n};\n*/\n\n// graph payload (with minimalist structure)\nconst initial_state = {\n\t\tnodes: [{ id: \"zine\", synonyms:[ {synonym: 'anxious'}, ] }, { id: \"cool\", synonyms:[ {synonym: 'anxious'}, ]}, { id: \"world\", synonyms:[]}],\n\t\tlinks: [\n\t\t\t\t{ source: \"zine\", target: \"cool\" },\n\t\t\t\t{ source: \"zine\", target: \"world\"},\n\t\t],\n\t\tisError: false,\n\t\tisLoading: true,\n\t\tsearchTerm: '',\n\t\tDestinationTerm: '',\n};\n\nfunction App() {\n\n\n\t\t// make reducer for the words data and internal state \n\t\tconst stateReducer = (state, action) =>{\n\t\t\t\tswitch (action.type){\n\t\t\t\t\t\tcase 'SET_NEW_NODES':\n\t\t\t\t\t\t\t\treturn { \n\t\t\t\t\t\t\t\t\t\t...state, \n\t\t\t\t\t\t\t\t\t\tnodes: [ ...state.nodes, ...action.payload ],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'SET_NEW_LINKS':\n\t\t\t\t\t\t\t\treturn { \n\t\t\t\t\t\t\t\t\t\t...state, \n\t\t\t\t\t\t\t\t\t\tlinks: [ ...state.links, ...action.payload ]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'SET_SEARCH_NODE':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tnodes: [ action.payload ],\n\t\t\t\t\t\t\t\t\t\tlinks: [],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'ERASE_NODES':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\t\t\t\tlinks: [],\n\t\t\t\t\t\t\t\t};\n\n\n\t\t\t\t\t\tcase 'SET_SEARCH_TERM':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tsearchTerm: action.payload,\t\t\t\t\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcase 'SET_DEST_TERM':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tdestinationTerm: action.payload,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'SET_FETCH_FAILED':\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t...state,\n\t\t\t\t\t\t\t\t\t\tisError: true,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\t\t}\n\n\t\tconst [state, dispatchState] = React.useReducer( stateReducer, initial_state );\n\t\t/* define dispatcher for the Internal data */\n\n\t\tconst processNode = (node) =>{\n\t\t\t\t/* process a node from the api into one for the dispatcher\n\t\t\t\t * it changes title for id, for instance */\n\t\t\t\tnode['id'] = node.title\n\t\t\t\treturn node\n\t\t}\n\n\t\tconst createShallowLinks = (node) => \n\t\t\t\tnode.synonyms.map( synonym => ({ source: synonym['synonym'], target: node.id }))\n\n\n\t\tconst createDeepLinks = (newNode) => {\n\t\t\t\t/* This is pornography, but it basically check if a new word is a synonym of one already \n\t\t\t\t\tor if the new word has synonyms one of the words already in state */\n\t\t\t\tlet newLinks = [];\n\t\t\t\t// look if state nodes are synonym of new word\n\t\t\t\tstate.nodes.forEach( \n\t\t\t\t\t\tnode => node.synonyms.forEach( \n\t\t\t\t\t\t\t\tsynonym => synonym[\"synonym\"] === newNode.id && newLinks.push({ source:node.id, target:newNode.id })\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t// look if new word has a synonym to to state word\n\t\t\t\tnewNode.synonyms.forEach( \n\t\t\t\t\tsynonym => \n\t\t\t\t\t\tstate.nodes.forEach( \n\t\t\t\t\t\t\t\tnode => node.id === synonym[\"synonym\"] && newLinks.push({source:node.id, target:newNode.id})\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\treturn newLinks\n\t\t} \n\n\t\tconst  loadNodesCallBack = (nodes, withLinks=true) => {\n\t\t\t\t/* append array of nodes with a waiting time in between them so that they flow\n\t\t\t\t * also create new links and append them to state */\n\t\t\t\tlet links;\n\t\t\t\tif(!(nodes instanceof Array)) nodes = [nodes,]  // if a single node was passed\n\t\t\t\tnodes.forEach( (node) => { // if passed is an array\n\t\t\t\t\t\tnode = processNode(node);\n\t\t\t\t\t\t(withLinks)? links = createDeepLinks(node) : links = false\n\t\t\t\t\t\tdispatchState({ type: 'SET_NEW_NODES', payload: [node,]});\n\t\t\t\t\t\tlinks && dispatchState({ type: 'SET_NEW_LINKS', payload: links });\n\t\t\t\t})\n\t\t}\n\t\t\n\t\tconst  newSearchCallback = (node) => {\n\t\t\t\t/* call back for creating a new node */\n\t\t\t\tnode =  {  ...processNode(node) }\n\n\t\t\t\tdispatchState({ type: 'SET_SEARCH_NODE', payload: node});\n\t\t}\n\n\t\tconst  ShallowCallBack = (nodes, withLinks=true) => {\n\t\t\t\t/* append array of nodes with a waiting time in between them so that they flow\n\t\t\t\t * also create new links and append them to state */\n\t\t\t\tlet links;\n\t\t\t\tif(!(nodes instanceof Array)) nodes = [nodes,]  // if a single node was passed\n\t\t\t\tnodes.forEach( (node) => { // if passed is an array\n\t\t\t\t\t\tnode = processNode(node);\n\t\t\t\t\t\t(withLinks)? links = createDeepLinks(node) : links = false\n\t\t\t\t\t\tdispatchState({ type: 'SET_NEW_NODES', payload: [node,]});\n\t\t\t\t\t\tlinks && dispatchState({ type: 'SET_NEW_LINKS', payload: links });\n\t\t\t\t})\n\t\t}\n\n\t\tconst getNode = (nodeId) => state.nodes.filter( node => node.id === nodeId )[0]\n\t\t/* get node with given node id from state */\n\t\t\n\t\tconst requestNode = (word, callback = (result)=> loadNodesCallBack(result, true)) => { \n\t\t\t\t/* request a single node to the api and dispatch to state */\n\t\t\t\tfetch(API_ENDPOINT + word) \n\t\t\t\t\t\t.then( result => result.json())\n\t\t\t\t\t\t.then( result => processNode(result))\n\t\t\t\t\t\t.then( result => callback(result))\n\t\t\t\t\t\t.catch( () => dispatchState({ type: 'SET_FETCH_FAILED' }) );\n\t\t}\n\t\t\n\t\tconst requestSurroundingNodes = (nodeId) =>{\n\t\t\t\t// can be optimised by having a sorted list and using binary search\n\t\t\t\tlet node = getNode(nodeId);\n\t\t\t\tnode.synonyms.forEach( (synonym) => requestNode(synonym['synonym']) );\n\t\t}\t\n\n\t\t// handle the change by seting the state variable to \n\t\tconst handleSearchChange = change => dispatchState({ type: 'SET_SEARCH_TERM', payload: change.target.value });\n\t\t// handle the change by seting the state variable to \n\t\tconst handleDestinationChange = change => dispatchState({ type: 'SET_DEST_TERM', payload: change.target.value });\n\n\t\t// handle submit search button\n\t\tconst handleSearchSubmit = () => { \n\t\t\t\tconsole.log(state.searchTerm)\n\t\t\t\trequestNode(state.searchTerm, newSearchCallback)\n\t\t\t\tconsole.log(\"got here\")\n\t\t};\n\n\t\t// get node info\n\t\t// handle path button\n\t\tconst handlePathSubmit = () => { \n\t\t\t\tdispatchState({ type: 'RESET_NODE' });\n\t\t};\n\n\t\tconst onClickNode = function(nodeId) {\n\t\t\t\tconsole.log(`clicked node ${nodeId}`);\n\t\t\t\trequestSurroundingNodes(nodeId);\n\t\t};\n\n\t\tconst onRightClickNode = function(event, nodeId) {\n\t\t\t\twindow.alert(`Right clicked node ${nodeId}`);\n\t\t};\n\n\t\tconst onClickLink = function(source, target) {\n\t\t\t\twindow.alert(`Clicked link between ${source} and ${target}`);\n\t\t};\n\n\t\tconst onRightClickLink = function(event, source, target) {\n\t\t\t\twindow.alert(`Right clicked link between ${source} and ${target}`);\n\t\t};\n\n\t\treturn (\n\t\t\t\t<div className=\"App\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<InputWithLabel id=\"search\" type=\"text\" isFocuse value={state.searchTerm} onInputChange={handleSearchChange}>\n\t\t\t\t\t\t\t\t\t\t<strong>Search:</strong>\n\t\t\t\t\t\t\t\t</InputWithLabel>\n\t\t\t\t\t\t\t\t<button type=\"button\" disable={!state.searchTerm} onClick={handleSearchSubmit}>\n\t\t\t\t\t\t\t\t\t\tSearch\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<button type=\"button\" onClick={ () => requestNode(\"anxious\") }>\n\t\t\t\t\t\t\t\t\t\tAdd random Nodes\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<InputWithLabel id=\"destination\" type=\"text\" value={state.destinationTerm} onInputChange={handleDestinationChange}>\n\t\t\t\t\t\t\t\t\t\t<strong>Destination:</strong>\n\t\t\t\t\t\t\t\t</InputWithLabel>\n\t\t\t\t\t\t\t\t<button type=\"button\" disable={!state.destinationTerm} onClick={handlePathSubmit}>\n\t\t\t\t\t\t\t\t\t\tGet path\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<Graph\n\t\t\t\t\t\t\t\tid=\"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n\t\t\t\t\t\t\t\tdata={state}\n\t\t\t\t\t\t\t\tconfig={myConfig}\n\t\t\t\t\t\t\t\tonClickNode={onClickNode}\n\t\t\t\t\t\t\t\tonRightClickNode={onRightClickNode}\n\t\t\t\t\t\t\t\tonClickLink={onClickLink}\n\t\t\t\t\t\t\t\tonRightClickLink={onRightClickLink}\n\t\t\t\t\t\t\t\tbackgroundColor={\"black\"}\n\t\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t);\n}\n\nconst InputWithLabel = ({ id, type, value, onInputChange, isFocused, children }) => {\n\t\t/* A component with the Input and a Label */\n\t\t// Define an input ref for passing to input component\n\t\tconst inputRef = React.useRef()\n\t\t// set up a side effect it is updates if the focus changes\n\t\tReact.useEffect(() => { if(isFocused && inputRef.current) inputRef.current.focused(); }, [isFocused])\n\t\treturn <>\n\t\t\t\t<label htmlFor={id}> {children} </label>\n\t\t\t\t&nbsp;\n\t\t\t\t<input id={id} ref={inputRef} type={type} value={value} onChange={onInputChange}/>\n\t\t</>\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}
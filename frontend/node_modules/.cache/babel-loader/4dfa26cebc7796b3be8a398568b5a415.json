{"ast":null,"code":"module.exports = generateBoundsFunction;\nmodule.exports.generateFunctionBody = generateBoundsFunctionBody;\n\nconst createPatternBuilder = require('./createPatternBuilder');\n\nfunction generateBoundsFunction(dimension) {\n  let code = generateBoundsFunctionBody(dimension);\n  return new Function('bodies', 'settings', 'random', code);\n}\n\nfunction generateBoundsFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var boundingBox = {\n    ${pattern('min_{var}: 0, max_{var}: 0,', {\n    indent: 4\n  })}\n  };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n      var ${pattern('base_{var} = 0', {\n    join: ', '\n  })};\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          let neighborPos = neighbors[i].pos;\n          ${pattern('base_{var} += neighborPos.{var};', {\n    indent: 10\n  })}\n        }\n\n        ${pattern('base_{var} /= neighbors.length;', {\n    indent: 8\n  })}\n      } else {\n        ${pattern('base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;', {\n    indent: 8\n  })}\n      }\n\n      var springLength = settings.springLength;\n      return {\n        ${pattern('{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,', {\n    indent: 8\n  })}\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; // No bodies - no borders.\n\n    ${pattern('var max_{var} = Number.MIN_VALUE;', {\n    indent: 4\n  })}\n    ${pattern('var min_{var} = Number.MAX_VALUE;', {\n    indent: 4\n  })}\n\n    while(i--) {\n      // this is O(n), it could be done faster with quadtree, if we check the root node bounds\n      var bodyPos = bodies[i].pos;\n      ${pattern('if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};', {\n    indent: 6\n  })}\n      ${pattern('if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};', {\n    indent: 6\n  })}\n    }\n\n    ${pattern('boundingBox.min_{var} = min_{var};', {\n    indent: 4\n  })}\n    ${pattern('boundingBox.max_{var} = max_{var};', {\n    indent: 4\n  })}\n  }\n\n  function resetBoundingBox() {\n    ${pattern('boundingBox.min_{var} = boundingBox.max_{var} = 0;', {\n    indent: 4\n  })}\n  }\n`;\n  return code;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.forcelayout/lib/codeGenerators/generateBounds.js"],"names":["module","exports","generateBoundsFunction","generateFunctionBody","generateBoundsFunctionBody","createPatternBuilder","require","dimension","code","Function","pattern","indent","join"],"mappings":"AACAA,MAAM,CAACC,OAAP,GAAiBC,sBAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,oBAAf,GAAsCC,0BAAtC;;AAEA,MAAMC,oBAAoB,GAAGC,OAAO,CAAC,wBAAD,CAApC;;AAEA,SAASJ,sBAAT,CAAgCK,SAAhC,EAA2C;AACzC,MAAIC,IAAI,GAAGJ,0BAA0B,CAACG,SAAD,CAArC;AACA,SAAO,IAAIE,QAAJ,CAAa,QAAb,EAAuB,UAAvB,EAAmC,QAAnC,EAA6CD,IAA7C,CAAP;AACD;;AAED,SAASJ,0BAAT,CAAoCG,SAApC,EAA+C;AAC7C,MAAIG,OAAO,GAAGL,oBAAoB,CAACE,SAAD,CAAlC;AAEA,MAAIC,IAAI,GAAI;;MAERE,OAAO,CAAC,6BAAD,EAAgC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAhC,CAA6C;;;;;;;;;;;YAW9CD,OAAO,CAAC,gBAAD,EAAmB;AAACE,IAAAA,IAAI,EAAE;AAAP,GAAnB,CAAiC;;;;;YAKxCF,OAAO,CAAC,kCAAD,EAAqC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAArC,CAAmD;;;UAG5DD,OAAO,CAAC,iCAAD,EAAoC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAApC,CAAiD;;UAExDD,OAAO,CAAC,mEAAD,EAAsE;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtE,CAAmF;;;;;UAK1FD,OAAO,CAAC,iEAAD,EAAoE;AAACC,IAAAA,MAAM,EAAE;AAAT,GAApE,CAAiF;;;;;;;;;MAS5FD,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAAmD;MAC1DD,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAAmD;;;;;QAKxDD,OAAO,CAAC,2DAAD,EAA8D;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA9D,CAA2E;QAClFD,OAAO,CAAC,2DAAD,EAA8D;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA9D,CAA2E;;;MAGpFD,OAAO,CAAC,oCAAD,EAAuC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAvC,CAAoD;MAC3DD,OAAO,CAAC,oCAAD,EAAuC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAvC,CAAoD;;;;MAI3DD,OAAO,CAAC,oDAAD,EAAuD;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAvD,CAAoE;;CApD/E;AAuDA,SAAOH,IAAP;AACD","sourcesContent":["\nmodule.exports = generateBoundsFunction;\nmodule.exports.generateFunctionBody = generateBoundsFunctionBody;\n\nconst createPatternBuilder = require('./createPatternBuilder');\n\nfunction generateBoundsFunction(dimension) {\n  let code = generateBoundsFunctionBody(dimension);\n  return new Function('bodies', 'settings', 'random', code);\n}\n\nfunction generateBoundsFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n\n  let code = `\n  var boundingBox = {\n    ${pattern('min_{var}: 0, max_{var}: 0,', {indent: 4})}\n  };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n      var ${pattern('base_{var} = 0', {join: ', '})};\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          let neighborPos = neighbors[i].pos;\n          ${pattern('base_{var} += neighborPos.{var};', {indent: 10})}\n        }\n\n        ${pattern('base_{var} /= neighbors.length;', {indent: 8})}\n      } else {\n        ${pattern('base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;', {indent: 8})}\n      }\n\n      var springLength = settings.springLength;\n      return {\n        ${pattern('{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,', {indent: 8})}\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; // No bodies - no borders.\n\n    ${pattern('var max_{var} = Number.MIN_VALUE;', {indent: 4})}\n    ${pattern('var min_{var} = Number.MAX_VALUE;', {indent: 4})}\n\n    while(i--) {\n      // this is O(n), it could be done faster with quadtree, if we check the root node bounds\n      var bodyPos = bodies[i].pos;\n      ${pattern('if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};', {indent: 6})}\n      ${pattern('if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};', {indent: 6})}\n    }\n\n    ${pattern('boundingBox.min_{var} = min_{var};', {indent: 4})}\n    ${pattern('boundingBox.max_{var} = max_{var};', {indent: 4})}\n  }\n\n  function resetBoundingBox() {\n    ${pattern('boundingBox.min_{var} = boundingBox.max_{var} = 0;', {indent: 4})}\n  }\n`\n  return code;\n}"]},"metadata":{},"sourceType":"script"}
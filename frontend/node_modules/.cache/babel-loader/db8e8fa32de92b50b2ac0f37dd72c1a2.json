{"ast":null,"code":"import { colors, API_ENDPOINT } from \"./myConfig\";\nimport { getRandomInt } from \"./Components/RandomGenerator\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n/* \n * Functions for processing single node search and adjacent nodes \n * */\n\nconst processNode = node => {\n  /* process a node from the api into one for the dispatcher\n   * it changes title for id, for instance */\n  node['id'] = node.w_id;\n  node['label'] = node.word;\n  node['key'] = node.w_id;\n  node['isSelected'] = false;\n  node['isDone'] = false;\n  node['color'] = colors.node.default;\n  return node;\n};\n/* retrive node with given node id from state */\n\n\nconst getNode = (nodeId, state) => state.nodes.filter(node => node.id === nodeId)[0];\n/* returns true id node is not in state in state, \n * could import time complexity by using a hash table */\n\n\nconst isNewNode = (nodeId, state) => state.nodes.every(node => node.id !== nodeId);\n/* when user clicks on a node, query adjacent nodes\n * and set node as selected */\n\n\nconst onClickNode = (input, state, dispatchState) => {\n  let node = typeof input == 'string' ? getNode(input, state.forceData) : input;\n  state.selected['color'] = colors.node.done;\n  queryAdjecentNodes(node, state, dispatchState);\n  dispatchState({\n    type: 'SET_NODE_DONE',\n    payload: state.selected\n  });\n  dispatchState({\n    type: 'SWITCH_SELECTED_NODE',\n    payload: node\n  });\n  node['isDone'] = true;\n  node['color'] = colors.node.selected;\n};\n/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/\n\n\nconst timelyDispatch = (dispatchFunc, waitTime = 0.5, random = 0) => setTimeout(dispatchFunc, waitTime + getRandomInt(random));\n/* reset the graph state and start a new query into a word, \n * sometime this stymes when it is called a second time,\n * this might be because of dispatchState being called twice\n * must investigate.  */\n\n\nconst queryNewWord = (word, state, dispatchState) => {\n  //console.log(\"query New owrd ran\")\n  fetch(API_ENDPOINT + word) // fetch word\n  .then(result => result.json()) //unpack node\n  .then(result => catchError(result, state, dispatchState)) //check if word was found\n  .then(result => processNode(result)) //process node\n  .then(node => {\n    node['color'] = colors.node.selected;\n    return node;\n  }) //process node\n  .then(node => {\n    //dispatch as new word\n    dispatchState({\n      type: 'SET_NEW_NODE',\n      payload: node\n    });\n    return node;\n  }) // get the surrounding words\n  .then(node => {\n    //console.log(\"querying adhjacent nodes\")\n    //console.log(node)\n    queryAdjecentNodes(node, state, dispatchState);\n  }).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n/* Fetch all the adjancent node of a given node and dispatch */\n\n\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n  // define whether we should link te deeper\n  let linkAll = state.isDeepLinks; // define which type of graph we are requesting\n\n  let graph_type = 'synonyms/'; // request the synonyms\n\n  fetch(API_ENDPOINT + graph_type + node.id).then(result => result.json()) // unpack json\n  .then(adjNodes => adjNodes.forEach( // for every node in the fetched array\n  adjNode => timelyDispatch(() => {\n    // dispacth timely\n    // for each of the nodes in the list \t\t\n    adjNode = processNode(adjNode); //process node \n    //console.log(\"node processed to dispatch\")\n    //console.log(adjNode)\n    // proces is it is new node, or deep link set\n\n    if (isNewNode(adjNode.id, state)) {\n      // if it is a new node append \n      dispatchState({\n        //dispatch node with link node\n        type: 'SET_NODE_LINK',\n        payload: {\n          node: adjNode,\n          link: {\n            source: node,\n            target: adjNode //color: 'red',\n\n          }\n        }\n      });\n    } else if (linkAll) {\n      dispatchState({\n        // if deep links is on , and it is a new node\n        type: 'SET_NEW_LINK',\n        payload: {\n          source: node,\n          target: getNode(adjNode.id, state.forceData) //color: 'red',\n\n        }\n      });\n    }\n  }))).catch(() => dispatchState({\n    type: 'SET_FETCH_FAILED'\n  }));\n};\n/* \n * Functions for processing paths of nodes \n *\n * */\n\n/* takes a list of inputs \n * and divied it into pairs */\n\n\nconst pairUp = list => {\n  let pairs = [];\n\n  for (let i = 0; i + 1 <= list.length - 1; i++) pairs.push({\n    'first': list[i],\n    'last': list[i + 1]\n  });\n\n  return pairs;\n};\n/* gets a list of word and removes the ones which \n * do not checkout in the api.\n * This seemly simple task becomes complex to do \n * with promises*/\n\n\nconst removeNotFoundWords = async (words, dispatchState) => {\n  var foundWords = new Array(words.lenght); // make a empty array of as long as\n  // the origial to mantain the same order\n\n  await Promise.all(words.map((word, index) => // for every word check the api, \n  // await untill all promises are returned\n  fetch(API_ENDPOINT + 'check/' + word + \"/\").then(response => response.json()).then(response => {\n    if (response.detail === \"Found.\") {\n      foundWords[index] = word;\n    } else {\n      dispatchState({\n        type: 'SET_WORD_NOT_FOUND',\n        payload: word\n      });\n    }\n  }).catch(err => console.log(err))));\n  return foundWords.filter(Boolean);\n};\n/* add foreach node in the path where it comming from,\n\t\t* also adds the color to be graphed */\n\n\nconst processPath = (path, request) => {\n  let prevNode = null; //declare prev node\n\n  if (path instanceof Array) {\n    // only if it is a list \n    path.forEach(node => {\n      node = processNode(node); //might as well process node \n      // set the previous node if there was a previous one\n\n      node['prevNode'] = prevNode ? prevNode : node.id; // colo if it is reuested\n\n      if (node.word === request.first || node.word === request.last) node['color'] = colors.node.selected; // color as selected\n      // if it is start of path set first previous to itself\n\n      prevNode = node.id;\n    });\n  }\n\n  return path;\n};\n/* gets a list of pair request for paths an queryes the api \n * then is saves those paths in a order list and returns*/\n\n\nconst fetchPathsParts = async (pathRequests, dispatchState) => {\n  // make an empty array of the same length as request paths\n  var paths = new Array(pathRequests.length);\n  await Promise.all( //wait for all promises to return \n  pathRequests.map((request, index) => fetch(API_ENDPOINT + 'path/' + request.first + \"/\" + request.last).then(response => response.json()).then(response => processPath(response, request)).then(response => {\n    if (response.detail === \"Path not found.\") {\n      dispatchState({\n        type: 'SET_PATH_NOT_FOUND',\n        payload: request\n      });\n      paths[index] = null;\n    } else {\n      paths[index] = response;\n    }\n  }).catch(err => console.log(err))));\n  return paths;\n};\n\nconst amendPath = async paths => {\n  /* takes a list of paths and if there\n   * is a gap tries to find a connecting path*/\n  const getGaps = paths => {\n    /* takes a list of paths retusn a list of \n     * indexes where the gaps are*/\n    let gaps = [];\n    let gap = {\n      start: null,\n      end: null\n    };\n    let wasPath = false;\n    let wasGap = false;\n    paths.forEach((path, index) => {\n      if (path === null) {\n        // if it is gap\n        if (wasPath) {\n          // comes from gap\n          gap.start = index; //save start\n        } // and comes from path\n\n\n        wasGap = true; // switch to gap\n\n        wasPath = false;\n      } else {\n        //if is path\n        if (wasGap) {\n          // and comes from gap\n          gap.end = index; // record end\n\n          gaps.push({ ...gap\n          }); //save gap\n        }\n\n        wasPath = true; // switch to path \n\n        wasGap = false;\n      }\n    });\n    return gaps;\n  };\n\n  function* nextNodeGenerator(start, end, paths) {\n    /* makes a generator to go thought the nodes\n     * which must try to find a bridge*/\n    // for every path left in paths\n    for (let pathIndex = end; pathIndex < paths.length; pathIndex++) {\n      let curPath = paths[pathIndex];\n\n      if (paths[pathIndex] !== null) {\n        // if it is not a null path\n        // \tif gap is one length, start at 1, else 0\n        //let index = (end-start > 1)? 0 : 1; \n        // for every node in the current path\n        for (let nodeIndex = 0; nodeIndex < curPath.length; nodeIndex++) {\n          let stop = yield curPath[nodeIndex]; // return the current path \n\n          if (stop === true) // if the messeage send back is to stop\n            return null; // stop generation\n        }\n      }\n    }\n\n    return null; // reached the end\n  }\n\n  const bridgeGap = async (start, end, paths) => {\n    /* gets a set of indexes indicating the gap, \n     * make fetch request to attempt to find a \n     * conncetion */\n\n    /* generator fuction for trying node to  find a bridge*/\n    let leftPath = paths[start - 1]; // last word in the left side path\n\n    let lastWord = leftPath[leftPath.length - 1].word; // if there exacly one gap, dont bother chechi\n    //let index = (end-start > 1)? 0 : 1; \n\n    let gen = nextNodeGenerator(start, end, paths);\n    let curIter = gen.next();\n\n    const foundBridge = response => {\n      if (response.detail === \"Path not found.\") {\n        curIter = gen.next(); // get the next node\n      } else {\n        paths[start] = response; //set the bridge\n\n        curIter = gen.next(true); //break loop\n      }\n    };\n\n    while (!curIter.done) {\n      // while the bridge is not been found\n      await fetch(API_ENDPOINT + 'path/' + lastWord + \"/\" + curIter.value.word).then(response => response.json()).then(response => processPath(response)).then(foundBridge).catch(err => console.log(err));\n    }\n  };\n\n  paths.forEach((path, index, paths) => {\n    if (index > 0) {\n      let prevPath = paths[index - 1];\n\n      if (path[0].w_id = prevPath[prevPath.lenght - 1]) {\n        console.log(path);\n      }\n    }\n  });\n  let gaps = getGaps(paths);\n  await Promise.all(gaps.map(gap => bridgeGap(gap.start, gap.end, paths)));\n  return paths;\n};\n/* get a list of paths of words, joins them together \n * and dipatches it to state*/\n\n\nconst dispatchPath = (paths, state, dispatchState) => {\n  let finalPath = []; // declare final array\n  //if( paths isIntanceof Array) return null;\n\n  paths = paths.filter(Boolean); // filter any null chars\n  // add all paths together\n\n  paths.forEach(path => finalPath.push(...path)); // console.log(finalPath)\n\n  finalPath.forEach((node, index) => //for every node in final path\n  timelyDispatch(() => {\n    // dispath in a timely order\n    if (index === 0) {\n      // if this is the first node\n      dispatchState({\n        //dipatch as new node\n        type: 'SET_NEW_NODE',\n        payload: node\n      });\n    } else {\n      // is not first node\n      dispatchState({\n        //if append a node list\n        type: 'SET_PATH_NODE',\n        payload: {\n          node: node,\n          link: {\n            target: node.id,\n            source: node.prevNode\n          }\n        }\n      });\n    }\n  }));\n};\n/* gets passesed a set of two words, \n * queries the server for the path and \n * dispateches the result to state */\n\n\nconst queryPath = async (words, state, dispatchState) => {\n  //first remove all words from the input which are not in api\n  words = await removeNotFoundWords(words, dispatchState).catch(err => //catch error is could not fetch\n  dispatchState({\n    type: 'SET_ERROR',\n    payload: \"Could not get words\"\n  })); // get the list of words and return them in pair\n  // w1, w2, w3, w4 => (w1, w2), (w2, w3), (w3, w4)\n\n  let pathRequests = pairUp(words); // for every pair of words query the api for a path between them\n\n  let pathParts = await fetchPathsParts(pathRequests, dispatchState).catch(err => dispatchState({\n    type: 'SET_ERROR',\n    //catch error is could not fetch\n    payload: \"could not get paths\"\n  })); // get the final path and attempt to cannect them together\n  // to form one cohesive path\n\n  let finalPath = await amendPath(pathParts).catch(err => dispatchState({\n    type: 'SET_ERROR',\n    payload: \"Could not amend path\"\n  }));\n  dispatchPath(finalPath, state, dispatchState); // dispatch the ammedned path to state to be graphed\n};\n/* Set error to state when user search a word not found */\n\n\nconst catchError = (response, state, dispatchState) => {\n  //console.log(\"got to cath error:\")\n  //console.log(response)\n  if (response instanceof Array) {\n    let foundWords = []; //console.log(\"words was not found\")\n    // if it has the response for many words\n\n    response.forEach((word, index, words) => {\n      if (word.detail === \"Not Found.\") {\n        dispatchState({\n          type: 'SET_WORD_NOT_FOUND',\n          payload: word.w_id\n        });\n      } else {\n        foundWords.push(word);\n      }\n    });\n    return foundWords;\n  } else {\n    // if it only one elment\n    if (response.detail === \"Not found.\") {\n      dispatchState({\n        type: 'SET_WORD_NOT_FOUND',\n        payload: state.searchTerm\n      });\n      throw new Error(\"word not found\");\n    } else if (response.detail === \"Path not found.\") {\n      // if the error is path not found\n      //console.log(\"path was not found\")\n      dispatchState({\n        type: 'SET_PATH_NOT_FOUND',\n        payload: {\n          'first': response.first,\n          'last': response.last\n        }\n      });\n      throw new Error(\"path not found\");\n    } else {\n      return response;\n    }\n  }\n};\n\nconst onMouseOverNode = function (nodeId, dispatchState) {\n  dispatchState({\n    type: 'SET_DEFINED_NODE',\n    payload: nodeId\n  }); // need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","getRandomInt","processNode","node","w_id","word","default","getNode","nodeId","state","nodes","filter","id","isNewNode","every","onClickNode","input","dispatchState","forceData","selected","done","queryAdjecentNodes","type","payload","timelyDispatch","dispatchFunc","waitTime","random","setTimeout","queryNewWord","fetch","then","result","json","catchError","catch","linkAll","isDeepLinks","graph_type","adjNodes","forEach","adjNode","link","source","target","pairUp","list","pairs","i","length","push","removeNotFoundWords","words","foundWords","Array","lenght","Promise","all","map","index","response","detail","err","console","log","Boolean","processPath","path","request","prevNode","first","last","fetchPathsParts","pathRequests","paths","amendPath","getGaps","gaps","gap","start","end","wasPath","wasGap","nextNodeGenerator","pathIndex","curPath","nodeIndex","stop","bridgeGap","leftPath","lastWord","gen","curIter","next","foundBridge","value","prevPath","dispatchPath","finalPath","queryPath","pathParts","searchTerm","Error","onMouseOverNode"],"mappings":"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","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\nimport { getRandomInt }  from \"./Components/RandomGenerator\";\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n/* \n * Functions for processing single node search and adjacent nodes \n * */\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['label'] = node.word;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['isDone'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n/* retrive node with given node id from state */\nconst getNode = (nodeId, state) => \n\t\tstate.nodes.filter( node => \n\t\t\t\tnode.id === nodeId )[0]\n\n/* returns true id node is not in state in state, \n * could import time complexity by using a hash table */\nconst isNewNode = (nodeId, state) => \n\t\tstate.nodes.every( node => node.id !== nodeId )\n\n/* when user clicks on a node, query adjacent nodes\n * and set node as selected */\nconst onClickNode = (input, state, dispatchState) => {\n\t\tlet node = (typeof input == 'string')? \n\t\t\t\tgetNode(input, state.forceData) : input;\n\t\tstate.selected['color'] = colors.node.done;\n\t\tqueryAdjecentNodes(node, state, dispatchState)\n\t\tdispatchState({type:'SET_NODE_DONE', payload: state.selected})\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: node})\n\t\tnode['isDone'] = true;\n\t\tnode['color'] =  colors.node.selected;\n};\n\n/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/\n\nconst timelyDispatch = (dispatchFunc , waitTime=0.5, random=0) => \n\t\tsetTimeout(dispatchFunc, waitTime + getRandomInt(random));\n\n/* reset the graph state and start a new query into a word, \n * sometime this stymes when it is called a second time,\n * this might be because of dispatchState being called twice\n * must investigate.  */\nconst queryNewWord = (word, state, dispatchState) => {\n\t\t//console.log(\"query New owrd ran\")\n\t\tfetch(API_ENDPOINT + word) // fetch word\n\t\t\t\t.then(result => result.json()) //unpack node\n\t\t\t\t.then(result => catchError(result, state, dispatchState)) \n\t\t//check if word was found\n\t\t\t\t.then(result => processNode(result)) //process node\n\t\t\t\t.then(node => { node['color'] = colors.node.selected ; return node })//process node\n\t\t\t\t.then(node => { //dispatch as new word\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\tpayload: node\n\t\t\t\t\t\t}); \n\t\t\t\t\t\treturn node; })\n\t\t// get the surrounding words\n\t\t\t\t.then(node => { \n\t\t\t\t\t\t//console.log(\"querying adhjacent nodes\")\n\t\t\t\t\t\t//console.log(node)\n\t\t\t\t\t\tqueryAdjecentNodes(node, state, dispatchState)\n\t\t\t\t})\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}));\n}\n\n/* Fetch all the adjancent node of a given node and dispatch */\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n\t\t// define whether we should link te deeper\n\t\tlet linkAll = state.isDeepLinks;\n\t\t// define which type of graph we are requesting\n\t\tlet graph_type = 'synonyms/';\n\t\t// request the synonyms\n\t\tfetch(API_ENDPOINT + graph_type + node.id )\n\t\t\t\t.then(result => result.json()) // unpack json\n\t\t\t\t.then(adjNodes =>  \n\t\t\t\t\t\tadjNodes.forEach(// for every node in the fetched array\n\t\t\t\t\t\t\t\tadjNode => timelyDispatch(() => {// dispacth timely\n\t\t\t\t\t\t\t\t\t\t// for each of the nodes in the list \t\t\n\t\t\t\t\t\t\t\t\t\tadjNode = processNode(adjNode); //process node \n\t\t\t\t\t\t\t\t\t\t//console.log(\"node processed to dispatch\")\n\t\t\t\t\t\t\t\t\t\t//console.log(adjNode)\n\t\t\t\t\t\t\t\t\t\t// proces is it is new node, or deep link set\n\t\t\t\t\t\t\t\t\t\tif(isNewNode(adjNode.id, state)){\n\t\t\t\t\t\t\t\t\t\t\t\t// if it is a new node append \n\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({//dispatch node with link node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//color: 'red',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}else if(linkAll){\n\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({// if deep links is on , and it is a new node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: getNode(adjNode.id, state.forceData), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//color: 'red',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t).catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\n\n/* \n * Functions for processing paths of nodes \n *\n * */\n\n/* takes a list of inputs \n * and divied it into pairs */\nconst pairUp = (list) => {\n\t\tlet pairs = [];\n\t\tfor(let i = 0; i+1 <= list.length - 1; i++)\n\t\t\t\tpairs.push({'first': list[i], 'last':list[i+1]});\n\t\treturn pairs\n}\n\n/* gets a list of word and removes the ones which \n * do not checkout in the api.\n * This seemly simple task becomes complex to do \n * with promises*/\nconst removeNotFoundWords = async (words, dispatchState) => {\n\t\tvar foundWords = new Array(words.lenght)\n\t\t// make a empty array of as long as\n\t\t// the origial to mantain the same order\n\t\tawait Promise.all( words.map( (word, index) => \n\t\t\t\t// for every word check the api, \n\t\t\t\t// await untill all promises are returned\n\t\t\t\tfetch(API_ENDPOINT+'check/'+ word +\"/\")\n\t\t\t\t.then( response => response.json())\n\t\t\t\t.then( response => { \n\t\t\t\t\t\tif(response.detail === \"Found.\"){ \n\t\t\t\t\t\t\t\tfoundWords[index] = word \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype:'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word})\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(err => console.log(err))\n\t\t))\n\t\treturn foundWords.filter( Boolean )\n}\n\n/* add foreach node in the path where it comming from,\n\t\t* also adds the color to be graphed */\nconst processPath = (path, request) =>{\n\t\tlet prevNode = null; //declare prev node\n\t\tif(path instanceof Array){ // only if it is a list \n\t\t\t\tpath.forEach((node) => { \n\t\t\t\t\t\tnode = processNode(node); //might as well process node \n\t\t\t\t\t\t// set the previous node if there was a previous one\n\t\t\t\t\t\tnode['prevNode'] = (prevNode)? prevNode : node.id;\n\t\t\t\t\t\t// colo if it is reuested\n\t\t\t\t\t\tif(node.word === request.first || node.word === request.last)\n\t\t\t\t\t\t\t\tnode['color'] = colors.node.selected // color as selected\n\t\t\t\t\t\t// if it is start of path set first previous to itself\n\t\t\t\t\t\tprevNode = node.id;\n\t\t\t\t})\n\t\t}\n\t\treturn path\n}\n\n\n/* gets a list of pair request for paths an queryes the api \n * then is saves those paths in a order list and returns*/\nconst fetchPathsParts = async (pathRequests, dispatchState) => {\n\t\t// make an empty array of the same length as request paths\n\t\tvar paths = new Array(pathRequests.length)\n\t\tawait Promise.all( //wait for all promises to return \n\t\t\t\tpathRequests.map((request, index) =>\n\t\t\t\t\t\tfetch(API_ENDPOINT+'path/'+request.first+\"/\"+request.last)\n\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t.then( response => processPath(response, request))\n\t\t\t\t\t\t.then( response => { \n\t\t\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype:'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: request});\n\t\t\t\t\t\t\t\t\t\tpaths[index] = null;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tpaths[index] = response;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t))\n\t\treturn paths;\n}\n\nconst amendPath = async (paths) => {\n\t\t/* takes a list of paths and if there\n\t\t * is a gap tries to find a connecting path*/\n\t\tconst getGaps = (paths) => {\n\t\t\t\t/* takes a list of paths retusn a list of \n\t\t\t\t * indexes where the gaps are*/\n\t\t\t\tlet gaps = [];\n\t\t\t\tlet gap = {start:null, end:null}\n\t\t\t\tlet wasPath = false;\n\t\t\t\tlet wasGap = false;\n\t\t\t\tpaths.forEach((path, index) => {\n\t\t\t\t\t\tif(path === null ){// if it is gap\n\t\t\t\t\t\t\t\tif(wasPath){  // comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.start = index //save start\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// and comes from path\n\t\t\t\t\t\t\t\twasGap = true; // switch to gap\n\t\t\t\t\t\t\t\twasPath = false \n\t\t\t\t\t\t}else{ //if is path\n\t\t\t\t\t\t\t\tif(wasGap){   // and comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.end = index; // record end\n\t\t\t\t\t\t\t\t\t\tgaps.push({...gap}); //save gap\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\twasPath = true; // switch to path \n\t\t\t\t\t\t\t\twasGap = false;\n\t\t\t\t\t\t}\n\t\t\t\t}) \n\t\t\t\treturn gaps;\n\t\t}\n\n\t\tfunction* nextNodeGenerator(start, end, paths) {\n\t\t\t\t/* makes a generator to go thought the nodes\n\t\t\t\t * which must try to find a bridge*/\n\t\t\t\t// for every path left in paths\n\t\t\t\tfor(let pathIndex = end; pathIndex < paths.length; pathIndex++){\n\t\t\t\t\t\tlet curPath = paths[pathIndex]\n\t\t\t\t\t\tif(paths[pathIndex] !== null){ // if it is not a null path\n\t\t\t\t\t\t\t\t// \tif gap is one length, start at 1, else 0\n\t\t\t\t\t\t\t\t//let index = (end-start > 1)? 0 : 1; \n\t\t\t\t\t\t\t\t// for every node in the current path\n\t\t\t\t\t\t\t\tfor(let nodeIndex = 0; nodeIndex < curPath.length; nodeIndex++){\n\t\t\t\t\t\t\t\t\t\tlet stop = yield curPath[nodeIndex]; // return the current path \n\t\t\t\t\t\t\t\t\t\tif(stop === true) // if the messeage send back is to stop\n\t\t\t\t\t\t\t\t\t\t\t\treturn null; // stop generation\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null; // reached the end\n\t\t}\n\n\n\t\tconst bridgeGap = async (start, end, paths) => {\n\t\t\t\t/* gets a set of indexes indicating the gap, \n\t\t\t\t * make fetch request to attempt to find a \n\t\t\t\t * conncetion */\n\t\t\t\t/* generator fuction for trying node to  find a bridge*/\n\t\t\t\tlet leftPath = paths[start-1];\n\t\t\t\t// last word in the left side path\n\t\t\t\tlet lastWord = leftPath[leftPath.length-1].word;\n\t\t\t\t// if there exacly one gap, dont bother chechi\n\t\t\t\t//let index = (end-start > 1)? 0 : 1; \n\t\t\t\tlet gen = nextNodeGenerator(start, end, paths);\n\t\t\t\tlet curIter = gen.next();\n\t\t\t\tconst foundBridge = (response) =>{\n\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\tcurIter = gen.next(); // get the next node\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpaths[start] = response; //set the bridge\n\t\t\t\t\t\t\t\tcurIter = gen.next(true); //break loop\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\twhile(!curIter.done){ // while the bridge is not been found\n\t\t\t\t\t\tawait fetch(API_ENDPOINT+'path/'+lastWord+\"/\"+ curIter.value.word)\n\t\t\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t\t\t.then( response => processPath(response))\n\t\t\t\t\t\t\t\t.then( foundBridge )\n\t\t\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t}\n\t\t}\n\t\tpaths.forEach( (path, index, paths) => { \n\t\t\t\tif(index > 0){ \n\t\t\t\t\t\tlet prevPath = paths[index-1]\n\t\t\t\t\t\tif(path[0].w_id = prevPath[prevPath.lenght - 1]) {\n\t\t\t\t\t\t\t\tconsole.log(path)\n\t\t\t\t\t\t} \n\t\t\t\t}\n\t\t}\n\t\t)\n\t\tlet gaps = getGaps(paths);\n\t\tawait Promise.all(gaps.map( gap => bridgeGap(gap.start, gap.end, paths)))\n\t\treturn paths;\n}\n\n\n/* get a list of paths of words, joins them together \n * and dipatches it to state*/\nconst dispatchPath = (paths, state, dispatchState) => {\n\t\tlet finalPath = []; // declare final array\n\t\t//if( paths isIntanceof Array) return null;\n\t\tpaths = paths.filter( Boolean ); // filter any null chars\n\t\t// add all paths together\n\t\tpaths.forEach(path => finalPath.push(...path)) \n\t\t// console.log(finalPath)\n\t\tfinalPath.forEach((node, index) => //for every node in final path\n\t\t\t\ttimelyDispatch(() => { // dispath in a timely order\n\t\t\t\t\t\tif(index === 0){ // if this is the first node\n\t\t\t\t\t\t\t\tdispatchState({ //dipatch as new node\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: node, })\n\t\t\t\t\t\t}else{ // is not first node\n\t\t\t\t\t\t\t\tdispatchState({ //if append a node list\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.prevNode, \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t)\n}\n\n/* gets passesed a set of two words, \n * queries the server for the path and \n * dispateches the result to state */\nconst queryPath = async (words, state, dispatchState) => {\n\t\t//first remove all words from the input which are not in api\n\t\twords = await removeNotFoundWords(words, dispatchState)\n\t\t\t\t.catch(err =>  //catch error is could not fetch\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\t\t\tpayload:\"Could not get words\"}));\n\t\t// get the list of words and return them in pair\n\t\t// w1, w2, w3, w4 => (w1, w2), (w2, w3), (w3, w4)\n\t\tlet pathRequests = pairUp(words);\n\t\t// for every pair of words query the api for a path between them\n\t\tlet pathParts = await fetchPathsParts(pathRequests, dispatchState)\n\t\t\t\t.catch(err => \n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype:'SET_ERROR', //catch error is could not fetch\n\t\t\t\t\t\t\t\tpayload: \"could not get paths\"}));\n\t\t// get the final path and attempt to cannect them together\n\t\t// to form one cohesive path\n\t\tlet finalPath = await amendPath(pathParts)\n\t\t.catch(err => \n\t\t\t\tdispatchState({\n\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\tpayload: \"Could not amend path\"}))\n\t\tdispatchPath(finalPath, state, dispatchState)\n\t\t// dispatch the ammedned path to state to be graphed\n}\n\n\n/* Set error to state when user search a word not found */\nconst catchError = (response, state, dispatchState) => {\n\t\t//console.log(\"got to cath error:\")\n\t\t//console.log(response)\n\t\tif(response instanceof Array){\n\t\t\t\tlet foundWords = []\n\t\t\t\t//console.log(\"words was not found\")\n\t\t\t\t// if it has the response for many words\n\t\t\t\tresponse.forEach((word, index, words) => {\n\t\t\t\t\t\tif(word.detail === \"Not Found.\"){\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word.w_id});\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfoundWords.push(word);\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn foundWords;\n\t\t}else{ // if it only one elment\n\t\t\t\tif(response.detail === \"Not found.\") {\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: state.searchTerm});\n\t\t\t\t\t\tthrow new Error(\"word not found\");\n\t\t\t\t}else if(response.detail === \"Path not found.\"){\n\t\t\t\t\t\t// if the error is path not found\n\t\t\t\t\t\t//console.log(\"path was not found\")\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t'first': response.first,\n\t\t\t\t\t\t\t\t\t\t'last': response.last, }})\n\t\t\t\t\t\tthrow new Error(\"path not found\");\n\t\t\t\t}else{\n\t\t\t\t\t\treturn response\n\t\t\t\t}\n\t\t}\n}\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
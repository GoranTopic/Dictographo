{"ast":null,"code":"module.exports = merge;\n/**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in \n * options\n *\n * @returns {Object} merged object\n */\n\nfunction merge(target, options) {\n  var key;\n\n  if (!target) {\n    target = {};\n  }\n\n  if (options) {\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        var targetHasIt = target.hasOwnProperty(key),\n            optionsValueType = typeof options[key],\n            shouldReplace = !targetHasIt || typeof target[key] !== optionsValueType;\n\n        if (shouldReplace) {\n          target[key] = options[key];\n        } else if (optionsValueType === 'object') {\n          // go deep, don't care about loops here, we are simple API!:\n          target[key] = merge(target[key], options[key]);\n        }\n      }\n    }\n  }\n\n  return target;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.merge/index.js"],"names":["module","exports","merge","target","options","key","hasOwnProperty","targetHasIt","optionsValueType","shouldReplace"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AAEA;;;;;;;;AAOA,SAASA,KAAT,CAAeC,MAAf,EAAuBC,OAAvB,EAAgC;AAC9B,MAAIC,GAAJ;;AACA,MAAI,CAACF,MAAL,EAAa;AAAEA,IAAAA,MAAM,GAAG,EAAT;AAAc;;AAC7B,MAAIC,OAAJ,EAAa;AACX,SAAKC,GAAL,IAAYD,OAAZ,EAAqB;AACnB,UAAIA,OAAO,CAACE,cAAR,CAAuBD,GAAvB,CAAJ,EAAiC;AAC/B,YAAIE,WAAW,GAAGJ,MAAM,CAACG,cAAP,CAAsBD,GAAtB,CAAlB;AAAA,YACIG,gBAAgB,GAAG,OAAOJ,OAAO,CAACC,GAAD,CADrC;AAAA,YAEII,aAAa,GAAG,CAACF,WAAD,IAAiB,OAAOJ,MAAM,CAACE,GAAD,CAAb,KAAuBG,gBAF5D;;AAIA,YAAIC,aAAJ,EAAmB;AACjBN,UAAAA,MAAM,CAACE,GAAD,CAAN,GAAcD,OAAO,CAACC,GAAD,CAArB;AACD,SAFD,MAEO,IAAIG,gBAAgB,KAAK,QAAzB,EAAmC;AACxC;AACAL,UAAAA,MAAM,CAACE,GAAD,CAAN,GAAcH,KAAK,CAACC,MAAM,CAACE,GAAD,CAAP,EAAcD,OAAO,CAACC,GAAD,CAArB,CAAnB;AACD;AACF;AACF;AACF;;AAED,SAAOF,MAAP;AACD","sourcesContent":["module.exports = merge;\n\n/**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in \n * options\n *\n * @returns {Object} merged object\n */\nfunction merge(target, options) {\n  var key;\n  if (!target) { target = {}; }\n  if (options) {\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        var targetHasIt = target.hasOwnProperty(key),\n            optionsValueType = typeof options[key],\n            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n\n        if (shouldReplace) {\n          target[key] = options[key];\n        } else if (optionsValueType === 'object') {\n          // go deep, don't care about loops here, we are simple API!:\n          target[key] = merge(target[key], options[key]);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * Normalise an SVG path to absolute coordinates\n * and full commands, rather than relative coordinates\n * and/or shortcut commands.\n */\nexport default function normalizePath(d) {\n  // preprocess \"d\" so that we have spaces between values\n  d = d.replace(/,/g, \" \") // replace commas with spaces\n  .replace(/-/g, \" - \") // add spacing around minus signs\n  .replace(/-\\s+/g, \"-\") // remove spacing to the right of minus signs.\n  .replace(/([a-zA-Z])/g, \" $1 \"); // set up the variables used in this function\n\n  var instructions = d.replace(/([a-zA-Z])\\s?/g, \"|$1\").split(\"|\"),\n      instructionLength = instructions.length;\n  var i,\n      instruction,\n      op,\n      lop,\n      args = [],\n      alen,\n      a,\n      sx = 0,\n      sy = 0,\n      x = 0,\n      y = 0,\n      cx = 0,\n      cy = 0,\n      cx2 = 0,\n      cy2 = 0,\n      rx = 0,\n      ry = 0,\n      xrot = 0,\n      lflag = 0,\n      sweep = 0,\n      normalized = \"\"; // we run through the instruction list starting at 1, not 0,\n  // because we split up \"|M x y ....\" so the first element will\n  // always be an empty string. By design.\n\n  for (i = 1; i < instructionLength; i++) {\n    // which instruction is this?\n    instruction = instructions[i];\n    op = instruction.substring(0, 1);\n    lop = op.toLowerCase(); // what are the arguments? note that we need to convert\n    // all strings into numbers, or + will do silly things.\n\n    args = instruction.replace(op, \"\").trim().split(\" \");\n    args = args.filter(function (v) {\n      return v !== \"\";\n    }).map(parseFloat);\n    alen = args.length; // we could use a switch, but elaborate code in a \"case\" with\n    // fallthrough is just horrid to read. So let's use ifthen\n    // statements instead.\n    // moveto command (plus possible lineto)\n\n    if (lop === \"m\") {\n      normalized += \"M \";\n\n      if (op === \"m\") {\n        x += args[0];\n        y += args[1];\n      } else {\n        x = args[0];\n        y = args[1];\n      } // records start position, for dealing\n      // with the shape close operator ('Z')\n\n\n      sx = x;\n      sy = y;\n      normalized += x + \" \" + y + \" \";\n\n      if (alen > 2) {\n        for (a = 0; a < alen; a += 2) {\n          if (op === \"m\") {\n            x += args[a];\n            y += args[a + 1];\n          } else {\n            x = args[a];\n            y = args[a + 1];\n          }\n\n          normalized += \"L \" + x + \" \" + y + \" \";\n        }\n      }\n    } // lineto commands\n    else if (lop === \"l\") {\n        for (a = 0; a < alen; a += 2) {\n          if (op === \"l\") {\n            x += args[a];\n            y += args[a + 1];\n          } else {\n            x = args[a];\n            y = args[a + 1];\n          }\n\n          normalized += \"L \" + x + \" \" + y + \" \";\n        }\n      } else if (lop === \"h\") {\n        for (a = 0; a < alen; a++) {\n          if (op === \"h\") {\n            x += args[a];\n          } else {\n            x = args[a];\n          }\n\n          normalized += \"L \" + x + \" \" + y + \" \";\n        }\n      } else if (lop === \"v\") {\n        for (a = 0; a < alen; a++) {\n          if (op === \"v\") {\n            y += args[a];\n          } else {\n            y = args[a];\n          }\n\n          normalized += \"L \" + x + \" \" + y + \" \";\n        }\n      } // quadratic curveto commands\n      else if (lop === \"q\") {\n          for (a = 0; a < alen; a += 4) {\n            if (op === \"q\") {\n              cx = x + args[a];\n              cy = y + args[a + 1];\n              x += args[a + 2];\n              y += args[a + 3];\n            } else {\n              cx = args[a];\n              cy = args[a + 1];\n              x = args[a + 2];\n              y = args[a + 3];\n            }\n\n            normalized += \"Q \" + cx + \" \" + cy + \" \" + x + \" \" + y + \" \";\n          }\n        } else if (lop === \"t\") {\n          for (a = 0; a < alen; a += 2) {\n            // reflect previous cx/cy over x/y\n            cx = x + (x - cx);\n            cy = y + (y - cy); // then get real end point\n\n            if (op === \"t\") {\n              x += args[a];\n              y += args[a + 1];\n            } else {\n              x = args[a];\n              y = args[a + 1];\n            }\n\n            normalized += \"Q \" + cx + \" \" + cy + \" \" + x + \" \" + y + \" \";\n          }\n        } // cubic curveto commands\n        else if (lop === \"c\") {\n            for (a = 0; a < alen; a += 6) {\n              if (op === \"c\") {\n                cx = x + args[a];\n                cy = y + args[a + 1];\n                cx2 = x + args[a + 2];\n                cy2 = y + args[a + 3];\n                x += args[a + 4];\n                y += args[a + 5];\n              } else {\n                cx = args[a];\n                cy = args[a + 1];\n                cx2 = args[a + 2];\n                cy2 = args[a + 3];\n                x = args[a + 4];\n                y = args[a + 5];\n              }\n\n              normalized += \"C \" + cx + \" \" + cy + \" \" + cx2 + \" \" + cy2 + \" \" + x + \" \" + y + \" \";\n            }\n          } else if (lop === \"s\") {\n            for (a = 0; a < alen; a += 4) {\n              // reflect previous cx2/cy2 over x/y\n              cx = x + (x - cx2);\n              cy = y + (y - cy2); // then get real control and end point\n\n              if (op === \"s\") {\n                cx2 = x + args[a];\n                cy2 = y + args[a + 1];\n                x += args[a + 2];\n                y += args[a + 3];\n              } else {\n                cx2 = args[a];\n                cy2 = args[a + 1];\n                x = args[a + 2];\n                y = args[a + 3];\n              }\n\n              normalized += \"C \" + cx + \" \" + cy + \" \" + cx2 + \" \" + cy2 + \" \" + x + \" \" + y + \" \";\n            }\n          } //   rx ry x-axis-rotation large-arc-flag sweep-flag  x   y\n          // a 25,25             -30              0,         1 50,-25\n          // arc command\n          else if (lop === \"a\") {\n              for (a = 0; a < alen; a += 7) {\n                rx = args[a];\n                ry = args[a + 1];\n                xrot = args[a + 2];\n                lflag = args[a + 3];\n                sweep = args[a + 4];\n\n                if (op === \"a\") {\n                  x += args[a + 5];\n                  y += args[a + 6];\n                } else {\n                  x = args[a + 5];\n                  y = args[a + 6];\n                }\n\n                normalized += \"A \" + rx + \" \" + ry + \" \" + xrot + \" \" + lflag + \" \" + sweep + \" \" + x + \" \" + y + \" \";\n              }\n            } else if (lop === \"z\") {\n              normalized += \"Z \"; // not unimportant: path closing changes the current x/y coordinate\n\n              x = sx;\n              y = sy;\n            }\n  }\n\n  return normalized.trim();\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/bezier-js/lib/normalise-svg.js"],"names":["normalizePath","d","replace","instructions","split","instructionLength","length","i","instruction","op","lop","args","alen","a","sx","sy","x","y","cx","cy","cx2","cy2","rx","ry","xrot","lflag","sweep","normalized","substring","toLowerCase","trim","filter","v","map","parseFloat"],"mappings":"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","sourcesContent":["/**\n * Normalise an SVG path to absolute coordinates\n * and full commands, rather than relative coordinates\n * and/or shortcut commands.\n */\nexport default function normalizePath(d) {\n  // preprocess \"d\" so that we have spaces between values\n  d = d\n    .replace(/,/g, \" \") // replace commas with spaces\n    .replace(/-/g, \" - \") // add spacing around minus signs\n    .replace(/-\\s+/g, \"-\") // remove spacing to the right of minus signs.\n    .replace(/([a-zA-Z])/g, \" $1 \");\n\n  // set up the variables used in this function\n  const instructions = d.replace(/([a-zA-Z])\\s?/g, \"|$1\").split(\"|\"),\n    instructionLength = instructions.length;\n\n  let i,\n    instruction,\n    op,\n    lop,\n    args = [],\n    alen,\n    a,\n    sx = 0,\n    sy = 0,\n    x = 0,\n    y = 0,\n    cx = 0,\n    cy = 0,\n    cx2 = 0,\n    cy2 = 0,\n    rx = 0,\n    ry = 0,\n    xrot = 0,\n    lflag = 0,\n    sweep = 0,\n    normalized = \"\";\n\n  // we run through the instruction list starting at 1, not 0,\n  // because we split up \"|M x y ....\" so the first element will\n  // always be an empty string. By design.\n  for (i = 1; i < instructionLength; i++) {\n    // which instruction is this?\n    instruction = instructions[i];\n    op = instruction.substring(0, 1);\n    lop = op.toLowerCase();\n\n    // what are the arguments? note that we need to convert\n    // all strings into numbers, or + will do silly things.\n    args = instruction.replace(op, \"\").trim().split(\" \");\n    args = args\n      .filter(function (v) {\n        return v !== \"\";\n      })\n      .map(parseFloat);\n    alen = args.length;\n\n    // we could use a switch, but elaborate code in a \"case\" with\n    // fallthrough is just horrid to read. So let's use ifthen\n    // statements instead.\n\n    // moveto command (plus possible lineto)\n    if (lop === \"m\") {\n      normalized += \"M \";\n      if (op === \"m\") {\n        x += args[0];\n        y += args[1];\n      } else {\n        x = args[0];\n        y = args[1];\n      }\n      // records start position, for dealing\n      // with the shape close operator ('Z')\n      sx = x;\n      sy = y;\n      normalized += x + \" \" + y + \" \";\n      if (alen > 2) {\n        for (a = 0; a < alen; a += 2) {\n          if (op === \"m\") {\n            x += args[a];\n            y += args[a + 1];\n          } else {\n            x = args[a];\n            y = args[a + 1];\n          }\n          normalized += \"L \" + x + \" \" + y + \" \";\n        }\n      }\n    }\n\n    // lineto commands\n    else if (lop === \"l\") {\n      for (a = 0; a < alen; a += 2) {\n        if (op === \"l\") {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n        normalized += \"L \" + x + \" \" + y + \" \";\n      }\n    } else if (lop === \"h\") {\n      for (a = 0; a < alen; a++) {\n        if (op === \"h\") {\n          x += args[a];\n        } else {\n          x = args[a];\n        }\n        normalized += \"L \" + x + \" \" + y + \" \";\n      }\n    } else if (lop === \"v\") {\n      for (a = 0; a < alen; a++) {\n        if (op === \"v\") {\n          y += args[a];\n        } else {\n          y = args[a];\n        }\n        normalized += \"L \" + x + \" \" + y + \" \";\n      }\n    }\n\n    // quadratic curveto commands\n    else if (lop === \"q\") {\n      for (a = 0; a < alen; a += 4) {\n        if (op === \"q\") {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n        normalized += \"Q \" + cx + \" \" + cy + \" \" + x + \" \" + y + \" \";\n      }\n    } else if (lop === \"t\") {\n      for (a = 0; a < alen; a += 2) {\n        // reflect previous cx/cy over x/y\n        cx = x + (x - cx);\n        cy = y + (y - cy);\n        // then get real end point\n        if (op === \"t\") {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n        normalized += \"Q \" + cx + \" \" + cy + \" \" + x + \" \" + y + \" \";\n      }\n    }\n\n    // cubic curveto commands\n    else if (lop === \"c\") {\n      for (a = 0; a < alen; a += 6) {\n        if (op === \"c\") {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          cx2 = x + args[a + 2];\n          cy2 = y + args[a + 3];\n          x += args[a + 4];\n          y += args[a + 5];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          cx2 = args[a + 2];\n          cy2 = args[a + 3];\n          x = args[a + 4];\n          y = args[a + 5];\n        }\n        normalized +=\n          \"C \" +\n          cx +\n          \" \" +\n          cy +\n          \" \" +\n          cx2 +\n          \" \" +\n          cy2 +\n          \" \" +\n          x +\n          \" \" +\n          y +\n          \" \";\n      }\n    } else if (lop === \"s\") {\n      for (a = 0; a < alen; a += 4) {\n        // reflect previous cx2/cy2 over x/y\n        cx = x + (x - cx2);\n        cy = y + (y - cy2);\n        // then get real control and end point\n        if (op === \"s\") {\n          cx2 = x + args[a];\n          cy2 = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx2 = args[a];\n          cy2 = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n        normalized +=\n          \"C \" +\n          cx +\n          \" \" +\n          cy +\n          \" \" +\n          cx2 +\n          \" \" +\n          cy2 +\n          \" \" +\n          x +\n          \" \" +\n          y +\n          \" \";\n      }\n    }\n\n    //   rx ry x-axis-rotation large-arc-flag sweep-flag  x   y\n    // a 25,25             -30              0,         1 50,-25\n\n    // arc command\n    else if (lop === \"a\") {\n      for (a = 0; a < alen; a += 7) {\n        rx = args[a];\n        ry = args[a + 1];\n        xrot = args[a + 2];\n        lflag = args[a + 3];\n        sweep = args[a + 4];\n        if (op === \"a\") {\n          x += args[a + 5];\n          y += args[a + 6];\n        } else {\n          x = args[a + 5];\n          y = args[a + 6];\n        }\n        normalized +=\n          \"A \" +\n          rx +\n          \" \" +\n          ry +\n          \" \" +\n          xrot +\n          \" \" +\n          lflag +\n          \" \" +\n          sweep +\n          \" \" +\n          x +\n          \" \" +\n          y +\n          \" \";\n      }\n    } else if (lop === \"z\") {\n      normalized += \"Z \";\n      // not unimportant: path closing changes the current x/y coordinate\n      x = sx;\n      y = sy;\n    }\n  }\n  return normalized.trim();\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _construct from \"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport normalise from \"./normalise-svg.js\";\nvar M = {\n  x: false,\n  y: false\n};\n/**\n * ...\n */\n\nfunction makeBezier(Bezier, term, values) {\n  if (term === \"Z\") return;\n\n  if (term === \"M\") {\n    M = {\n      x: values[0],\n      y: values[1]\n    };\n    return;\n  }\n\n  var curve = _construct(Bezier, [M.x, M.y].concat(_toConsumableArray(values)));\n\n  var last = values.slice(-2);\n  M = {\n    x: last[0],\n    y: last[1]\n  };\n  return curve;\n}\n/**\n * ...\n */\n\n\nfunction convertPath(Bezier, d) {\n  var terms = normalise(d).split(\" \"),\n      matcher = new RegExp(\"[MLCQZ]\", \"\");\n  var term,\n      segment,\n      values,\n      segments = [],\n      ARGS = {\n    C: 6,\n    Q: 4,\n    L: 2,\n    M: 2\n  };\n\n  while (terms.length) {\n    term = terms.splice(0, 1)[0];\n\n    if (matcher.test(term)) {\n      values = terms.splice(0, ARGS[term]).map(parseFloat);\n      segment = makeBezier(Bezier, term, values);\n      if (segment) segments.push(segment);\n    }\n  }\n\n  return new Bezier.PolyBezier(segments);\n}\n\nexport { convertPath };","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/bezier-js/lib/svg-to-beziers.js"],"names":["normalise","M","x","y","makeBezier","Bezier","term","values","curve","last","slice","convertPath","d","terms","split","matcher","RegExp","segment","segments","ARGS","C","Q","L","length","splice","test","map","parseFloat","push","PolyBezier"],"mappings":";;AAAA,OAAOA,SAAP,MAAsB,oBAAtB;AAEA,IAAIC,CAAC,GAAG;AAAEC,EAAAA,CAAC,EAAE,KAAL;AAAYC,EAAAA,CAAC,EAAE;AAAf,CAAR;AAEA;;;;AAGA,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkCC,MAAlC,EAA0C;AACxC,MAAID,IAAI,KAAK,GAAb,EAAkB;;AAClB,MAAIA,IAAI,KAAK,GAAb,EAAkB;AAChBL,IAAAA,CAAC,GAAG;AAAEC,MAAAA,CAAC,EAAEK,MAAM,CAAC,CAAD,CAAX;AAAgBJ,MAAAA,CAAC,EAAEI,MAAM,CAAC,CAAD;AAAzB,KAAJ;AACA;AACD;;AACD,MAAMC,KAAK,cAAOH,MAAP,GAAcJ,CAAC,CAACC,CAAhB,EAAmBD,CAAC,CAACE,CAArB,4BAA2BI,MAA3B,GAAX;;AACA,MAAME,IAAI,GAAGF,MAAM,CAACG,KAAP,CAAa,CAAC,CAAd,CAAb;AACAT,EAAAA,CAAC,GAAG;AAAEC,IAAAA,CAAC,EAAEO,IAAI,CAAC,CAAD,CAAT;AAAcN,IAAAA,CAAC,EAAEM,IAAI,CAAC,CAAD;AAArB,GAAJ;AACA,SAAOD,KAAP;AACD;AAED;;;;;AAGA,SAASG,WAAT,CAAqBN,MAArB,EAA6BO,CAA7B,EAAgC;AAC9B,MAAMC,KAAK,GAAGb,SAAS,CAACY,CAAD,CAAT,CAAaE,KAAb,CAAmB,GAAnB,CAAd;AAAA,MACEC,OAAO,GAAG,IAAIC,MAAJ,CAAW,SAAX,EAAsB,EAAtB,CADZ;AAGA,MAAIV,IAAJ;AAAA,MACEW,OADF;AAAA,MAEEV,MAFF;AAAA,MAGEW,QAAQ,GAAG,EAHb;AAAA,MAIEC,IAAI,GAAG;AAAEC,IAAAA,CAAC,EAAE,CAAL;AAAQC,IAAAA,CAAC,EAAE,CAAX;AAAcC,IAAAA,CAAC,EAAE,CAAjB;AAAoBrB,IAAAA,CAAC,EAAE;AAAvB,GAJT;;AAMA,SAAOY,KAAK,CAACU,MAAb,EAAqB;AACnBjB,IAAAA,IAAI,GAAGO,KAAK,CAACW,MAAN,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAAP;;AACA,QAAIT,OAAO,CAACU,IAAR,CAAanB,IAAb,CAAJ,EAAwB;AACtBC,MAAAA,MAAM,GAAGM,KAAK,CAACW,MAAN,CAAa,CAAb,EAAgBL,IAAI,CAACb,IAAD,CAApB,EAA4BoB,GAA5B,CAAgCC,UAAhC,CAAT;AACAV,MAAAA,OAAO,GAAGb,UAAU,CAACC,MAAD,EAASC,IAAT,EAAeC,MAAf,CAApB;AACA,UAAIU,OAAJ,EAAaC,QAAQ,CAACU,IAAT,CAAcX,OAAd;AACd;AACF;;AAED,SAAO,IAAIZ,MAAM,CAACwB,UAAX,CAAsBX,QAAtB,CAAP;AACD;;AAED,SAASP,WAAT","sourcesContent":["import normalise from \"./normalise-svg.js\";\n\nlet M = { x: false, y: false };\n\n/**\n * ...\n */\nfunction makeBezier(Bezier, term, values) {\n  if (term === \"Z\") return;\n  if (term === \"M\") {\n    M = { x: values[0], y: values[1] };\n    return;\n  }\n  const curve = new Bezier(M.x, M.y, ...values);\n  const last = values.slice(-2);\n  M = { x: last[0], y: last[1] };\n  return curve;\n}\n\n/**\n * ...\n */\nfunction convertPath(Bezier, d) {\n  const terms = normalise(d).split(\" \"),\n    matcher = new RegExp(\"[MLCQZ]\", \"\");\n\n  let term,\n    segment,\n    values,\n    segments = [],\n    ARGS = { C: 6, Q: 4, L: 2, M: 2 };\n\n  while (terms.length) {\n    term = terms.splice(0, 1)[0];\n    if (matcher.test(term)) {\n      values = terms.splice(0, ARGS[term]).map(parseFloat);\n      segment = makeBezier(Bezier, term, values);\n      if (segment) segments.push(segment);\n    }\n  }\n\n  return new Bezier.PolyBezier(segments);\n}\n\nexport { convertPath };\n"]},"metadata":{},"sourceType":"module"}
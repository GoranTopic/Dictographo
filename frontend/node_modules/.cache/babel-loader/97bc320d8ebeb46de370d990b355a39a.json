{"ast":null,"code":"import _toConsumableArray from\"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/telix/dictographo/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{colors,API_ENDPOINT}from\"./myConfig\";import{getRandomInt}from\"./Components/RandomGenerator\";/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */ /* \n * Functions for processing single node search and adjacent nodes \n * */var processNode=function processNode(node){/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */node['id']=node.w_id;node['key']=node.w_id;node['isSelected']=false;node['color']=colors.node.default;return node;};/* retrive node with given node id from state */var getNode=function getNode(nodeId,state){return state.nodes.filter(function(node){return node.id===nodeId;})[0];};/* returns true id node is not in state in state, \n * could import time complexity by using a hash table */var isNewNode=function isNewNode(nodeId,state){return state.nodes.every(function(node){return node.id!==nodeId;});};/* when user clicks on a node, query adjacent nodes\n * and set node as selected */var onClickNode=function onClickNode(nodeId,state,dispatchState){queryAdjecentNodes(getNode(nodeId,state),state,dispatchState);dispatchState({type:'SWITCH_SELECTED_NODE',payload:nodeId});};/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/var timelyDispatch=function timelyDispatch(dispatchFunc){var waitTime=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0.5;var random=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;return setTimeout(dispatchFunc,waitTime+getRandomInt(random));};/* reset the graph state and start a new query into a word, \n * sometime this stymes when it is called a second time,\n * this might be because of dispatchState being called twice\n * must investigate.  */var queryNewWord=function queryNewWord(word,state,dispatchState){fetch(API_ENDPOINT+word)// fetch word\n.then(function(result){return(//unpack node\nresult.json());}).then(function(result){return(//check if word was found\ncatchError(result,state,dispatchState));}).then(function(result){return(//process node\nprocessNode(result));}).then(function(node){//dispatch as new word\ndispatchState({type:'SET_NEW_NODE',payload:node});return node;}).then(function(node){return(// get the surrounding words\nqueryAdjecentNodes(node,state,dispatchState));}).catch(function(){return dispatchState({type:'SET_FETCH_FAILED'});});};/* Fetch all the adjancent node of a given node and dispatch */var queryAdjecentNodes=function queryAdjecentNodes(node,state,dispatchState){// define whether we should link te deeper\nvar linkAll=state.isDeepLinks;// define which type of graph we are requesting\nvar graph_type='synonyms/';// fetch nodes\nfetch(API_ENDPOINT+graph_type+node.id).then(function(result){return(// request the synonyms\nresult.json());}).then(function(result){return(// catch erros if there are any\ncatchError(result,state,dispatchState));}).then(function(adjNodes){return adjNodes.forEach(// for every node in the fetched array\nfunction(adjNode){return timelyDispatch(function(){// dispacth timely\n// for each of the nodes in the list \t\t\nadjNode=processNode(adjNode);//process node \n// proces is it is new node, or deep link set\nif(linkAll||isNewNode(adjNode.id,state)){dispatchState({//dispatch node with link node\ntype:'SET_NODE_LINK',payload:{node:adjNode,link:{source:node.id,target:adjNode.id}}});}});});}).catch(function(){return dispatchState({type:'SET_FETCH_FAILED'});});};/* \n * Functions for processing paths of nodes \n *\n * */ /* takes a list of inputs \n * and divied it into pairs */var pairUp=function pairUp(list){var pairs=[];for(var i=0;i+1<=list.length-1;i++){pairs.push({'first':list[i],'last':list[i+1]});}return pairs;};/* gets a list of word and removes the ones which \n * do not checkout in the api.\n * This seemly simple task becomes complex to do \n * with promises*/var removeNotFoundWords=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(words,dispatchState){var foundWords;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:foundWords=new Array(words.lenght);// make a empty array of as long as\n// the origial to mantain the same order\n_context.next=3;return Promise.all(words.map(function(word,index){return(// for every word check the api, \n// await untill all promises are returned\nfetch(API_ENDPOINT+'check/'+word+\"/\").then(function(response){return response.json();}).then(function(response){if(response.detail===\"Found.\"){foundWords[index]=word;}else{dispatchState({type:'SET_WORD_NOT_FOUND',payload:word});}}).catch(function(err){return console.log(err);}));}));case 3:return _context.abrupt(\"return\",foundWords.filter(Boolean));case 4:case\"end\":return _context.stop();}}},_callee);}));return function removeNotFoundWords(_x,_x2){return _ref.apply(this,arguments);};}();/* add foreach node in the path where it comming from,\n\t\t* also adds the color to be graphed */var processPath=function processPath(path,request){var prevNode=null;//declare prev node\nif(path instanceof Array){// only if it is a list \npath.forEach(function(node){node=processNode(node);//might as well process node \n// set the previous node if there was a previous one\nnode['prevNode']=prevNode?prevNode:node.id;// colo if it is reuested\nif(node.word===request.first||node.word===request.last)node['color']=colors.node.selected;// color as selected\n// if it is start of path set first previous to itself\nprevNode=node.id;});}return path;};/* gets a list of pair request for paths an queryes the api \n * then is saves those paths in a order list and returns*/var fetchPathsParts=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(pathRequests,dispatchState){var paths;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:// make an empty array of the same length as request paths\npaths=new Array(pathRequests.length);_context2.next=3;return Promise.all(//wait for all promises to return \npathRequests.map(function(request,index){return fetch(API_ENDPOINT+'path/'+request.first+\"/\"+request.last).then(function(response){return response.json();}).then(function(response){return processPath(response,request);}).then(function(response){if(response.detail===\"Path not found.\"){dispatchState({type:'SET_PATH_NOT_FOUND',payload:request});paths[index]=null;}else{paths[index]=response;}}).catch(function(err){return console.log(err);});}));case 3:return _context2.abrupt(\"return\",paths);case 4:case\"end\":return _context2.stop();}}},_callee2);}));return function fetchPathsParts(_x3,_x4){return _ref2.apply(this,arguments);};}();var amendPath=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(paths){var _marked,getGaps,nextNodeGenerator,bridgeGap,gaps;return _regeneratorRuntime.wrap(function _callee4$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:nextNodeGenerator=function _nextNodeGenerator(start,end,paths){var pathIndex,curPath,nodeIndex,stop;return _regeneratorRuntime.wrap(function nextNodeGenerator$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:pathIndex=end;case 1:if(!(pathIndex<paths.length)){_context3.next=17;break;}curPath=paths[pathIndex];if(!(paths[pathIndex]!==null)){_context3.next=14;break;}nodeIndex=0;case 5:if(!(nodeIndex<curPath.length)){_context3.next=14;break;}_context3.next=8;return curPath[nodeIndex];case 8:stop=_context3.sent;if(!(stop===true)){_context3.next=11;break;}return _context3.abrupt(\"return\",null);case 11:nodeIndex++;_context3.next=5;break;case 14:pathIndex++;_context3.next=1;break;case 17:return _context3.abrupt(\"return\",null);case 18:case\"end\":return _context3.stop();}}},_marked);};_marked=/*#__PURE__*/_regeneratorRuntime.mark(nextNodeGenerator);/* takes a list of paths and is there\n\t\t * is a gap tries to find a connecting path*/getGaps=function getGaps(paths){/* takes a list of paths retusn a list of \n\t\t\t\t * indexes where the gaps are*/var gaps=[];var gap={start:null,end:null};var wasPath=false;var wasGap=false;paths.forEach(function(path,index){if(path===null){// if it is gap\nif(wasPath){// comes from gap\ngap.start=index;//save start\n}// and comes from path\nwasGap=true;// switch to gap\nwasPath=false;}else{//if is path\nif(wasGap){// and comes from gap\ngap.end=index;// record end\ngaps.push(_objectSpread({},gap));//save gap\n}wasPath=true;// switch to path \nwasGap=false;}});return gaps;};bridgeGap=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(start,end,paths){var leftPath,lastWord,gen,curIter,foundBridge;return _regeneratorRuntime.wrap(function _callee3$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:/* gets a set of indexes indicating the gap, \n\t\t\t\t * make fetch request to attempt to find a \n\t\t\t\t * conncetion */ /* generator fuction for trying node to  find a bridge*/leftPath=paths[start-1];// last word in the left side path\nlastWord=leftPath[leftPath.length-1].word;// if there exacly one gap, dont bother chechi\n//let index = (end-start > 1)? 0 : 1; \ngen=nextNodeGenerator(start,end,paths);curIter=gen.next();foundBridge=function foundBridge(response){if(response.detail===\"Path not found.\"){curIter=gen.next();// get the next node\n}else{paths[start]=response;//set the bridge\ncurIter=gen.next(true);//break loop\n}};case 5:if(curIter.done){_context4.next=10;break;}_context4.next=8;return fetch(API_ENDPOINT+'path/'+lastWord+\"/\"+curIter.value.word).then(function(response){return response.json();}).then(function(response){return processPath(response);}).then(foundBridge).catch(function(err){return console.log(err);});case 8:_context4.next=5;break;case 10:case\"end\":return _context4.stop();}}},_callee3);}));return function bridgeGap(_x6,_x7,_x8){return _ref4.apply(this,arguments);};}();gaps=getGaps(paths);_context5.next=7;return Promise.all(gaps.map(function(gap){return bridgeGap(gap.start,gap.end,paths);}));case 7:return _context5.abrupt(\"return\",paths);case 8:case\"end\":return _context5.stop();}}},_callee4);}));return function amendPath(_x5){return _ref3.apply(this,arguments);};}();/* get a list of paths of words, joins them together \n * and dipatches it to state*/var dispatchPath=function dispatchPath(paths,state,dispatchState){var finalPath=[];// declare final array\n//if( paths isIntanceof Array) return null;\npaths=paths.filter(Boolean);// filter any null chars\n// add all paths together\npaths.forEach(function(path){return finalPath.push.apply(finalPath,_toConsumableArray(path));});//console.log(finalPath)\nfinalPath.forEach(function(node,index){return(//for every node in final path\ntimelyDispatch(function(){// dispath in a timely order\n//console.log(state.isEmpty)\nif(index===0){// if this is the first node\ndispatchState({//dipatch as new node\ntype:'SET_NEW_NODE',payload:node});}else{// is not first node\ndispatchState({//if append a node list\ntype:'SET_PATH_NODE',payload:{node:node,link:{target:node.id,source:node.prevNode}}});}}));});};/* gets passesed a set of two words, \n * queries the server for the path and \n * dispateches the result to state */var queryPath=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(words,state,dispatchState){var pathRequests,pathParts,finalPath;return _regeneratorRuntime.wrap(function _callee5$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return removeNotFoundWords(words,dispatchState).catch(function(err){return(//catch error is could not fetch\ndispatchState({type:'SET_ERROR',payload:\"Could not get words\"}));});case 2:words=_context6.sent;// get the list of words and return them in pair\n// w1, w2, w3, w4 => (w1, w2), (w2, w3), (w3, w4)\npathRequests=pairUp(words);// for every pair of words query the api for a path between them\n_context6.next=6;return fetchPathsParts(pathRequests,dispatchState).catch(function(err){return dispatchState({type:'SET_ERROR',//catch error is could not fetch\npayload:\"could not get paths\"});});case 6:pathParts=_context6.sent;_context6.next=9;return amendPath(pathParts).catch(function(err){return dispatchState({type:'SET_ERROR',payload:\"Could not amend path\"});});case 9:finalPath=_context6.sent;dispatchPath(finalPath,state,dispatchState);// dispatch the ammedned path to state to be graphed\ncase 11:case\"end\":return _context6.stop();}}},_callee5);}));return function queryPath(_x9,_x10,_x11){return _ref5.apply(this,arguments);};}();/* Set error to state when user search a word not found */var catchError=function catchError(response,state,dispatchState){//console.log(\"got to cath error:\")\n//console.log(response)\nif(response instanceof Array){var foundWords=[];//console.log(\"words was not found\")\n// if it has the response for many words\nresponse.forEach(function(word,index,words){if(word.detail===\"Not Found.\"){dispatchState({type:'SET_WORD_NOT_FOUND',payload:word.w_id});}else{foundWords.push(word);}});return foundWords;}else{// if it only one elment\nif(response.detail===\"Not found.\"){dispatchState({type:'SET_WORD_NOT_FOUND',payload:state.searchTerm});throw new Error(\"word not found\");}else if(response.detail===\"Path not found.\"){// if the error is path not found\n//console.log(\"path was not found\")\ndispatchState({type:'SET_PATH_NOT_FOUND',payload:{'first':response.first,'last':response.last}});throw new Error(\"path not found\");}else{return response;}}};var onMouseOverNode=function onMouseOverNode(nodeId,dispatchState){dispatchState({type:'SET_DEFINED_NODE',payload:nodeId});// need to fund a way to also run the default fuction \n};export{processNode,catchError,queryNewWord,queryAdjecentNodes,queryPath,onClickNode,onMouseOverNode};","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/node_functions.js"],"names":["colors","API_ENDPOINT","getRandomInt","processNode","node","w_id","default","getNode","nodeId","state","nodes","filter","id","isNewNode","every","onClickNode","dispatchState","queryAdjecentNodes","type","payload","timelyDispatch","dispatchFunc","waitTime","random","setTimeout","queryNewWord","word","fetch","then","result","json","catchError","catch","linkAll","isDeepLinks","graph_type","adjNodes","forEach","adjNode","link","source","target","pairUp","list","pairs","i","length","push","removeNotFoundWords","words","foundWords","Array","lenght","Promise","all","map","index","response","detail","err","console","log","Boolean","processPath","path","request","prevNode","first","last","selected","fetchPathsParts","pathRequests","paths","amendPath","nextNodeGenerator","start","end","pathIndex","curPath","nodeIndex","stop","getGaps","gaps","gap","wasPath","wasGap","bridgeGap","leftPath","lastWord","gen","curIter","next","foundBridge","done","value","dispatchPath","finalPath","queryPath","pathParts","searchTerm","Error","onMouseOverNode"],"mappings":"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","sourcesContent":["import { colors, API_ENDPOINT }  from \"./myConfig\";\nimport { getRandomInt }  from \"./Components/RandomGenerator\";\n\n/*\n * ==================================================\n *      Functions Definnitions for handeling changes\n * ==================================================\n * \n */\n\n/* \n * Functions for processing single node search and adjacent nodes \n * */\n\nconst processNode = (node) =>{\n\t\t/* process a node from the api into one for the dispatcher\n\t\t * it changes title for id, for instance */\n\t\tnode['id'] = node.w_id;\n\t\tnode['key'] = node.w_id;\n\t\tnode['isSelected'] = false;\n\t\tnode['color'] = colors.node.default;\n\t\treturn node\n}\n\n/* retrive node with given node id from state */\nconst getNode = (nodeId, state) => \n\t\tstate.nodes.filter( node => \n\t\t\t\tnode.id === nodeId )[0]\n\n/* returns true id node is not in state in state, \n * could import time complexity by using a hash table */\nconst isNewNode = (nodeId, state) => \n\t\tstate.nodes.every( node => node.id !== nodeId )\n\n/* when user clicks on a node, query adjacent nodes\n * and set node as selected */\nconst onClickNode = (nodeId, state, dispatchState) => {\n\t\tqueryAdjecentNodes(getNode(nodeId, state), state, dispatchState)\n\t\tdispatchState({type:'SWITCH_SELECTED_NODE', payload: nodeId})};\n\n/* takes a dispachState functions and dispaches it in a \n\t * random timply fashion this is usefulf for node not to \n\t * appear all at once in the graph and make it easier on \n\t * the browser. Returns nothing*/\nconst timelyDispatch = (dispatchFunc , waitTime=0.5, random=0) => \n\t\tsetTimeout(dispatchFunc, waitTime + getRandomInt(random));\n\n/* reset the graph state and start a new query into a word, \n * sometime this stymes when it is called a second time,\n * this might be because of dispatchState being called twice\n * must investigate.  */\nconst queryNewWord = (word, state, dispatchState) => {\n\t\tfetch(API_ENDPOINT + word) // fetch word\n\t\t\t\t.then(result => //unpack node\n\t\t\t\t\t\tresult.json())\n\t\t\t\t.then(result => //check if word was found\n\t\t\t\t\t\tcatchError(result, state, dispatchState)) \n\t\t\t\t.then(result => //process node\n\t\t\t\t\t\tprocessNode(result)) \n\t\t\t\t.then(node => { //dispatch as new word\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\tpayload: node\n\t\t\t\t\t\t}); \n\t\t\t\t\t\treturn node; })\n\t\t\t\t.then(node => // get the surrounding words\n\t\t\t\t\t\tqueryAdjecentNodes(node, state, dispatchState))\n\t\t\t\t.catch(() => \n\t\t\t\t\t\tdispatchState({type:'SET_FETCH_FAILED'}));\n}\n\n/* Fetch all the adjancent node of a given node and dispatch */\nconst queryAdjecentNodes = (node, state, dispatchState) => {\n\t\t// define whether we should link te deeper\n\t\tlet linkAll = state.isDeepLinks;\n\t\t// define which type of graph we are requesting\n\t\tlet graph_type = 'synonyms/';\n\t\t// fetch nodes\n\t\tfetch(API_ENDPOINT + graph_type + node.id )\n\t\t\t\t.then(result =>// request the synonyms\n\t\t\t\t\t\tresult.json())\n\t\t\t\t\t\t.then(result =>// catch erros if there are any\n\t\t\t\t\t\t\t\tcatchError(result, state, dispatchState))\n\t\t\t\t\t\t.then(adjNodes =>  \n\t\t\t\t\t\t\t\tadjNodes.forEach(// for every node in the fetched array\n\t\t\t\t\t\t\t\t\t\tadjNode => timelyDispatch(() => {// dispacth timely\n\t\t\t\t\t\t\t\t\t\t\t\t// for each of the nodes in the list \t\t\n\t\t\t\t\t\t\t\t\t\t\t\tadjNode = processNode(adjNode); //process node \n\t\t\t\t\t\t\t\t\t\t\t\t// proces is it is new node, or deep link set\n\t\t\t\t\t\t\t\t\t\t\t\tif(linkAll || isNewNode(adjNode.id, state)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdispatchState({//dispatch node with link node\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'SET_NODE_LINK', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode: adjNode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.id ,  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: adjNode.id \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\n\t\t\t\t))\n\t\t\t\t.catch(() => dispatchState({type:'SET_FETCH_FAILED'}))\n}\n\n\n/* \n * Functions for processing paths of nodes \n *\n * */\n\n/* takes a list of inputs \n * and divied it into pairs */\nconst pairUp = (list) => {\n\t\tlet pairs = [];\n\t\tfor(let i = 0; i+1 <= list.length - 1; i++)\n\t\t\t\tpairs.push({'first': list[i], 'last':list[i+1]});\n\t\treturn pairs\n}\n\n/* gets a list of word and removes the ones which \n * do not checkout in the api.\n * This seemly simple task becomes complex to do \n * with promises*/\nconst removeNotFoundWords = async (words, dispatchState) => {\n\t\tvar foundWords = new Array(words.lenght)\n\t\t// make a empty array of as long as\n\t\t// the origial to mantain the same order\n\t\tawait Promise.all( words.map( (word, index) => \n\t\t\t\t// for every word check the api, \n\t\t\t\t// await untill all promises are returned\n\t\t\t\tfetch(API_ENDPOINT+'check/'+ word +\"/\")\n\t\t\t\t.then( response => response.json())\n\t\t\t\t.then( response => { \n\t\t\t\t\t\tif(response.detail === \"Found.\"){ \n\t\t\t\t\t\t\t\tfoundWords[index] = word \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype:'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word})\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(err => console.log(err))\n\t\t))\n\t\treturn foundWords.filter( Boolean )\n}\n\n/* add foreach node in the path where it comming from,\n\t\t* also adds the color to be graphed */\nconst processPath = (path, request) =>{\n\t\tlet prevNode = null; //declare prev node\n\t\tif(path instanceof Array){ // only if it is a list \n\t\t\t\tpath.forEach((node) => { \n\t\t\t\t\t\tnode = processNode(node); //might as well process node \n\t\t\t\t\t\t// set the previous node if there was a previous one\n\t\t\t\t\t\tnode['prevNode'] = (prevNode)? prevNode : node.id;\n\t\t\t\t\t\t// colo if it is reuested\n\t\t\t\t\t\tif(node.word === request.first || node.word === request.last)\n\t\t\t\t\t\t\t\tnode['color'] = colors.node.selected // color as selected\n\t\t\t\t\t\t// if it is start of path set first previous to itself\n\t\t\t\t\t\tprevNode = node.id;\n\t\t\t\t})\n\t\t}\n\t\treturn path\n}\n\n\n/* gets a list of pair request for paths an queryes the api \n * then is saves those paths in a order list and returns*/\nconst fetchPathsParts = async (pathRequests, dispatchState) => {\n\t\t// make an empty array of the same length as request paths\n\t\tvar paths = new Array(pathRequests.length)\n\t\tawait Promise.all( //wait for all promises to return \n\t\t\t\tpathRequests.map((request, index) =>\n\t\t\t\t\t\tfetch(API_ENDPOINT+'path/'+request.first+\"/\"+request.last)\n\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t.then( response => processPath(response, request))\n\t\t\t\t\t\t.then( response => { \n\t\t\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\t\t\ttype:'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\t\t\tpayload: request});\n\t\t\t\t\t\t\t\t\t\tpaths[index] = null;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tpaths[index] = response;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t))\n\t\treturn paths;\n}\n\nconst amendPath = async (paths) => {\n\t\t/* takes a list of paths and is there\n\t\t * is a gap tries to find a connecting path*/\n\t\tconst getGaps = (paths) => {\n\t\t\t\t/* takes a list of paths retusn a list of \n\t\t\t\t * indexes where the gaps are*/\n\t\t\t\tlet gaps = [];\n\t\t\t\tlet gap = {start:null, end:null}\n\t\t\t\tlet wasPath = false;\n\t\t\t\tlet wasGap = false;\n\t\t\t\tpaths.forEach((path, index) => {\n\t\t\t\t\t\tif(path === null ){// if it is gap\n\t\t\t\t\t\t\t\tif(wasPath){  // comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.start = index //save start\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// and comes from path\n\t\t\t\t\t\t\t\twasGap = true; // switch to gap\n\t\t\t\t\t\t\t\twasPath = false \n\t\t\t\t\t\t}else{ //if is path\n\t\t\t\t\t\t\t\tif(wasGap){   // and comes from gap\n\t\t\t\t\t\t\t\t\t\tgap.end = index; // record end\n\t\t\t\t\t\t\t\t\t\tgaps.push({...gap}); //save gap\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\twasPath = true; // switch to path \n\t\t\t\t\t\t\t\twasGap = false;\n\t\t\t\t\t\t}\n\t\t\t\t}) \n\t\t\t\treturn gaps;\n\t\t}\n\n\t\tfunction* nextNodeGenerator(start, end, paths) {\n\t\t\t\t/* makes a generator to go thought the nodes\n\t\t\t\t * which must try to find a bridge*/\n\t\t\t\t// for every path left in paths\n\t\t\t\tfor(let pathIndex = end; pathIndex < paths.length; pathIndex++){\n\t\t\t\t\t\tlet curPath = paths[pathIndex]\n\t\t\t\t\t\tif(paths[pathIndex] !== null){ // if it is not a null path\n\t\t\t\t\t\t\t\t// \tif gap is one length, start at 1, else 0\n\t\t\t\t\t\t\t\t//let index = (end-start > 1)? 0 : 1; \n\t\t\t\t\t\t\t\t// for every node in the current path\n\t\t\t\t\t\t\t\tfor(let nodeIndex = 0; nodeIndex < curPath.length; nodeIndex++){\n\t\t\t\t\t\t\t\t\t\tlet stop = yield curPath[nodeIndex]; // return the current path \n\t\t\t\t\t\t\t\t\t\tif(stop === true) // if the messeage send back is to stop\n\t\t\t\t\t\t\t\t\t\t\t\treturn null; // stop generation\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null; // reached the end\n\t\t}\n\n\n\t\tconst bridgeGap = async (start, end, paths) => {\n\t\t\t\t/* gets a set of indexes indicating the gap, \n\t\t\t\t * make fetch request to attempt to find a \n\t\t\t\t * conncetion */\n\t\t\t\t/* generator fuction for trying node to  find a bridge*/\n\t\t\t\tlet leftPath = paths[start-1];\n\t\t\t\t// last word in the left side path\n\t\t\t\tlet lastWord = leftPath[leftPath.length-1].word;\n\t\t\t\t// if there exacly one gap, dont bother chechi\n\t\t\t\t//let index = (end-start > 1)? 0 : 1; \n\t\t\t\tlet gen = nextNodeGenerator(start, end, paths);\n\t\t\t\tlet curIter = gen.next();\n\t\t\t\tconst foundBridge = (response) =>{\n\t\t\t\t\t\tif(response.detail === \"Path not found.\"){ \n\t\t\t\t\t\t\t\tcurIter = gen.next(); // get the next node\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpaths[start] = response; //set the bridge\n\t\t\t\t\t\t\t\tcurIter = gen.next(true); //break loop\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\twhile(!curIter.done){ // while the bridge is not been found\n\t\t\t\t\t\tawait fetch(API_ENDPOINT+'path/'+lastWord+\"/\"+ curIter.value.word)\n\t\t\t\t\t\t\t\t.then( response => response.json())\n\t\t\t\t\t\t\t\t.then( response => processPath(response))\n\t\t\t\t\t\t\t\t.then( foundBridge )\n\t\t\t\t\t\t\t\t.catch(err => console.log(err))\n\t\t\t\t}\n\t\t}\n\t\tlet gaps = getGaps(paths);\n\t\tawait Promise.all(gaps.map( gap => bridgeGap(gap.start, gap.end, paths)))\n\t\treturn paths;\n}\n\n\n/* get a list of paths of words, joins them together \n * and dipatches it to state*/\nconst dispatchPath = (paths, state, dispatchState) => {\n\t\tlet finalPath = []; // declare final array\n\t\t//if( paths isIntanceof Array) return null;\n\t\t\t\tpaths = paths.filter( Boolean ); // filter any null chars\n\t\t// add all paths together\n\t\tpaths.forEach(path => finalPath.push(...path)) \n\t\t//console.log(finalPath)\n\t\tfinalPath.forEach((node, index) =>//for every node in final path\n\t\t\t\ttimelyDispatch(() => { // dispath in a timely order\n\t\t\t\t\t\t//console.log(state.isEmpty)\n\t\t\t\t\t\tif(index === 0){ // if this is the first node\n\t\t\t\t\t\t\t\tdispatchState({ //dipatch as new node\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_NEW_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: node, })\n\t\t\t\t\t\t}else{ // is not first node\n\t\t\t\t\t\t\t\tdispatchState({ //if append a node list\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_PATH_NODE', \n\t\t\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\t\t\t\t\t\t\tlink: { \n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget: node.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource: node.prevNode, \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t)\n}\n\n/* gets passesed a set of two words, \n * queries the server for the path and \n * dispateches the result to state */\nconst queryPath = async (words, state, dispatchState) => {\n\t\t//first remove all words from the input which are not in api\n\t\twords = await removeNotFoundWords(words, dispatchState)\n\t\t\t\t.catch(err =>  //catch error is could not fetch\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\t\t\tpayload:\"Could not get words\"}));\n\t\t// get the list of words and return them in pair\n\t\t// w1, w2, w3, w4 => (w1, w2), (w2, w3), (w3, w4)\n\t\tlet pathRequests = pairUp(words);\n\t\t// for every pair of words query the api for a path between them\n\t\tlet pathParts = await fetchPathsParts(pathRequests, dispatchState)\n\t\t\t\t.catch(err => \n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype:'SET_ERROR', //catch error is could not fetch\n\t\t\t\t\t\t\t\tpayload: \"could not get paths\"}));\n\t\t// get the final path and attempt to cannect them together\n\t\t// to form one cohesive path\n\t\tlet finalPath = await amendPath(pathParts)\n\t\t.catch(err => \n\t\t\t\tdispatchState({\n\t\t\t\t\t\ttype:'SET_ERROR', \n\t\t\t\t\t\tpayload: \"Could not amend path\"}))\n\t\tdispatchPath(finalPath, state, dispatchState)\n\t\t// dispatch the ammedned path to state to be graphed\n}\n\n\n/* Set error to state when user search a word not found */\nconst catchError = (response, state, dispatchState) => {\n\t\t//console.log(\"got to cath error:\")\n\t\t//console.log(response)\n\t\tif(response instanceof Array){\n\t\t\t\tlet foundWords = []\n\t\t\t\t//console.log(\"words was not found\")\n\t\t\t\t// if it has the response for many words\n\t\t\t\tresponse.forEach((word, index, words) => {\n\t\t\t\t\t\tif(word.detail === \"Not Found.\"){\n\t\t\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\t\t\tpayload: word.w_id});\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfoundWords.push(word);\n\t\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn foundWords;\n\t\t}else{ // if it only one elment\n\t\t\t\tif(response.detail === \"Not found.\") {\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_WORD_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: state.searchTerm});\n\t\t\t\t\t\tthrow new Error(\"word not found\");\n\t\t\t\t}else if(response.detail === \"Path not found.\"){\n\t\t\t\t\t\t// if the error is path not found\n\t\t\t\t\t\t//console.log(\"path was not found\")\n\t\t\t\t\t\tdispatchState({\n\t\t\t\t\t\t\t\ttype: 'SET_PATH_NOT_FOUND', \n\t\t\t\t\t\t\t\tpayload: { \n\t\t\t\t\t\t\t\t\t\t'first': response.first,\n\t\t\t\t\t\t\t\t\t\t'last': response.last, }})\n\t\t\t\t\t\tthrow new Error(\"path not found\");\n\t\t\t\t}else{\n\t\t\t\t\t\treturn response\n\t\t\t\t}\n\t\t}\n}\n\nconst onMouseOverNode = function(nodeId, dispatchState) {\n\t\tdispatchState({type:'SET_DEFINED_NODE', payload: nodeId})  \n\t\t// need to fund a way to also run the default fuction \n};\n\nexport { processNode, catchError, queryNewWord, queryAdjecentNodes, queryPath, onClickNode, onMouseOverNode }\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"const createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {\n    indent: 2\n  })}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {\n    indent: 4\n  })}\n    ${pattern('var v{var} = body.velocity.{var};', {\n    indent: 4\n  })}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {\n    join: ' + '\n  })});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {\n    indent: 6\n  })}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {\n    indent: 4\n  })}\n\n    ${pattern('body.pos.{var} += d{var};', {\n    indent: 4\n  })}\n\n    ${pattern('t{var} += Math.abs(d{var});', {\n    indent: 4\n  })}\n  }\n\n  return (${pattern('t{var} * t{var}', {\n    join: ' + '\n  })})/length;\n`;\n  return code;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.forcelayout/lib/codeGenerators/generateIntegrator.js"],"names":["createPatternBuilder","require","module","exports","generateIntegratorFunction","generateIntegratorFunctionBody","dimension","code","Function","pattern","indent","join"],"mappings":"AAAA,MAAMA,oBAAoB,GAAGC,OAAO,CAAC,wBAAD,CAApC;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,0BAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,8BAAf,GAAgDA,8BAAhD;;AAEA,SAASD,0BAAT,CAAoCE,SAApC,EAA+C;AAC7C,MAAIC,IAAI,GAAGF,8BAA8B,CAACC,SAAD,CAAzC;AACA,SAAO,IAAIE,QAAJ,CAAa,QAAb,EAAuB,UAAvB,EAAmC,wBAAnC,EAA6DD,IAA7D,CAAP;AACD;;AAED,SAASF,8BAAT,CAAwCC,SAAxC,EAAmD;AACjD,MAAIG,OAAO,GAAGT,oBAAoB,CAACM,SAAD,CAAlC;AACA,MAAIC,IAAI,GAAI;;;;IAIVE,OAAO,CAAC,6BAAD,EAAgC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAhC,CAA6C;;;;;;;;;;;;MAYlDD,OAAO,CAAC,kDAAD,EAAqD;AAACC,IAAAA,MAAM,EAAE;AAAT,GAArD,CAAkE;MACzED,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAAmD;wBACxCD,OAAO,CAAC,iBAAD,EAAoB;AAACE,IAAAA,IAAI,EAAE;AAAP,GAApB,CAAmC;;;;;QAK1DF,OAAO,CAAC,mCAAD,EAAsC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAtC,CAAmD;;;MAG5DD,OAAO,CAAC,0CAAD,EAA6C;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA7C,CAA0D;;MAEjED,OAAO,CAAC,2BAAD,EAA8B;AAACC,IAAAA,MAAM,EAAE;AAAT,GAA9B,CAA2C;;MAElDD,OAAO,CAAC,6BAAD,EAAgC;AAACC,IAAAA,MAAM,EAAE;AAAT,GAAhC,CAA6C;;;YAG9CD,OAAO,CAAC,iBAAD,EAAoB;AAACE,IAAAA,IAAI,EAAE;AAAP,GAApB,CAAmC;CAjCpD;AAmCA,SAAOJ,IAAP;AACD","sourcesContent":["const createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {indent: 2})}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {indent: 4})}\n    ${pattern('var v{var} = body.velocity.{var};', {indent: 4})}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {join: ' + '})});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {indent: 6})}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {indent: 4})}\n\n    ${pattern('body.pos.{var} += d{var};', {indent: 4})}\n\n    ${pattern('t{var} += Math.abs(d{var});', {indent: 4})}\n  }\n\n  return (${pattern('t{var} * t{var}', {join: ' + '})})/length;\n`\n  return code;\n}\n"]},"metadata":{},"sourceType":"script"}
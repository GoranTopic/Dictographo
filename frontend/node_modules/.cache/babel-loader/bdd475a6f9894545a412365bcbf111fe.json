{"ast":null,"code":"import { dispatch } from \"d3-dispatch\";\nimport { timer } from \"d3-timer\";\nimport lcg from \"./lcg.js\";\nvar MAX_DIMENSIONS = 3;\nexport function x(d) {\n  return d.x;\n}\nexport function y(d) {\n  return d.y;\n}\nexport function z(d) {\n  return d.z;\n}\nvar initialRadius = 10,\n    initialAngleRoll = Math.PI * (3 - Math.sqrt(5)),\n    // Golden ratio angle\ninitialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221)); // Markov irrational number\n\nexport default function (nodes, numDimensions) {\n  numDimensions = numDimensions || 2;\n  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))),\n      simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = new Map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\"),\n      random = lcg();\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick(iterations) {\n    var i,\n        n = nodes.length,\n        node;\n    if (iterations === undefined) iterations = 1;\n\n    for (var k = 0; k < iterations; ++k) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n      forces.forEach(function (force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;else node.x = node.fx, node.vx = 0;\n\n        if (nDim > 1) {\n          if (node.fy == null) node.y += node.vy *= velocityDecay;else node.y = node.fy, node.vy = 0;\n        }\n\n        if (nDim > 2) {\n          if (node.fz == null) node.z += node.vz *= velocityDecay;else node.z = node.fz, node.vz = 0;\n        }\n      }\n    }\n\n    return simulation;\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if (node.fy != null) node.y = node.fy;\n      if (node.fz != null) node.z = node.fz;\n\n      if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {\n        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i) : nDim > 1 ? Math.sqrt(0.5 + i) : i),\n            rollAngle = i * initialAngleRoll,\n            yawAngle = i * initialAngleYaw;\n\n        if (nDim === 1) {\n          node.x = radius;\n        } else if (nDim === 2) {\n          node.x = radius * Math.cos(rollAngle);\n          node.y = radius * Math.sin(rollAngle);\n        } else {\n          // 3 dimensions: use spherical distribution along 2 irrational number angles\n          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);\n          node.y = radius * Math.cos(rollAngle);\n          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);\n        }\n      }\n\n      if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {\n        node.vx = 0;\n\n        if (nDim > 1) {\n          node.vy = 0;\n        }\n\n        if (nDim > 2) {\n          node.vz = 0;\n        }\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes, nDim, random);\n    return force;\n  }\n\n  initializeNodes();\n  return simulation = {\n    tick: tick,\n    restart: function () {\n      return stepper.restart(step), simulation;\n    },\n    stop: function () {\n      return stepper.stop(), simulation;\n    },\n    numDimensions: function (_) {\n      return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation) : nDim;\n    },\n    nodes: function (_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n    alpha: function (_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n    alphaMin: function (_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n    alphaDecay: function (_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n    alphaTarget: function (_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n    velocityDecay: function (_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n    randomSource: function (_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n    force: function (name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function () {\n      var args = Array.prototype.slice.call(arguments);\n      var x = args.shift() || 0,\n          y = (nDim > 1 ? args.shift() : null) || 0,\n          z = (nDim > 2 ? args.shift() : null) || 0,\n          radius = args.shift() || Infinity;\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          dz,\n          d2,\n          node,\n          closest;\n      radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - (node.y || 0);\n        dz = z - (node.z || 0);\n        d2 = dx * dx + dy * dy + dz * dz;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n    on: function (name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-force-3d/src/simulation.js"],"names":["dispatch","timer","lcg","MAX_DIMENSIONS","x","d","y","z","initialRadius","initialAngleRoll","Math","PI","sqrt","initialAngleYaw","nodes","numDimensions","nDim","min","max","round","simulation","alpha","alphaMin","alphaDecay","pow","alphaTarget","velocityDecay","forces","Map","stepper","step","event","random","tick","call","stop","iterations","i","n","length","node","undefined","k","forEach","force","fx","vx","fy","vy","fz","vz","initializeNodes","index","isNaN","radius","cbrt","rollAngle","yawAngle","cos","sin","initializeForce","initialize","restart","_","arguments","randomSource","name","delete","set","get","find","args","Array","prototype","slice","shift","Infinity","dx","dy","dz","d2","closest","on"],"mappings":"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","sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer} from \"d3-timer\";\nimport lcg from \"./lcg.js\";\n\nvar MAX_DIMENSIONS = 3;\n\nexport function x(d) {\n  return d.x;\n}\n\nexport function y(d) {\n  return d.y;\n}\n\nexport function z(d) {\n  return d.z;\n}\n\nvar initialRadius = 10,\n    initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), // Golden ratio angle\n    initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221)); // Markov irrational number\n\nexport default function(nodes, numDimensions) {\n  numDimensions = numDimensions || 2;\n\n  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))),\n      simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = new Map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\"),\n      random = lcg();\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick(iterations) {\n    var i, n = nodes.length, node;\n\n    if (iterations === undefined) iterations = 1;\n\n    for (var k = 0; k < iterations; ++k) {\n      alpha += (alphaTarget - alpha) * alphaDecay;\n\n      forces.forEach(function (force) {\n        force(alpha);\n      });\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        if (node.fx == null) node.x += node.vx *= velocityDecay;\n        else node.x = node.fx, node.vx = 0;\n        if (nDim > 1) {\n          if (node.fy == null) node.y += node.vy *= velocityDecay;\n          else node.y = node.fy, node.vy = 0;\n        }\n        if (nDim > 2) {\n          if (node.fz == null) node.z += node.vz *= velocityDecay;\n          else node.z = node.fz, node.vz = 0;\n        }\n      }\n    }\n\n    return simulation;\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (node.fx != null) node.x = node.fx;\n      if (node.fy != null) node.y = node.fy;\n      if (node.fz != null) node.z = node.fz;\n      if (isNaN(node.x) || (nDim > 1 && isNaN(node.y)) || (nDim > 2 && isNaN(node.z))) {\n        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i) : (nDim > 1 ? Math.sqrt(0.5 + i) : i)),\n          rollAngle = i * initialAngleRoll,\n          yawAngle = i * initialAngleYaw;\n\n        if (nDim === 1) {\n          node.x = radius;\n        } else if (nDim === 2) {\n          node.x = radius * Math.cos(rollAngle);\n          node.y = radius * Math.sin(rollAngle);\n        } else { // 3 dimensions: use spherical distribution along 2 irrational number angles\n          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);\n          node.y = radius * Math.cos(rollAngle);\n          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);\n        }\n      }\n      if (isNaN(node.vx) || (nDim > 1 && isNaN(node.vy)) || (nDim > 2 && isNaN(node.vz))) {\n        node.vx = 0;\n        if (nDim > 1) { node.vy = 0; }\n        if (nDim > 2) { node.vz = 0; }\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes, nDim, random);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    numDimensions: function(_) {\n      return arguments.length\n          ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation)\n          : nDim;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    randomSource: function(_) {\n      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function() {\n      var args = Array.prototype.slice.call(arguments);\n      var x = args.shift() || 0,\n          y = (nDim > 1 ? args.shift() : null) || 0,\n          z = (nDim > 2 ? args.shift() : null) || 0,\n          radius = args.shift() || Infinity;\n\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          dz,\n          d2,\n          node,\n          closest;\n\n      radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - (node.y || 0);\n        dz = z - (node.z ||0);\n        d2 = dx * dx + dy * dy + dz * dz;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}
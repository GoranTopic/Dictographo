{"ast":null,"code":"var _jsxFileName = \"/home/telix/dictographo/frontend/src/Components/SearchSuggestion/SearchSuggestion.js\";\nimport React, { useState, useEffect } from 'react';\nimport { API_ENDPOINT } from \"../../myConfig\";\nimport useKeypress from '../../hooks/useKeypress';\nimport styles from './SearchSuggestion.css';\nimport { queryNewWord, queryPath } from '../../node_functions';\n/*\n * =======================================\n *      Search suggestion componenet\n * =======================================\n * for predicting  what the user is going to type\n */\n\nlet query_search = 'querysearch/'; //add this to myconfig\n\nfunction SuggestionsContainer(props) {\n  /* tahek a child fro a input an add suggestions to it */\n  // handle the change by seting the state variable to \n  let state = props.state;\n  let dispatchState = props.dispatchState;\n  const [suggestions, setSuggestions] = useState([]);\n  const [selected, setSelected] = useState(1);\n  useKeypress('ArrowDown', () => selected < 0 ? setSelected(suggestions.length - 1) : setSelected(selected + 1));\n  useKeypress('ArrowUp', () => selected > suggestions.length - 1 ? setSelected(0) : setSelected(selected - 1));\n\n  const getmultipleWords = string => {\n    /* determines qhereteher a string \n     * is compossed of multiple words */\n    //remove multiple spaces\n    //trim, remove multiple and seperate by spaces\n    return string.replace(/  +/g, ' ').trim().split(' ');\n  };\n\n  useKeypress('Enter', () => {\n    if (isWrittingWord()) {\n      if (suggestions.length > 0) {\n        addToSearchTerm(suggestions[selected].word);\n      }\n    } else {\n      let words = getmultipleWords(state.searchTerm.toLowerCase()); // set all serches to lowercase\n\n      if (words.length > 1) {\n        //if it has more that two words\n        queryPath(words, state, dispatchState);\n      } else {\n        // if there is only one word\n        queryNewWord(words[0], state, dispatchState);\n      }\n    }\n  });\n\n  const isWrittingWord = () => {\n    /* uses the state to see if\n    \t\t* the user is in the middle of writting a word */\n    let len = state.searchTerm.length;\n    let last = state.searchTerm[state.searchTerm.length - 1];\n\n    if (len === 0) {\n      return false;\n    } else if (last === \" \") {\n      return false;\n    } else return true;\n  };\n\n  const filterSuggestions = suggestions =>\n  /* filter out all words which have spaces */\n  suggestions.filter(suggestion => /\\s/.test(suggestion));\n\n  const addToSearchTerm = word => {\n    /* append a given word to the seate searchTerm */\n    let wordList = state.searchTerm.split(\" \");\n    let len = wordList.length;\n    wordList[len - 1] = word; // set the last word as clicke word\n\n    dispatchState({\n      type: 'SET_SEARCH_TERM',\n      payload: wordList.join(\" \") + \" \"\n    });\n    setSuggestions([]); // reset suggestions\n\n    setSelected(0); // reset selected\n  };\n\n  const onClick = word => addToSearchTerm(word);\n\n  useEffect(() => {\n    /* query server for search suggestionsa\n     * and sets the  */\n    let wordList = state.searchTerm.split(\" \"); //split the search into words\n\n    let len = wordList.length; //get the length\n\n    let last = wordList[len - 1]; //fetch the last element \n\n    fetch(API_ENDPOINT + query_search + last).then(result => result.json()) //unpack suggestions\n    .then(result => {\n      console.log(result);\n      return result;\n    }) //unpack suggestions\n    .then(suggestions => filterSuggestions(suggestions)).then(suggestions => setSuggestions(suggestions)).catch(err => console.log(err));\n  }, [state.searchTerm, dispatchState]);\n\n  const SuggestionList = () => /*#__PURE__*/React.createElement(\"ul\", {\n    class: \"suggestions\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 5\n    }\n  }, suggestions.map((suggestion, index) => {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      key: index,\n      className: index === selected ? \"selected\" : null,\n      onClick: () => onClick(suggestion.word),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 118,\n        columnNumber: 19\n      }\n    }, suggestion.word);\n  }));\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"input\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 14\n    }\n  }, props.children, isWrittingWord() ? /*#__PURE__*/React.createElement(SuggestionList, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 28\n    }\n  }) : /*#__PURE__*/React.createElement(React.Fragment, null));\n}\n\nexport default SuggestionsContainer;","map":{"version":3,"sources":["/home/telix/dictographo/frontend/src/Components/SearchSuggestion/SearchSuggestion.js"],"names":["React","useState","useEffect","API_ENDPOINT","useKeypress","styles","queryNewWord","queryPath","query_search","SuggestionsContainer","props","state","dispatchState","suggestions","setSuggestions","selected","setSelected","length","getmultipleWords","string","replace","trim","split","isWrittingWord","addToSearchTerm","word","words","searchTerm","toLowerCase","len","last","filterSuggestions","filter","suggestion","test","wordList","type","payload","join","onClick","fetch","then","result","json","console","log","catch","err","SuggestionList","map","index","children"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { API_ENDPOINT }  from \"../../myConfig\";\nimport useKeypress from '../../hooks/useKeypress';\nimport styles from './SearchSuggestion.css'; \nimport { queryNewWord, queryPath } from '../../node_functions';\n\n/*\n * =======================================\n *      Search suggestion componenet\n * =======================================\n * for predicting  what the user is going to type\n */\n\nlet query_search = 'querysearch/' //add this to myconfig\n\nfunction SuggestionsContainer(props){\n\t\t/* tahek a child fro a input an add suggestions to it */\n\t\t// handle the change by seting the state variable to \n\t\tlet state = props.state\n\t\tlet dispatchState = props.dispatchState;\n\t\tconst [suggestions, setSuggestions] = useState([])\t\n\t\tconst [selected, setSelected] = useState(1)\t\n\t\t\n\n\t\tuseKeypress('ArrowDown', () =>\n\t\t\t\t(selected < 0)?\n\t\t\t\tsetSelected(suggestions.length-1)\n\t\t\t\t: setSelected(selected + 1)\n\t\t);\n\n\t\tuseKeypress('ArrowUp', () => \n\t\t\t\t(selected > suggestions.length-1)?\n\t\t\t\tsetSelected(0)\n\t\t\t\t:setSelected(selected - 1)\n\t\t);\n\n\n\t\tconst getmultipleWords = (string) => {\n\t\t\t\t/* determines qhereteher a string \n\t\t\t\t * is compossed of multiple words */\n\t\t\t\t//remove multiple spaces\n\t\t\t\t//trim, remove multiple and seperate by spaces\n\t\t\t\treturn string.replace(/  +/g, ' ').trim().split(' ') \n\t\t}\n\n\t\tuseKeypress('Enter', () => {\n\t\t\t\tif(isWrittingWord()){\n\t\t\t\t\t\tif(suggestions.length > 0){\n\t\t\t\t\t\t\t\taddToSearchTerm(suggestions[selected].word);\n\t\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t\tlet words = getmultipleWords(state.searchTerm.toLowerCase());\n\t\t\t\t\t\t// set all serches to lowercase\n\t\t\t\t\t\tif(words.length > 1){\n\t\t\t\t\t\t\t\t//if it has more that two words\n\t\t\t\t\t\t\t\tqueryPath(words, state, dispatchState);\n\t\t\t\t\t\t}else{ \n\t\t\t\t\t\t\t\t// if there is only one word\n\t\t\t\t\t\t\t\tqueryNewWord(words[0], state, dispatchState);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t})\n\n\t\tconst isWrittingWord = () =>{\n\t\t\t\t/* uses the state to see if\n\t\t\t\t\t\t* the user is in the middle of writting a word */\n\t\t\t\tlet len = state.searchTerm.length;\n\t\t\t\tlet last = state.searchTerm[state.searchTerm.length-1];\n\t\t\t\tif(len === 0){ return false;\n\t\t\t\t}else if (last === \" \"){ return false;\n\t\t\t\t}else return true; \n\t\t}\n\n\t\tconst filterSuggestions = suggestions => \n\t\t\t\t/* filter out all words which have spaces */\n\t\t\t\tsuggestions.filter( suggestion => /\\s/.test(suggestion))\n\n\t\t\n\t\tconst addToSearchTerm = (word) => {\n\t\t\t\t/* append a given word to the seate searchTerm */\n\t\t\t\tlet wordList = state.searchTerm.split(\" \");\n\t\t\t\tlet len = wordList.length \n\t\t\t\twordList[len-1] = word // set the last word as clicke word\n\t\t\t\tdispatchState({ \n\t\t\t\t\t\ttype: 'SET_SEARCH_TERM',\n\t\t\t\t\t\tpayload: wordList.join(\" \") + \" \",\n\t\t\t\t});\t\n\t\t\t\tsetSuggestions([]); // reset suggestions\n\t\t\t\tsetSelected(0); // reset selected\n\t\t}\n\n\n\t\tconst onClick = (word) => addToSearchTerm(word);\n\t\t\n\n\t\tuseEffect(() => {\n\t\t\t\t/* query server for search suggestionsa\n\t\t\t\t * and sets the  */\n\t\t\t\tlet wordList = state.searchTerm.split(\" \");\n\t\t\t\t//split the search into words\n\t\t\t\tlet len = wordList.length;\n\t\t\t\t//get the length\n\t\t\t\tlet last = wordList[len-1]\n\t\t\t\t//fetch the last element \n\t\t\t\tfetch(API_ENDPOINT + query_search + last)\n\t\t\t\t\t\t.then(result => result.json()) //unpack suggestions\n\t\t\t\t\t\t.then(result => {console.log(result); return result}) //unpack suggestions\n\t\t\t\t\t\t.then(suggestions => filterSuggestions(suggestions))\n\t\t\t\t\t\t.then(suggestions => setSuggestions(suggestions))\n\t\t\t\t\t\t.catch((err) => console.log(err));\n\t\t}, [state.searchTerm, dispatchState])\n\n\n\t\tconst SuggestionList = () =>\n\t\t\t\t<ul class=\"suggestions\">\n\t\t\t\t\t\t{ suggestions.map(\n\t\t\t\t\t\t\t\t(suggestion, index) => {  \n\t\t\t\t\t\t\t\t\t\treturn  <li \n\t\t\t\t\t\t\t\t\t\t\t\tkey={index} \n\t\t\t\t\t\t\t\t\t\t\t\tclassName={index === selected? \"selected\": null}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => onClick(suggestion.word)}>\n\t\t\t\t\t\t\t\t\t\t\t\t{suggestion.word}\n\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)}\n\t\t\t\t</ul>\n\t\t\t\t\t\treturn <div className=\"input\">\n\t\t\t\t\t\t\t\t{props.children}\n\t\t\t\t\t\t\t\t{isWrittingWord()? <SuggestionList/>: <></> }\n\t\t\t\t\t\t</div>\n}\n\nexport default SuggestionsContainer;\n"]},"metadata":{},"sourceType":"module"}
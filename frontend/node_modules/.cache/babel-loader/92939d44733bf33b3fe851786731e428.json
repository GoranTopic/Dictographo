{"ast":null,"code":"const unselectedNodeColor = '#3D3C3A';\nconst selectedNodeColor = '#E41B17';\nconst pathNodeColor = '#17E0E3'; //const pathLinkColor = '#E41B17'\n// function for getting random num\n\nexport const getRandomInt = max => {\n  return Math.floor(Math.random() * Math.floor(max)) + 1;\n}; // fuction for getting a random string\n\nexport const getRandomStr = length => {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\n  return result;\n}; //generate random link\n\nexport const getRandomLinks = (link_number, word, nodes) => {\n  var seen_targets = [];\n  var links = [];\n\n  for (var i = 0; i < link_number; i++) {\n    var target = nodes[getRandomInt(nodes.length - 1)].id;\n\n    if (!seen_targets.includes(target)) {\n      links.push({\n        source: word,\n        target: target\n      });\n      seen_targets.push(target);\n    }\n  }\n\n  return links;\n}; // Generate a random node \n\nexport const genRandomNode = nodes => {\n  var title = getRandomStr(6);\n  var links = getRandomLinks(getRandomInt(6), title, nodes);\n  return {\n    node: {\n      id: title\n    },\n    links\n  };\n}; // generate a list of grapth recursibly\n\nexport const genGrapNodes = (word, depth = 0, data = []) => {\n  for (var i = 0; i < getRandomInt(3); i++) {\n    var adjacent_word = getRandomStr(8);\n    data.push({\n      node: {\n        id: adjacent_word\n      },\n      links: [{\n        source: word,\n        target: adjacent_word\n      }]\n    });\n    if (depth > 0) genGrapNodes(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};\nexport const makeNewNode = (prevNode, newNode, path = false, selected = false) => {\n  var color = path ? pathNodeColor : selected ? selectedNodeColor : unselectedNodeColor;\n  return {\n    node: {\n      id: newNode,\n      color: color\n    },\n    links: [{\n      source: prevNode,\n      target: newNode,\n      color: color\n    }]\n  };\n}; // Generate a Nodes path from  node to the other\n\nexport const genPath = (start, destination) => {\n  let distance = getRandomInt(10) + 5;\n  let currentNode = start;\n  let data = [];\n  data.push({\n    node: {\n      id: start,\n      color: pathNodeColor\n    },\n    links: []\n  });\n\n  for (var i = 0; i < distance; i++) {\n    var nextNode = getRandomStr(8);\n    data.push(makeNewNode(currentNode, nextNode, true));\n\n    for (var j = 0; j < getRandomInt(5); j++) {\n      var adjacentNode = getRandomStr(8);\n      data.push(makeNewNode(nextNode, adjacentNode));\n    }\n\n    currentNode = nextNode;\n  }\n\n  data.push(makeNewNode(currentNode, destination, true));\n  return data;\n}; // generate a list of grapth recursibly sent them in lists \n\nexport const genGrapDepth = (word, depth = 0, data = {\n  nodes: [],\n  links: []\n}) => {\n  // Add word to data nodes \n  data.nodes.push({\n    id: word\n  }); //for word get adjacent words into link data\n\n  if (depth <= 0) return data;\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    //gen a adjecent word\n    var adjacent_word = getRandomStr(8); // Add link \n\n    data.links.push({\n      source: word,\n      target: adjacent_word\n    }); // be a recursive bitch\n\n    genGrapDepth(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/telix/dictio-grapho/src/RandomGenerator.js"],"names":["unselectedNodeColor","selectedNodeColor","pathNodeColor","getRandomInt","max","Math","floor","random","getRandomStr","length","result","characters","charactersLength","i","charAt","getRandomLinks","link_number","word","nodes","seen_targets","links","target","id","includes","push","source","genRandomNode","title","node","genGrapNodes","depth","data","adjacent_word","makeNewNode","prevNode","newNode","path","selected","color","genPath","start","destination","distance","currentNode","nextNode","j","adjacentNode","genGrapDepth"],"mappings":"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","sourcesContent":["const unselectedNodeColor = '#3D3C3A'\nconst selectedNodeColor = '#E41B17'\nconst pathNodeColor = '#17E0E3'\n//const pathLinkColor = '#E41B17'\n\n// function for getting random num\nexport const getRandomInt = (max) => {\n\t\treturn Math.floor(Math.random() * Math.floor(max))+1 ;\n}\n\n// fuction for getting a random string\nexport const getRandomStr = (length) => {\n\t\tvar result           = '';\n\t\tvar characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t\tvar charactersLength = characters.length;\n\t\tfor ( var i = 0; i < length; i++ ) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t\treturn result;\n}\n\n//generate random link\nexport const getRandomLinks = (link_number, word, nodes) => {\n\t\tvar seen_targets = [] \n\t\tvar links = [];\n\t\tfor (var i = 0; i < link_number; i++ ){\n\t\t\t\tvar target = nodes[getRandomInt(nodes.length-1)].id;\n\t\t\t\tif(!seen_targets.includes(target)){\n\t\t\t\t\t\tlinks.push({ source: word, target: target });\n\t\t\t\t\t\tseen_targets.push(target);\n\t\t\t\t}\n\t\t}\n\t\treturn links;\n}\n\n// Generate a random node \nexport const genRandomNode = (nodes) => {\n\t\tvar title = getRandomStr(6);\n\t\tvar links = getRandomLinks(getRandomInt(6), title, nodes);\n\t\treturn { node:{ id: title }, links };\n}\n\n\n// generate a list of grapth recursibly\nexport const genGrapNodes = (word, depth=0, data=[]) =>{\n\t\tfor(var i = 0; i < getRandomInt(3); i++){\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\tdata.push({  node:{id: adjacent_word }, links:[{ source: word, target: adjacent_word }] });\n\t\t\t\tif( depth > 0 ) genGrapNodes(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\nexport const makeNewNode = (prevNode, newNode, path=false, selected=false) => {\n\t\tvar color = (path)? pathNodeColor : (selected)? selectedNodeColor : unselectedNodeColor\n\t\t\t\treturn { \n\t\t\t\t\t\tnode:{ id: newNode, color: color}, \n\t\t\t\t\t\tlinks:[{ source: prevNode, target: newNode, color: color}] \n\t\t\t\t}\n\t\t};\n\n// Generate a Nodes path from  node to the other\nexport const genPath = (start, destination) =>{\n\t\tlet distance  = getRandomInt(10) + 5;\n\t\tlet currentNode = start;\n\t\tlet data = [];\n\t\tdata.push({node:{ id: start, color: pathNodeColor}, links:[] });\n\t\tfor(var i = 0; i < distance; i++){\n\t\t\t\tvar nextNode = getRandomStr(8);\n\t\t\t\tdata.push(makeNewNode(currentNode, nextNode, true));\n\t\t\t\tfor(var j = 0; j < getRandomInt(5); j++){\n\t\t\t\t\t\tvar adjacentNode = getRandomStr(8);\n\t\t\t\t\t\tdata.push(makeNewNode(nextNode, adjacentNode));\n\t\t\t\t}\n\t\t\t\tcurrentNode = nextNode;\n\t\t}\n\t\tdata.push(makeNewNode(currentNode, destination, true));\n\t\treturn data;\n}\n\n\n// generate a list of grapth recursibly sent them in lists \nexport const genGrapDepth = (word, depth=0, data={ nodes:[], links:[] }) =>{\n\t\t// Add word to data nodes \n\t\tdata.nodes.push({ id: word });\n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) return data;\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\t//gen a adjecent word\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\t// Add link \n\t\t\t\tdata.links.push({ source: word, target: adjacent_word });\n\t\t\t\t// be a recursive bitch\n\t\t\t\tgenGrapDepth(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}
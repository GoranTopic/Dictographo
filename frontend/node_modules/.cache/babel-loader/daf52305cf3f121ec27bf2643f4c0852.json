{"ast":null,"code":"module.exports = function eventify(subject) {\n  validateSubject(subject);\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n\n      var handlers = registeredEvents[eventName];\n\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n\n      handlers.push({\n        callback: callback,\n        ctx: ctx\n      });\n      return subject;\n    },\n    off: function (eventName, callback) {\n      var wantToRemoveAll = typeof eventName === 'undefined';\n\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = typeof callback !== 'function';\n\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n\n      for (var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n\n  var reservedWords = ['on', 'fire', 'off'];\n\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/ngraph.events/index.js"],"names":["module","exports","eventify","subject","validateSubject","eventsStorage","createEventsStorage","on","off","fire","registeredEvents","Object","create","eventName","callback","ctx","Error","handlers","push","wantToRemoveAll","deleteAllCallbacksForEvent","callbacks","i","length","splice","fireArguments","arguments","Array","prototype","call","callbackInfo","apply","reservedWords","hasOwnProperty"],"mappings":"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","sourcesContent":["module.exports = function eventify(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import Half from \"./half\";\nexport default function (x, radius) {\n  var data,\n      x0 = this._x0,\n      x1,\n      x2,\n      x3 = this._x1,\n      halves = [],\n      node = this._root,\n      q,\n      i;\n  if (node) halves.push(new Half(node, x0, x3));\n  if (radius == null) radius = Infinity;else {\n    x0 = x - radius;\n    x3 = x + radius;\n  }\n\n  while (q = halves.pop()) {\n    // Stop searching if this half can’t contain a closer node.\n    if (!(node = q.node) || (x1 = q.x0) > x3 || (x2 = q.x1) < x0) continue; // Bisect the current half.\n\n    if (node.length) {\n      var xm = (x1 + x2) / 2;\n      halves.push(new Half(node[1], xm, x2), new Half(node[0], x1, xm)); // Visit the closest half first.\n\n      if (i = +(x >= xm)) {\n        q = halves[halves.length - 1];\n        halves[halves.length - 1] = halves[halves.length - 1 - i];\n        halves[halves.length - 1 - i] = q;\n      }\n    } // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n        var d = Math.abs(x - +this._x.call(null, node.data));\n\n        if (d < radius) {\n          radius = d;\n          x0 = x - d;\n          x3 = x + d;\n          data = node.data;\n        }\n      }\n  }\n\n  return data;\n}","map":{"version":3,"sources":["/home/telix/dictographo/frontend/node_modules/d3-binarytree/src/find.js"],"names":["Half","x","radius","data","x0","_x0","x1","x2","x3","_x1","halves","node","_root","q","i","push","Infinity","pop","length","xm","d","Math","abs","_x","call"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,QAAjB;AAEA,eAAe,UAASC,CAAT,EAAYC,MAAZ,EAAoB;AACjC,MAAIC,IAAJ;AAAA,MACIC,EAAE,GAAG,KAAKC,GADd;AAAA,MAEIC,EAFJ;AAAA,MAGIC,EAHJ;AAAA,MAIIC,EAAE,GAAG,KAAKC,GAJd;AAAA,MAKIC,MAAM,GAAG,EALb;AAAA,MAMIC,IAAI,GAAG,KAAKC,KANhB;AAAA,MAOIC,CAPJ;AAAA,MAQIC,CARJ;AAUA,MAAIH,IAAJ,EAAUD,MAAM,CAACK,IAAP,CAAY,IAAIf,IAAJ,CAASW,IAAT,EAAeP,EAAf,EAAmBI,EAAnB,CAAZ;AACV,MAAIN,MAAM,IAAI,IAAd,EAAoBA,MAAM,GAAGc,QAAT,CAApB,KACK;AACHZ,IAAAA,EAAE,GAAGH,CAAC,GAAGC,MAAT;AACAM,IAAAA,EAAE,GAAGP,CAAC,GAAGC,MAAT;AACD;;AAED,SAAOW,CAAC,GAAGH,MAAM,CAACO,GAAP,EAAX,EAAyB;AAEvB;AACA,QAAI,EAAEN,IAAI,GAAGE,CAAC,CAACF,IAAX,KACG,CAACL,EAAE,GAAGO,CAAC,CAACT,EAAR,IAAcI,EADjB,IAEG,CAACD,EAAE,GAAGM,CAAC,CAACP,EAAR,IAAcF,EAFrB,EAEyB,SALF,CAOvB;;AACA,QAAIO,IAAI,CAACO,MAAT,EAAiB;AACf,UAAIC,EAAE,GAAG,CAACb,EAAE,GAAGC,EAAN,IAAY,CAArB;AAEAG,MAAAA,MAAM,CAACK,IAAP,CACE,IAAIf,IAAJ,CAASW,IAAI,CAAC,CAAD,CAAb,EAAkBQ,EAAlB,EAAsBZ,EAAtB,CADF,EAEE,IAAIP,IAAJ,CAASW,IAAI,CAAC,CAAD,CAAb,EAAkBL,EAAlB,EAAsBa,EAAtB,CAFF,EAHe,CAQf;;AACA,UAAIL,CAAC,GAAG,EAAEb,CAAC,IAAIkB,EAAP,CAAR,EAAoB;AAClBN,QAAAA,CAAC,GAAGH,MAAM,CAACA,MAAM,CAACQ,MAAP,GAAgB,CAAjB,CAAV;AACAR,QAAAA,MAAM,CAACA,MAAM,CAACQ,MAAP,GAAgB,CAAjB,CAAN,GAA4BR,MAAM,CAACA,MAAM,CAACQ,MAAP,GAAgB,CAAhB,GAAoBJ,CAArB,CAAlC;AACAJ,QAAAA,MAAM,CAACA,MAAM,CAACQ,MAAP,GAAgB,CAAhB,GAAoBJ,CAArB,CAAN,GAAgCD,CAAhC;AACD;AACF,KAdD,CAgBA;AAhBA,SAiBK;AACH,YAAIO,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASrB,CAAC,GAAG,CAAC,KAAKsB,EAAL,CAAQC,IAAR,CAAa,IAAb,EAAmBb,IAAI,CAACR,IAAxB,CAAd,CAAR;;AACA,YAAIiB,CAAC,GAAGlB,MAAR,EAAgB;AACdA,UAAAA,MAAM,GAAGkB,CAAT;AACAhB,UAAAA,EAAE,GAAGH,CAAC,GAAGmB,CAAT;AACAZ,UAAAA,EAAE,GAAGP,CAAC,GAAGmB,CAAT;AACAjB,UAAAA,IAAI,GAAGQ,IAAI,CAACR,IAAZ;AACD;AACF;AACF;;AAED,SAAOA,IAAP;AACD","sourcesContent":["import Half from \"./half\";\n\nexport default function(x, radius) {\n  var data,\n      x0 = this._x0,\n      x1,\n      x2,\n      x3 = this._x1,\n      halves = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) halves.push(new Half(node, x0, x3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius;\n    x3 = x + radius;\n  }\n\n  while (q = halves.pop()) {\n\n    // Stop searching if this half can’t contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (x2 = q.x1) < x0) continue;\n\n    // Bisect the current half.\n    if (node.length) {\n      var xm = (x1 + x2) / 2;\n\n      halves.push(\n        new Half(node[1], xm, x2),\n        new Half(node[0], x1, xm)\n      );\n\n      // Visit the closest half first.\n      if (i = +(x >= xm)) {\n        q = halves[halves.length - 1];\n        halves[halves.length - 1] = halves[halves.length - 1 - i];\n        halves[halves.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n      var d = Math.abs(x - +this._x.call(null, node.data));\n      if (d < radius) {\n        radius = d;\n        x0 = x - d;\n        x3 = x + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n}\n"]},"metadata":{},"sourceType":"module"}
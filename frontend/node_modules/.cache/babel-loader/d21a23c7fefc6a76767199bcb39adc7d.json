{"ast":null,"code":"// function for getting random num\nexport const getRandomInt = max => {\n  return Math.floor(Math.random() * Math.floor(max)) + 1;\n}; // fuction for getting a random string\n\nexport const getRandomStr = length => {\n  var result = '';\n  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\n  return result;\n}; //generate random link\n\nexport const getRandomLinks = (link_number, word, nodes) => {\n  var seen_targets = [];\n  var links = [];\n\n  for (var i = 0; i < link_number; i++) {\n    var target = nodes[getRandomInt(nodes.length - 1)].id;\n\n    if (!seen_targets.includes(target)) {\n      links.push({\n        source: word,\n        target: target\n      });\n      seen_targets.push(target);\n    }\n  }\n\n  return links;\n}; // Generate a random node \n\nexport const genRandomNode = nodes => {\n  var title = getRandomStr(6);\n  var links = getRandomLinks(getRandomInt(6), title, nodes);\n  return {\n    node: {\n      id: title\n    },\n    links\n  };\n}; // generate a list of grapth recursibly\n\nexport const genGrapNodes = (word, depth = 0, data = []) => {\n  var curData = {\n    nodes: [],\n    links: []\n  };\n  curData.nodes.push({\n    id: word\n  });\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    var adjacent_word = getRandomStr(8);\n    curData.links.push({\n      source: word,\n      target: adjacent_word\n    });\n  }\n\n  data.push(curData); // Add word to data nodes \n  //for word get adjacent words into link data\n\n  if (depth <= 0) for (link in curData.links) genGrapDepth(link.target, depth - 1, data);\n  return data;\n}; // generate a list of grapth recursibly sent them in lists \n\nexport const genGrapDepth = (word, depth = 0, data = {\n  nodes: [],\n  links: []\n}) => {\n  // Add word to data nodes \n  data.nodes.push({\n    id: word\n  }); //for word get adjacent words into link data\n\n  if (depth <= 0) return data;\n\n  for (var i = 0; i < getRandomInt(6); i++) {\n    //gen a adjecent word\n    var adjacent_word = getRandomStr(8); // Add link \n\n    data.links.push({\n      source: word,\n      target: adjacent_word\n    }); // be a recursive bitch\n\n    genGrapDepth(adjacent_word, depth - 1, data);\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/telix/dictio-grapho/src/RandomGenerator.js"],"names":["getRandomInt","max","Math","floor","random","getRandomStr","length","result","characters","charactersLength","i","charAt","getRandomLinks","link_number","word","nodes","seen_targets","links","target","id","includes","push","source","genRandomNode","title","node","genGrapNodes","depth","data","curData","adjacent_word","link","genGrapDepth"],"mappings":"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","sourcesContent":["\n// function for getting random num\nexport const getRandomInt = (max) => {\n\t\treturn Math.floor(Math.random() * Math.floor(max))+1 ;\n}\n\n// fuction for getting a random string\nexport const getRandomStr = (length) => {\n\t\tvar result           = '';\n\t\tvar characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\t\tvar charactersLength = characters.length;\n\t\tfor ( var i = 0; i < length; i++ ) result += characters.charAt(Math.floor(Math.random() * charactersLength));\n\t\treturn result;\n}\n\n//generate random link\nexport const getRandomLinks = (link_number, word, nodes) => {\n\t\tvar seen_targets = [] \n\t\tvar links = [];\n\t\tfor (var i = 0; i < link_number; i++ ){\n\t\t\t\tvar target = nodes[getRandomInt(nodes.length-1)].id;\n\t\t\t\tif(!seen_targets.includes(target)){\n\t\t\t\t\t\tlinks.push({ source: word, target: target });\n\t\t\t\t\t\tseen_targets.push(target);\n\t\t\t\t}\n\t\t}\n\t\treturn links;\n}\n\n// Generate a random node \nexport const genRandomNode = (nodes) => {\n\t\tvar title = getRandomStr(6);\n\t\tvar links = getRandomLinks(getRandomInt(6), title, nodes);\n\t\treturn { node:{ id: title }, links };\n}\n\n\n// generate a list of grapth recursibly\nexport const genGrapNodes = (word, depth=0, data=[]) =>{\n\t\tvar curData = { nodes:[], links:[] };\n\t\tcurData.nodes.push({ id: word });\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\tcurData.links.push({ source: word, target: adjacent_word });\n\t\t}\n\t\tdata.push(curData);\n\t\t// Add word to data nodes \n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) for(link in curData.links) genGrapDepth(link.target, depth -1, data);\n\t\treturn data;\n}\n\n\n\n// generate a list of grapth recursibly sent them in lists \nexport const genGrapDepth = (word, depth=0, data={ nodes:[], links:[] }) =>{\n\t\t// Add word to data nodes \n\t\tdata.nodes.push({ id: word });\n\t\t//for word get adjacent words into link data\n\t\tif( depth <= 0 ) return data;\n\t\tfor(var i = 0; i < getRandomInt(6); i++){\n\t\t\t\t//gen a adjecent word\n\t\t\t\tvar adjacent_word = getRandomStr(8);\n\t\t\t\t// Add link \n\t\t\t\tdata.links.push({ source: word, target: adjacent_word });\n\t\t\t\t// be a recursive bitch\n\t\t\t\tgenGrapDepth(adjacent_word, depth -1, data);\n\t\t}\n\t\treturn data;\n}\n\n\n\n"]},"metadata":{},"sourceType":"module"}